{"version":3,"sources":["webpack:///es6-editor.min.js","webpack:///webpack/bootstrap 8237b15317773ff973aa","webpack:///./src/js/es6-editor.js","webpack:///./bower_components/jquery/dist/jquery.js?161c","webpack:///./bower_components/jquery/dist/jquery.js?6053","webpack:///./bower_components/jquery/dist/jquery.js","webpack:///./bower_components/foundation/js/foundation/foundation.js","webpack:///./bower_components/foundation/js/foundation/foundation.interchange.js","webpack:///./bower_components/foundation/js/foundation/foundation.reveal.js","webpack:///./bower_components/foundation/js/foundation/foundation.tab.js","webpack:///./~/codemirror/mode/javascript/javascript.js","webpack:///./~/codemirror/lib/codemirror.js?5d7a","webpack:///./~/codemirror/lib/codemirror.js","webpack:///./~/codemirror/mode/htmlmixed/htmlmixed.js","webpack:///./~/codemirror/mode/xml/xml.js","webpack:///./~/codemirror/mode/css/css.js","webpack:///./src/js/babel/repl.js","webpack:///./bower_components/underscore/underscore.js","webpack:///./~/codemirror/addon/comment/comment.js","webpack:///./~/codemirror/keymap/sublime.js","webpack:///./~/codemirror/addon/search/searchcursor.js","webpack:///./~/codemirror/addon/edit/matchbrackets.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_babelRepl","_babelRepl2","weakmap","WeakMap","$","each","index","el","repl","set","this","find","document","foundation","on","event","tab","has","parent","get","refresh","global","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","w","Error","window","noGlobal","isArraylike","length","type","jQuery","isWindow","nodeType","winnow","elements","qualifier","not","isFunction","grep","elem","i","risSimple","test","filter","indexOf","sibling","cur","dir","createOptions","options","object","optionsCache","match","rnotwhite","_","flag","completed","removeEventListener","ready","Data","Object","defineProperty","cache","expando","uid","dataAttr","key","data","name","undefined","replace","rmultiDash","toLowerCase","getAttribute","rbrace","parseJSON","e","data_user","returnTrue","returnFalse","safeActiveElement","activeElement","err","manipulationTarget","content","nodeName","firstChild","getElementsByTagName","appendChild","ownerDocument","createElement","disableScript","restoreScript","rscriptTypeMasked","exec","removeAttribute","setGlobalEval","elems","refElements","l","data_priv","cloneCopyEvent","src","dest","pdataOld","pdataCur","udataOld","udataCur","events","hasData","access","handle","add","extend","getAll","context","tag","ret","querySelectorAll","merge","fixInput","rcheckableType","checked","defaultValue","actualDisplay","doc","style","appendTo","body","display","getDefaultComputedStyle","css","detach","defaultDisplay","elemdisplay","iframe","documentElement","contentDocument","write","close","curCSS","computed","width","minWidth","maxWidth","getStyles","getPropertyValue","contains","rnumnonpx","rmargin","addGetHookIf","conditionFn","hookFn","apply","arguments","vendorPropName","capName","toUpperCase","slice","origName","cssPrefixes","setPositiveNumber","value","subtract","matches","rnumsplit","Math","max","augmentWidthOrHeight","extra","isBorderBox","styles","val","cssExpand","getWidthOrHeight","valueIsBorderBox","offsetWidth","offsetHeight","support","boxSizingReliable","parseFloat","showHide","show","hidden","values","isHidden","Tween","prop","end","easing","prototype","init","createFxNow","setTimeout","fxNow","now","genFx","includeWidth","which","attrs","height","opacity","createTween","animation","tween","collection","tweeners","concat","defaultPrefilter","props","opts","toggle","hooks","oldfire","checkDisplay","anim","orig","dataShow","queue","_queueHooks","unqueued","empty","fire","always","overflow","overflowX","overflowY","rfxtypes","isEmptyObject","done","hide","remove","start","propFilter","specialEasing","camelCase","isArray","cssHooks","expand","Animation","properties","result","stopped","animationPrefilters","deferred","Deferred","tick","currentTime","remaining","startTime","duration","temp","percent","tweens","run","notifyWith","resolveWith","promise","originalProperties","originalOptions","push","stop","gotoEnd","rejectWith","map","fx","timer","progress","complete","fail","addToPrefiltersOrTransports","structure","dataTypeExpression","func","dataType","dataTypes","unshift","inspectPrefiltersOrTransports","jqXHR","inspect","selected","inspected","prefilterOrFactory","dataTypeOrTransport","seekingTransport","transports","ajaxExtend","target","deep","flatOptions","ajaxSettings","ajaxHandleResponses","s","responses","ct","finalDataType","firstDataType","contents","shift","mimeType","getResponseHeader","converters","ajaxConvert","response","isSuccess","conv2","current","conv","tmp","prev","responseFields","dataFilter","split","state","error","buildParams","prefix","traditional","v","rbracket","getWindow","defaultView","arr","class2type","toString","hasOwn","hasOwnProperty","version","selector","fn","rtrim","rmsPrefix","rdashAlpha","fcamelCase","all","letter","jquery","constructor","toArray","num","pushStack","prevObject","callback","args","first","eq","last","len","j","sort","splice","copy","copyIsArray","clone","isPlainObject","random","isReady","msg","noop","Array","isNumeric","globalEval","code","script","indirect","eval","trim","text","head","parentNode","removeChild","string","makeArray","results","inArray","second","invert","callbackInverse","callbackExpect","arg","guid","proxy","Date","Sizzle","seed","groups","old","nid","newContext","newSelector","preferredDoc","setDocument","documentIsHTML","rquickExpr","getElementById","getElementsByClassName","qsa","rbuggyQSA","tokenize","rescape","setAttribute","toSelector","rsibling","testContext","join","qsaError","select","createCache","keys","Expr","cacheLength","markFunction","assert","div","addHandle","handler","attrHandle","siblingCheck","a","b","diff","sourceIndex","MAX_NEGATIVE","nextSibling","createInputPseudo","createButtonPseudo","createPositionalPseudo","argument","matchIndexes","setFilters","tokens","addCombinator","matcher","combinator","base","checkNonElements","doneName","xml","oldCache","outerCache","newCache","dirruns","elementMatcher","matchers","multipleContexts","contexts","condense","unmatched","newUnmatched","mapped","setMatcher","preFilter","postFilter","postFinder","postSelector","preMap","postMap","preexisting","matcherIn","matcherOut","matcherFromTokens","checkContext","leadingRelative","relative","implicitRelative","matchContext","matchAnyContext","outermostContext","matcherFromGroupMatchers","elementMatchers","setMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","dirrunsUnique","pop","uniqueSort","getText","isXML","compile","sortInput","hasDuplicate","docElem","rbuggyMatches","classCache","tokenCache","compilerCache","sortOrder","push_native","list","booleans","whitespace","characterEncoding","identifier","attributes","pseudos","rwhitespace","RegExp","rcomma","rcombinators","rattributeQuotes","rpseudo","ridentifier","matchExpr","ID","CLASS","TAG","ATTR","PSEUDO","CHILD","bool","needsContext","rinputs","rheader","rnative","runescape","funescape","escaped","escapedWhitespace","high","String","fromCharCode","unloadHandler","childNodes","els","node","hasCompare","top","addEventListener","attachEvent","className","createComment","getById","getElementsByName","attrId","getAttributeNode","innerHTML","input","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","compareDocumentPosition","adown","bup","compare","sortDetached","aup","ap","bp","expr","attr","specified","duplicates","detectDuplicates","sortStable","textContent","nodeValue","selectors","createPseudo",">"," ","+","~","excess","unquoted","nodeNameSelector","pattern","operator","check","what","simple","forward","ofType","nodeIndex","useCache","lastChild","pseudo","idx","matched","innerText","lang","elemLang","hash","location","root","focus","hasFocus","href","tabIndex","enabled","disabled","selectedIndex","header","button","even","odd","lt","gt","radio","checkbox","file","password","image","submit","reset","filters","parseOnly","soFar","preFilters","cached","token","compiled","div1","unique","isXMLDoc","rneedsContext","rsingleTag","self","is","rootjQuery","parseHTML","rparentsprev","guaranteedUnique","children","next","until","truncate","n","targets","closest","pos","prevAll","addBack","parents","parentsUntil","nextAll","nextUntil","prevUntil","siblings","reverse","Callbacks","memory","fired","firing","firingStart","firingLength","firingIndex","stack","once","stopOnFalse","disable","lock","locked","fireWith","tuples","then","fns","newDefer","tuple","returned","resolve","reject","notify","pipe","stateString","when","subordinate","progressValues","progressContexts","resolveContexts","resolveValues","updateFunc","readyList","readyWait","holdReady","hold","wait","triggerHandler","off","readyState","chainable","emptyGet","raw","bulk","acceptData","owner","accepts","descriptor","unlock","defineProperties","stored","camel","discard","removeData","_data","_removeData","camelKey","dequeue","startLength","setter","clearQueue","count","defer","pnum","source","fragment","createDocumentFragment","checkClone","cloneNode","noCloneChecked","strundefined","focusinBubbles","rkeyEvent","rmouseEvent","rfocusMorph","rtypenamespace","types","handleObjIn","eventHandle","t","handleObj","special","handlers","namespaces","origType","elemData","triggered","dispatch","delegateType","bindType","namespace","delegateCount","setup","mappedTypes","origCount","teardown","removeEvent","trigger","onlyHandlers","bubbleType","ontype","eventPath","Event","isTrigger","namespace_re","noBubble","parentWindow","isPropagationStopped","preventDefault","isDefaultPrevented","_default","fix","handlerQueue","delegateTarget","preDispatch","currentTarget","isImmediatePropagationStopped","stopPropagation","postDispatch","sel","fixHooks","keyHooks","original","charCode","keyCode","mouseHooks","eventDoc","pageX","clientX","scrollLeft","clientLeft","pageY","clientY","scrollTop","clientTop","originalEvent","fixHook","load","blur","click","beforeunload","returnValue","simulate","bubble","isSimulated","defaultPrevented","timeStamp","stopImmediatePropagation","mouseenter","mouseleave","pointerenter","pointerleave","related","relatedTarget","attaches","one","origFn","rxhtmlTag","rtagName","rhtml","rnoInnerhtml","rchecked","rscriptType","rcleanScript","wrapMap","option","thead","col","tr","td","optgroup","tbody","tfoot","colgroup","caption","th","dataAndEvents","deepDataAndEvents","srcElements","destElements","inPage","buildFragment","scripts","selection","wrap","nodes","createTextNode","cleanData","append","domManip","prepend","insertBefore","before","after","keepData","html","replaceWith","replaceChild","hasScripts","iNoClone","_evalUrl","prependTo","insertAfter","replaceAll","insert","opener","getComputedStyle","computePixelPositionAndBoxSizingReliable","cssText","container","divStyle","pixelPositionVal","boxSizingReliableVal","backgroundClip","clearCloneStyle","pixelPosition","reliableMarginRight","marginDiv","marginRight","swap","rdisplayswap","rrelNum","cssShow","position","visibility","cssNormalTransform","letterSpacing","fontWeight","cssNumber","columnCount","fillOpacity","flexGrow","flexShrink","lineHeight","order","orphans","widows","zIndex","zoom","cssProps","float","margin","padding","border","suffix","expanded","parts","unit","propHooks","eased","step","linear","swing","cos","PI","timerId","rfxnum","rrun","*","scale","maxIterations","tweener","prefilter","speed","opt","speeds","fadeTo","to","animate","optall","doAnimation","finish","stopQueue","timers","cssFn","slideDown","slideUp","slideToggle","fadeIn","fadeOut","fadeToggle","interval","setInterval","clearInterval","slow","fast","delay","time","timeout","clearTimeout","checkOn","optSelected","optDisabled","radioValue","nodeHook","boolHook","removeAttr","nType","attrHooks","propName","attrNames","propFix","getter","rfocusable","removeProp","for","class","notxml","hasAttribute","rclass","addClass","classes","clazz","finalValue","proceed","removeClass","toggleClass","stateVal","classNames","hasClass","rreturn","valHooks","optionSet","hover","fnOver","fnOut","bind","unbind","delegate","undelegate","nonce","rquery","JSON","parse","parseXML","DOMParser","parseFromString","rhash","rts","rheaders","rlocalProtocol","rnoContent","rprotocol","rurl","prefilters","allTypes","ajaxLocation","ajaxLocParts","active","lastModified","etag","url","isLocal","processData","async","contentType","json","* text","text html","text json","text xml","ajaxSetup","settings","ajaxPrefilter","ajaxTransport","ajax","status","nativeStatusText","headers","success","modified","statusText","timeoutTimer","transport","responseHeadersString","ifModified","cacheURL","callbackContext","statusCode","fireGlobals","globalEventContext","completeDeferred","responseHeaders","requestHeaders","requestHeadersNames","strAbort","getAllResponseHeaders","setRequestHeader","lname","overrideMimeType","abort","finalText","method","crossDomain","param","hasContent","beforeSend","send","getJSON","getScript","throws","wrapAll","firstElementChild","wrapInner","unwrap","visible","r20","rCRLF","rsubmitterTypes","rsubmittable","encodeURIComponent","serialize","serializeArray","xhr","XMLHttpRequest","xhrId","xhrCallbacks","xhrSuccessStatus",0,1223,"xhrSupported","cors","open","username","xhrFields","onload","onerror","responseText","text script","charset","scriptCharset","evt","oldCallbacks","rjsonp","jsonp","jsonpCallback","originalSettings","callbackName","overwritten","responseContainer","jsonProp","keepScripts","parsed","_load","params","animated","offset","setOffset","curPosition","curLeft","curCSSTop","curTop","curOffset","curCSSLeft","calculatePosition","curElem","left","using","win","box","getBoundingClientRect","pageYOffset","pageXOffset","offsetParent","parentOffset","scrollTo","Height","Width","","defaultExtra","funcName","size","andSelf","_jQuery","_$","noConflict","removeQuotes","MediaQuery","query","header_helpers","class_array","class_name","FastClick","attach","S","cont","attr_name","add_namespace","str","bindings","$this","should_bind_events","data_options","scope","single_image_loaded","bindLoad","navigator","userAgent","getTime","matchMedia","styleMedia","media","info","currentStyle","matchMedium","styleSheet","raf","animating","requestAnimationFrame","jqueryFxAvailable","lastTime","vendors","cancelAnimationFrame","currTime","timeToCall","Foundation","media_queries","small","small-only","medium","medium-only","large","large-only","xlarge","xlarge-only","xxlarge","stylesheet","sheet","libraries","rtl","set_namespace","libs","init_lib","lib","patch","defaults","utils","inherit","methods","methods_arr","throttle","debounce","immediate","later","callNow","data_attr_name","isNumber","o","isNaN","ii","opts_arr","cached_options","parseInt","register_media","media_class","add_custom_rule","rule","insertRule","cssRules","image_loaded","images","pictures_has_height","pictures_number","unloaded","random_str","fidx","mq","is_small_up","is_medium_up","is_large_up","is_xlarge_up","is_xxlarge_up","is_small_only","is_medium_only","is_large_only","is_xlarge_only","is_xxlarge_only","interchange","images_loaded","nodes_loaded","load_attr","named_queries","landscape","portrait","retina","directives","path","orig_path","last_path","data_attr","set_data_attr","reflow","get_media_hash","mediaHash","queryName","prevMediaHash","currMediaHash","resize","uuid","passed","scenario","scenarios","force_update","update_images","loaded_count","cached_images","enhance","update_nodes","cached_nodes","convert_directive","directive","trimmed","parse_scenario","directive_match","media_query","cached_split","raw_arr","parse_data_attr","store","current_uuid","output","getAnimationData","fade","openModals","reveal","animation_speed","close_on_background_click","close_on_esc","dismiss_modal_class","multiple_opened","bg_class","root_element","opened","closed","on_ajax_error","bg","element","replaceContentSel","close_targets","bg_clicked","open_video","close_video","key_up_on","open_modal","key_up_off","ajax_settings","modal","cache_offset","toggle_bg","openModal","to_back","old_success","textStatus","open_modals","to_front","isCurrent","elt","isThis","placeholder","animData","end_css","video","data_src","scrollY","active_class","deep_linking","scroll_to_content","is_hover","default_tab_hashes","handle_location_hash_change","usual_tab_behavior","Modernizr","touch","toggle_active_tab","hash_element","hash_tab_container_id","ind","location_hash","tabs","tab_link","anchor","target_hash","interpret_keyup_action","$target","$original","$prev","$next","tabindex","aria-selected","substring","go_to_hash","default_hash","scrollIntoView","aria-hidden","mod","CodeMirror","defineMode","config","parserConfig","readRegexp","stream","inSet","tp","tokenBase","ch","tokenString","eat","eatWhile","tokenComment","skipToEnd","lastType","isOperatorChar","tokenQuasi","wordRE","word","known","keywords","propertyIsEnumerable","quote","jsonldMode","peek","isJsonldKeyword","maybeEnd","findFatArrow","fatArrowAt","arrow","depth","sawSomething","charAt","bracket","brackets","JSLexical","indented","column","align","inScope","varname","localVars","cx","vars","parseJS","cc","marked","lexical","jsonMode","expression","statement","lex","pass","register","inList","globalVars","pushcontext","defaultVars","popcontext","pushlex","indent","outer","poplex","expect","wanted","exp","vardef","block","maybeelse","functiondef","forspec","maybelabel","funarg","afterExport","afterImport","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","atomicTypes","maybeexpressionNoComma","maybeexpression","comprehension","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","me","property","continueQuasi","targetNoComma","getterSetter","afterprop","maybetype","isTS","typedef","maybedefault","maybeAssign","vardefCont","proppattern","_type","forspec1","forspec2","formaybeinof","forspec3","classNameAfter","classBody","classGetterSetter","maybeFrom","importSpec","maybeAs","maybeArrayComprehension","isContinuedStatement","textAfter","indentUnit","statementIndent","jsonld","typescript","wordCharacters","kw","A","B","C","atom","jsKeywords","if","while","with","else","do","try","finally","return","break","continue","new","delete","throw","debugger","var","const","let","function","catch","switch","case","in","typeof","instanceof","true","false","null","NaN","Infinity","super","await","yield","export","import","extends","tsKeywords","interface","public","private","protected","static","number","boolean","any","variable","regexp","jsonld-keyword","startState","basecolumn","sol","indentation","eatSpace","Pass","firstChar","closing","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","lineComment","fold","closeBrackets","helperType","registerHelper","defineMIME","place","copyObj","setGuttersForLineNumbers","Doc","mode","lineSeparator","inputStyles","inputStyle","Display","wrapper","updateGutters","themeChanged","lineWrapping","autofocus","mobile","initScrollbars","keyMaps","overlays","modeGen","overwrite","delayingBlurEvent","focused","suppressEdits","pasteIncoming","cutIncoming","selectingText","draggingText","highlight","Delayed","keySeq","specialChars","cm","ie","ie_version","registerEventHandlers","ensureGlobalHandlers","startOperation","curOp","forceUpdate","attachDoc","onFocus","onBlur","optionHandlers","Init","maybeUpdateLineNumberWidth","finishInit","initHooks","endOperation","webkit","lineDiv","textRendering","d","scrollbarFiller","gutterFiller","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","mover","sizer","sizerWidth","heightForcer","scrollerGap","gutters","lineGutter","scroller","paddingRight","gecko","draggable","viewFrom","viewTo","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","selForContextMenu","activeTouch","loadMode","getMode","modeOption","resetModeState","iter","line","stateAfter","frontier","startWorker","regChange","wrappingChanged","rmClass","findMaxLine","estimateLineHeights","clearCaches","updateScrollbars","estimateHeight","textHeight","wrapping","perLine","clientWidth","charWidth","lineIsHidden","widgetsHeight","widgets","ceil","est","estHeight","updateLineHeight","theme","guttersChanged","alignHorizontally","specs","removeChildren","gutterClass","gElt","updateGutterSpace","marginLeft","lineLength","merged","collapsedSpanAtStart","found","from","collapsedSpanAtEnd","getLine","lineNumbers","measureForScrollbars","gutterW","docH","round","paddingVert","clientHeight","viewHeight","scrollWidth","viewWidth","barLeft","fixedGutter","docHeight","scrollHeight","scrollGap","gutterWidth","NativeScrollbars","scroll","vert","horiz","checkedOverlay","minHeight","NullScrollbars","scrollbars","clear","scrollbarModel","scrollbarStyle","axis","setScrollLeft","setScrollTop","startWidth","startHeight","updateScrollbarsInner","updateHeightsInViewport","sizes","update","right","paddingBottom","bottom","coverGutterNextToScrollbar","visibleLines","viewport","floor","paddingTop","lineAtHeight","ensure","ensureFrom","ensureTo","heightAtLine","min","lastLine","comp","compensateForHScroll","gutter","alignable","lineNumberFor","innerW","lineNumberFormatter","firstLineNumber","DisplayUpdate","force","editorIsHidden","wrapperHeight","wrapperWidth","oldDisplayWidth","displayWidth","dims","getDimensions","maybeClipScrollbars","marginBottom","borderRightWidth","updateDisplayIfNeeded","resetView","countDirtyView","viewportMargin","sawCollapsedSpans","visualLineNo","visualLineEndNo","different","adjustView","toUpdate","activeElt","patchDisplay","postUpdateDisplay","displayHeight","barMeasure","updateSelection","setDocumentHeight","signal","updateDisplaySimple","total","prevBottom","offsetTop","bot","updateWidgetHeight","rest","gutterLeft","offsetLeft","fixedPos","gutterTotalWidth","updateNumbersFrom","rm","mac","currentWheelTarget","lineN","lineView","updateNumber","lineNumber","changes","updateLineForChanges","buildLineElement","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","updateLineBackground","cls","bgClass","background","getLineContent","ext","built","buildLineContent","pre","textClass","wrapClass","gutterBackground","markers","gutterMarkers","gutterWrap","setUneditable","k","insertLineWidgets","insertLineWidgetsFor","allowAbove","ws","widget","handleMouseEvents","positionLineWidget","above","signalLater","noHScroll","coverGutter","paddingLeft","copyPos","x","Pos","maxPos","cmp","minPos","ensureFocus","isReadOnly","readOnly","cantEdit","applyTextInput","inserted","deleted","origin","paste","textLines","splitLines","multiPaste","ranges","lastCopied","range","lst","updateInput","changeEvent","makeChange","triggerElectric","ensureCursorVisible","typing","handlePaste","pasted","clipboardData","getData","disableInput","runInOp","electricChars","smartIndent","getModeAt","indentLine","copyableRanges","lineRange","getRange","disableBrowserMagic","field","TextareaInput","prevInput","pollingFast","polling","inaccurateSelection","hasSelection","composing","hiddenTextarea","te","ios","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","gracePeriod","posToDOM","findViewForLine","mapFromLineView","getOrder","side","partPos","getBidiPartAt","nodeAndOffsetInLineMap","collapse","badPos","bad","domToPos","lineNode","clipPos","locateNodeInLineView","textNode","topNode","maps","curNode","lineNo","dist","previousSibling","domTextBetween","fromLine","toLine","recognizeMarker","marker","walk","cmText","markerID","findMarks","getBetween","lineSep","Selection","primIndex","Range","normalizeSelection","prim","inv","simpleSelection","clipLine","clipToLen","linelen","isLine","clipPosArray","array","out","extendRange","other","posBefore","extendSelection","setSelection","primary","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","filterSelectionChange","setSelectionReplaceHistory","history","setSelectionNoUndo","addSelectionToHistory","hasHandler","bias","setSelectionInner","skipAtomicInSelection","equals","selectionChanged","signalCursorActivity","reCheckSelection","sel_dontScroll","mayClear","newAnchor","skipAtomic","newHead","flipped","curPos","search","markedSpans","sp","inclusiveLeft","inclusiveRight","explicitlyCleared","atomic","newPos","showSelection","prepareSelection","curFragment","cursors","selFragment","collapsed","showCursorWhenSelecting","drawSelectionCursor","drawSelectionRange","cursorCoords","singleCursorHeightPerLine","cursor","cursorHeight","otherCursor","rightSide","drawForLine","fromArg","toArg","coords","charCoords","lineObj","lineLen","iterateBidiSections","rightPos","leftPos","leftSide","paddingH","sFrom","sTo","singleVLine","visualLine","leftEnd","rightStart","restartBlink","blinker","cursorBlinkRate","highlightWorker","workTime","copyState","getStateBefore","changedLines","oldStyles","tooLong","maxHighlightLength","highlighted","highlightLine","oldCls","styleClasses","newCls","ischange","processLine","workDelay","regLineChange","findStartLine","precise","minindent","minline","lim","innerMode","countColumn","tabSize","save","removeChildrenAndAdd","ensureLineHeights","rect","curWidth","heights","rects","getClientRects","abs","caches","updateExternalMeasurement","LineView","measureChar","measureCharPrepared","prepareMeasureForLine","findViewIndex","hasHeights","prepared","varHeight","measureCharInner","bogus","rtop","rbottom","mStart","mEnd","insertLeft","coverStart","coverEnd","isExtendingChar","nullRect","maybeUpdateRectForZooming","rSpan","rbot","mid","screen","logicalXDPI","deviceXDPI","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","pageScrollX","pageScrollY","intoCoordSystem","widgetHeight","yOff","lOff","xOff","fromCoordSystem","localBox","lineSpaceBox","preparedMeasure","getBidi","part","level","bidiLeft","bidiRight","bidiOther","estimateCoords","PosWithInfo","outside","xRel","coordsChar","y","coordsCharInner","mergedPos","getX","wrongLine","innerOff","adjust","bidi","lineLeft","lineRight","fromX","fromOutside","toX","toOutside","moveVisually","xDiff","middle","middleX","measureText","viewChanged","changeObjs","cursorActivityHandlers","cursorActivityCalled","updateMaxLine","scrollToPos","nextOpId","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","callbacks","op","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","endOperation_finish","mustUpdate","updatedDisplay","adjustWidthTo","maxScrollLeft","preparedSelection","forceScroll","scrollPosIntoView","isCursor","maybeScrollWindow","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","lines","f","operation","methodOp","docMethodOp","visualLineContinued","buildViewArray","nextPos","lendiff","cut","viewCuttingPoint","cutTop","cutBot","oldN","newN","dirty","finishTouch","touchFinished","prevTouch","isMouseLikeTouchEvent","touches","radiusX","radiusY","farAway","dx","dy","onMouseDown","signalDOMEvent","posFromMouse","clickInGutter","eventInWidget","e_preventDefault","findWordAt","captureRightClick","onContextMenu","moved","onScrollWheel","dragFunctions","enter","e_stop","over","onDragOver","onDragStart","drop","onDrop","leave","clearDragCursor","inp","getField","onKeyUp","onKeyDown","onKeyPress","dragDropChanged","wasOn","funcs","onResize","setSize","e_target","liberal","forRect","space","colDiff","supportsTouch","shiftKey","e_button","leftButtonDown","lastMiddleDown","delayBlurEvent","lastDoubleClick","lastClick","contained","modifier","metaKey","ctrlKey","dragDrop","dragAndDrop","leftButtonStartDrag","leftButtonSelect","dragEnd","e2","addNew","extendTo","lastPos","startCol","posCol","findColumn","startSel","ourIndex","oldRange","ourRange","sel_mouse","curCount","counter","editorSize","move","up","lastSelOrigin","altKey","gutterEvent","prevent","signalfn","mX","mY","lineBox","e_defaultPrevented","g","lastDrop","files","dataTransfer","FileReader","File","read","loadFile","allowDropFileTypes","reader","change","changeEnd","readAsText","listSelections","replaceRange","replaceSelection","setData","getSelection","setDragImage","safari","img","presto","_top","frag","dragCursor","isScroller","delta","wheelEventDelta","canScrollX","canScrollY","wheelPixelsPerUnit","pixels","wheelSamples","movedX","movedY","sample","doHandleBinding","bound","dropShift","commands","ensurePolled","prevShift","lookupKeyForEditor","lookupKey","extraKeys","keyMap","dispatchKey","seq","isModifierKey","stopSeq","handleKeyBinding","keyName","motion","handleCharBinding","handled","lastStoppedKey","hasCopyEvent","showCrossHair","receivedFocus","contextMenuInGutter","adjustForChange","computeSelAfterChange","offsetPos","nw","computeReplacedSel","hint","oldPrev","newPrev","filterChange","canceled","cancel","ignoreReadOnly","sawReadOnlySpans","removeReadOnlyRanges","makeChangeInner","selAfter","addChangeToHistory","makeChangeSingleDoc","stretchSpansOverChange","rebased","linkedDocs","sharedHist","rebaseHist","makeChangeFromHistory","allowSelectionOnly","hist","undone","lastOrigin","pushSelectionToHistory","clearRedo","antiChanges","generation","maxGeneration","historyChangeFromChange","mergeOldSpans","shiftDoc","distance","spans","removed","makeChangeSingleDocInEditor","updateDoc","recomputeMaxLength","checkWidthStart","full","isWholeLineUpdate","changesHandler","changeHandler","doScroll","innerHeight","phantom","scrollNode","limit","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","x1","y1","x2","y2","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollPos","resolveScrollToPos","getCursor","cursorScrollMargin","sPos","how","aggressive","curSpace","curSpaceString","indentString","indentWithTabs","spaceStr","changeLine","changeType","no","deleteNearSelection","compute","kill","toKill","replaced","findPosH","visually","findNextLine","possible","moveOnce","boundToLine","moveLogically","origDir","sawType","helper","getHelper","isWordChar","hitSide","findPosV","pageSize","deflt","notOnInit","normalizeKeyName","alt","ctrl","cmd","getKeyMap","markText","shared","markTextShared","TextMarker","clearWhenEmpty","replacedWith","widgetNode","conflictingCollapsedRange","addToHistory","curLine","addMarkedSpan","MarkedSpan","clearOnEnter","clearHistory","nextMarkerId","title","startStyle","endStyle","linked","isParent","SharedTextMarker","findSharedMarkers","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","getMarkedSpanFor","span","removeMarkedSpan","r","attachLine","markedSpansBefore","startCh","isInsert","startsBefore","endsAfter","markedSpansAfter","endCh","oldFirst","oldLast","sameLine","clearEmptySpans","newMarkers","gapMarkers","gap","getOldSpans","stretched","oldCur","stretchCur","mark","mk","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","vis","lineIsHiddenInner","adjustScrollWhenAboveVisible","parentStyle","addLineWidget","LineWidget","insertAt","aboveVisible","updateLine","cleanUpLine","extractLineClasses","lineClass","callBlankLine","blankLine","inner","readToken","takeToken","asArray","getObj","StringStream","eol","runMode","lineClasses","forceToEnd","flattenSpans","curStart","curStyle","addModeClass","mName","st","overlay","at","i_end","opaque","getLineStyles","updateFrontier","startAt","interpretTokenStyle","styleToClassCacheWithMode","styleToClassCache","builder","splitSpaces","getOption","addToken","buildToken","hasBadBidiRects","buildTokenBadBidi","allowFrontierUpdate","insertLineContent","joinClasses","zeroWidthElement","defaultSpecialCharPlaceholder","charCodeAt","displayText","mustWrap","lastIndex","skipped","txt","tabWidth","specialCharPlaceholder","fullStyle","buildCollapsedSpan","ignoreWidget","needsContentAttribute","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","foundBookmarks","upto","tokenText","wholeLineUpdateBefore","spansFor","linesFor","Line","firstLine","lastText","lastSpans","nlines","added","LeafChunk","BranchChunk","chunkSize","sharedHistOnly","propagate","skip","rel","chunk","child","sz","getLines","h","lh","bidiOrdering","History","startGen","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","opId","historyEventDelay","selectionEventCanBeMerged","somethingSelected","existing","removeClearedSpans","copyHistoryArray","newGroup","instantiateSel","deepCopy","newChanges","Number","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","srcElement","getHandlers","emitter","_handlers","noHandlers","bnd","orphanDelayedCallbacks","fireOrphanDelayed","delayed","override","codemirrorIgnore","cursorActivity","eventMixin","ctor","spaceStrs","nothing","createObj","inst","create","isWordCharBasic","isEmpty","extendingChars","classTest","as","forEachCodeMirror","byClass","globalsRegistered","registerGlobalHandlers","resizeTimer","zwspSupported","badBidiRects","r0","r1","badZoomedRects","normal","fromRange","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","compareBidiLevel","linedir","moveInLine","byUnit","platform","ie_upto10","ie_11up","documentMode","qtwebkit","chrome","vendor","mac_geMountainLion","windows","presto_version","flipCtrlCmd","needsH","needsV","sWidth","totalHeight","totalWidth","overlayHack","barMouseDown","native","cmpPos","prepareCopyCut","getSelections","selectInput","lineWiseCopyCut","setSelections","textarea","poll","fastPoll","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","minimal","resetPosition","slowPoll","pollInterval","missed","execCommand","same","prepareSelectAllHack","selectionStart","extval","selectionEnd","rehide","oldCSS","selectAll","detectingSelectAll","resetSelectionOnContextMenu","oldScrollY","mouseup","readOnlyChanged","onCopyCut","clearData","kludge","hadFocus","startData","ours","applyComposition","forceCompositionEnd","pollContent","showPrimarySelection","showMultipleSelections","curAnchor","anchorNode","anchorOffset","curFocus","focusNode","focusOffset","rangeCount","getRangeAt","rng","removeAllRanges","addRange","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","pollSelection","fromIndex","fromNode","toIndex","toNode","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","contenteditable","here","there","wheelDeltaX","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","spec","modeSpec","removeOverlay","indentSelection","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","helpers","help","_global","pred","getStateAfter","defaultTextHeight","defaultCharWidth","setGutterMarker","gutterID","clearGutter","lineInfo","getViewport","addWidget","vspace","hspace","triggerOnKeyDown","triggerOnKeyPress","triggerOnKeyUp","amount","moveH","extendSelectionsBy","rtlMoveVisually","sel_move","deleteH","goalColumn","moveV","goals","startChar","toggleOverwrite","getScrollInfo","interpret","oldHeight","swapDoc","getInputField","getWrapperElement","getScrollerElement","getGutterElement","setValue","newBreaks","integer","modes","mimeModes","dependencies","mime","resolveMode","mfactory","modeObj","modeExtensions","exts","modeProps","extendMode","defineExtension","defineDocExtension","defineOption","defineInitHook","registerGlobalHelper","predicate","nstate","a1","a2","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","undo","redo","undoSelection","redoSelection","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","goLineDown","goPageUp","goPageDown","goCharLeft","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentMore","indentLess","insertTab","insertSoftTab","spaces","replaceSelections","defaultTab","transposeChars","newlineAndIndent","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","fallthrough","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","normalizeKeyMap","keymap","keyname","keyNames","noShift","altGraphKey","fromTextArea","getValue","form","leaveSubmitMethodAlone","realSubmit","wrappedSubmit","getTextArea","toTextArea","lastColumnPos","lastColumnValue","skipTo","backUp","consume","caseInsensitive","cased","substr","hideFirstChars","withOp","dHeight","oldH","removeInner","insertInner","iterN","spilled","newleaf","maybeSpill","myIndex","used","nextDocId","cleanGeneration","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","setCursor","addSelection","dup","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","addLineClass","where","removeLineClass","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","indexFromPos","copyHistory","linkedDoc","unlinkDoc","link","splitIds","iterLinkedDocs","getEditor","splitLinesAuto","eachLine","dontDelegate","e_stopPropagation","cancelBubble","detachEvent","ms","startIndex","startValue","nextTab","goal","_e","nonASCIISingleCaseWordChar","createRange","endNode","setEnd","setStart","createTextRange","moveToElementText","moveEnd","moveStart","host","nl","rt","parentElement","compareEndPoints","oncopy",3,8,9,13,16,17,18,19,20,27,32,33,34,35,36,37,38,39,40,44,45,46,59,61,91,92,93,106,107,109,110,111,127,173,186,187,188,189,190,191,192,219,220,221,222,63232,63233,63234,63235,63272,63273,63275,63276,63277,63302,"charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","nstart","maybeBackup","pat","getAttrRegexp","attrRegexpCache","getAttrValue","getTagRegexp","tagName","anchored","addTags","findMatchingMode","tagInfo","defaultTags","htmlState","tags","htmlMode","endTagA","endTag","localState","localMode","multilineTagIndentFactor","multilineTagIndentPastTag","configTags","configScript","scriptTypes","local","inText","chain","parser","inBlock","doctype","inTag","baseState","tagStart","inAttribute","stringStartCol","closure","isInAttribute","terminator","Context","startOfLine","Kludges","doNotIndent","noIndent","popContext","maybePopContext","nextTagName","parentTagName","contextGrabbers","tagNameState","closeTagNameState","setStyle","attrState","implicitlyClosed","closeState","closeStateErr","_stream","attrEqState","autoSelfClosers","attrValueState","allowMissing","attrContinuedState","allowUnquoted","area","br","command","embed","frame","hr","keygen","meta","track","wbr","menuitem","dd","li","rp","dt","address","article","aside","blockquote","dl","fieldset","footer","h1","h2","h3","h4","h5","h6","hgroup","menu","nav","ol","section","table","ul","caseFold","alignCDATA","isInText","fullLine","tagAfter","grabbers","configuration","keySet","tokenCComment","tokenHooks","tokenParenthesized","pushContext","states","popAndPass","wordAsValue","valueKeywords","colorKeywords","provided","propertyKeywords","inline","documentTypes","mediaTypes","mediaFeatures","mediaValueKeywords","nonStandardPropertyKeywords","fontProperties","counterDescriptors","allowNested","supportsAtComponent","stateArg","maybeprop","propBlock","parens","atBlock","atComponentBlock","atBlock_parens","restricted_atBlock_before","restricted_atBlock","keyframes","interpolation","documentTypes_","mediaTypes_","mediaFeatures_","mediaValueKeywords_","propertyKeywords_","nonStandardPropertyKeywords_","fontProperties_","counterDescriptors_","colorKeywords_","valueKeywords_","allWords","/",":","#","@","&","_classCallCheck","instance","Constructor","TypeError","_createClass","enumerable","configurable","writable","protoProps","staticProps","_underscore","_underscore2","_codemirrorLibCodemirror","_codemirrorLibCodemirror2","BabelREPL","$context","_this","$consoleReporter","$output","$toggleFullScreen","editorCompiled","matchBrackets","editor","handleCodeChange","changeObj","transformed","babel","transform","evaluate","message","flush","buffer","capturingConsole","console","log","debug","Function","logs","reduce","outerHTML","stringify","myRequire","createReduce","iterator","iteratee","memo","currentKey","optimizeCb","isArrayLike","createPredicateIndexFinder","cb","getLength","createIndexFinder","predicateFind","sortedIndex","item","collectNonEnumProps","nonEnumIdx","nonEnumerableProps","proto","ObjProto","previousUnderscore","ArrayProto","FuncProto","nativeIsArray","nativeKeys","nativeBind","nativeCreate","Ctor","_wrapped","VERSION","argCount","accumulator","identity","isObject","createAssigner","keysFunc","undefinedOnly","baseCreate","MAX_ARRAY_INDEX","pow","forEach","collect","foldl","inject","reduceRight","foldr","detect","findIndex","findKey","negate","every","some","includes","include","guard","invoke","isFunc","pluck","findWhere","lastComputed","shuffle","rand","shuffled","sortBy","criteria","behavior","groupBy","indexBy","countBy","partition","take","initial","tail","compact","flatten","shallow","strict","isArguments","without","difference","uniq","isSorted","isBoolean","seen","union","intersection","argsLength","zip","unzip","findLastIndex","low","lastIndexOf","executeBound","sourceFunc","boundFunc","callingContext","partial","boundArgs","bindAll","memoize","hasher","previous","leading","trailing","timestamp","compose","times","hasEnumBug","allKeys","mapObject","pairs","functions","names","extendOwn","assign","pick","oiteratee","omit","tap","interceptor","isMatch","aStack","bStack","areArrays","aCtor","bCtor","isEqual","isString","isElement","Int8Array","isFinite","isNull","isUndefined","constant","propertyOf","accum","escapeMap","<","\"","'","`","unescapeMap","createEscaper","escaper","testRegexp","replaceRegexp","escape","unescape","fallback","idCounter","uniqueId","templateSettings","interpolate","noMatch","escapes","\\","\r","\n"," "," ","escapeChar","template","oldSettings","render","_chain","mixin","valueOf","toJSON","nonWS","noOptions","toggleComment","minLine","uncomment","commentString","fullLines","blockComment","pad","blankLines","commentBlankLines","baseString","startString","endString","lastLineHasText","lead","blockCommentLead","didSomething","lineString","endPos","startLine","endLine","lastStart","firstEnd","almostLastStart","openEnd","foundEnd","findPosSubword","cat","moveSubword","insertLine","newSelection","wordAt","selectBetweenBrackets","opening","scanForBracket","mirror","sortLines","caseSensitive","toSort","au","bu","modifyWordOrSelection","indices","replacements","getTarget","findAndGoTo","getSearchCursor","findNext","findPrevious","sublime","cmds","scrollLineCombo","visibleBottomLine","visibleTopLine","lineRanges","extended","fullWord","sublimeFindFullWord","swapLineCombo","linesToMove","newSels","joined","actual","marks","sublimeBookmarks","sublimeBookmark","cK","toStartOfLine","prevIndent","sublimeMark","sublimeKilled","primaryIndex","SearchCursor","atOccurrence","ignoreCase","cutOff","newMatch","matchLen","origQuery","adjustPos","origTarget","ln","folded","pos1","len1","savePosAndFail","findMatchingBracket","matching","maxScanLen","maxScanLineLength","maxScanLines","re","bracketRegex","autoclear","maxHighlightLen","maxHighlightLineLength","ie_lt8","doMatchBrackets","currentlyHighlighted","(",")","[","]","{","}"],"mappings":"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,iEACA,2DACA,iEACA,yDACA,8DACA,oDACA,iEACA,uDACA,uEACA,+DACA,gEACA,sEACA,kEACA,sEACA,qEACA,6DACA,qEACA,qEACA,wDACA,gDACA,wDACA,qEACA,mEACA,mEACA,8EACA,qFACA,4DACA,wEACA,wEACA,sEACA,sEACA,+DACA,8DACA,8DACA,gEACA,6DACA,gEACA,4DACA,oEACA,0DACA,2DACA,kEACA,sEACA,+DACA,sCACA,iEACA,sEACA,wEACA,kEACA,iEACA,oEACA,sEACA,8DACA,yEACA,iEACA,kFACA,yDACA,wEACA,8DACA,mEACA,sEACA,8DACA,6DACA,0EACA,oFACA,mEACA,sDACA,kEACA,+DACA,uEACA,oEACA,qCAEA,0EACA,8EACA,oDACA,sEACA,6EACA,0EACA,qEACA,oEACA,2DACA1B,EAAAX,EAAAqC,GAEAC,GACA,6EACA,4EACA,kEACA,kFACA,yCACArB,EAAAjB,EAAAsC,GAEAC,GACA,2EACA,2CACArB,EAAAlB,EAAAuC,GAEAC,GACA,gEACA,wCACArB,EAAAnB,EAAAwC,GAEAC,GACA,+DACA,8DACA,0EACA,kEACA,kEACA,gEACA,6DACA,4DACA,+DACA,kEACA,0DACA,oEACA,wEACA,8DACA,oEACA,uEACA,yEACA,oEACA,wEACA,qEACA,2DACA,qEACA,wEACA,+DACA,+DACA,qCACAhC,EAAAT,EAAAyC,GAEAC,GACA,oEACA,gFACA,kEACA,wFACA,oFACA,6EACA,mFACA,8EACA,mEACA,uEACA,mEACA,4FACA,qFACA,yEACA,qEACA,mEACA,kEACA,0BACA,8EACA,2EACA,yEACA,mDACA,oDACA,kDACA,qDACA,4EACA,sEACA,mGACA,sEACA,kEACA,4DACA,sEACA,oEACA,uEACA,kFACA,mEACA,+CACA,qEACA,4DACA,mFACA,gEACA,kEACA,wEACA,yDACA,kEACA,wDACA,oEACA,yEACA,oEACA,oDACA,uEACA,qEACA,gEACA,mEACA,yFACA,8DACA,uEACA,+EACA,yEACA,+DACA,8DACA,gDAC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","file":"es6-editor.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"http://localhost:8080/lib/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t__webpack_require__(1);\n\t\n\t// Vendor stuff\n\t\n\t__webpack_require__(5);\n\t\n\t// require('modernizr');\n\t\n\t__webpack_require__(8);\n\t\n\t//require('foundation/js/foundation/foundation.abide.js');\n\t// require('foundation/js/foundation/foundation.accordion');\n\t//require('foundation/js/foundation/foundation.alert.js');\n\t// require('foundation/js/foundation/foundation.clearing');\n\t// require('foundation/js/foundation/foundation.dropdown');\n\t// require('foundation/js/foundation/foundation.equalizer');\n\t\n\t__webpack_require__(9);\n\t\n\t//require('foundation/js/foundation/foundation.joyride.js');\n\t// require('foundation/js/foundation/foundation.magellan');\n\t// require('foundation/js/foundation/foundation.offcanvas');\n\t//require('foundation/js/foundation/foundation.orbit.js');\n\t\n\t__webpack_require__(10);\n\t\n\t//require('foundation/js/foundation/foundation.slider.js');\n\t\n\t__webpack_require__(11);\n\t\n\t//require('foundation/js/foundation/foundation.tooltip.js');\n\t// require('foundation/js/foundation/foundation.topbar');\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(15);\n\t\n\t// Our stuff\n\t\n\tvar _babelRepl = __webpack_require__(18);\n\t\n\tvar _babelRepl2 = _interopRequireDefault(_babelRepl);\n\t\n\t// A good case for the weakmap, since we need to keep track of\n\t// what component holds. Alternatives would be to somehow\n\t// keep track of these relationships some other way, maybe\n\t// with some data-id or an array you need to loop through.\n\tvar weakmap = new WeakMap();\n\t$('.js-example').each(function (index, el) {\n\t  var repl = new _babelRepl2['default']($(el));\n\t\n\t  // Assigning the jquery object won't work. You need to actually\n\t  // access the index.\n\t  weakmap.set($(this).find('.tabs')[0], repl);\n\t});\n\t\n\t// Mainly for creating the tabs.\n\t$(document).foundation();\n\t\n\t// Need to keep track of this, so we can refresh the editor since\n\t// it and tabs don't exactly agree with each other without some help.\n\t$('.tabs').on('toggled', function (event, tab) {\n\t  // Need to check if the key exists in the weakmap, since\n\t  // we have the other tabs on the right to account for\n\t  if (weakmap.has($(tab).parent()[0])) {\n\t    weakmap.get($(tab).parent()[0]).refresh();\n\t  }\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"$\"] = __webpack_require__(6);\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"jQuery\"] = __webpack_require__(7);\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * jQuery JavaScript Library v2.1.4\n\t * http://jquery.com/\n\t *\n\t * Includes Sizzle.js\n\t * http://sizzlejs.com/\n\t *\n\t * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2015-04-28T16:01Z\n\t */\n\t\n\t(function( global, factory ) {\n\t\n\t\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t\t// is present, execute the factory and get jQuery.\n\t\t\t// For environments that do not have a `window` with a `document`\n\t\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t\t// This accentuates the need for the creation of a real `window`.\n\t\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t\t// See ticket #14549 for more info.\n\t\t\tmodule.exports = global.document ?\n\t\t\t\tfactory( global, true ) :\n\t\t\t\tfunction( w ) {\n\t\t\t\t\tif ( !w.document ) {\n\t\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn factory( w );\n\t\t\t\t};\n\t\t} else {\n\t\t\tfactory( global );\n\t\t}\n\t\n\t// Pass this if window is not defined yet\n\t}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\t\n\t// Support: Firefox 18+\n\t// Can't be in strict mode, several libs including ASP.NET trace\n\t// the stack via arguments.caller.callee and Firefox dies if\n\t// you try to trace through \"use strict\" call chains. (#13335)\n\t//\n\t\n\tvar arr = [];\n\t\n\tvar slice = arr.slice;\n\t\n\tvar concat = arr.concat;\n\t\n\tvar push = arr.push;\n\t\n\tvar indexOf = arr.indexOf;\n\t\n\tvar class2type = {};\n\t\n\tvar toString = class2type.toString;\n\t\n\tvar hasOwn = class2type.hasOwnProperty;\n\t\n\tvar support = {};\n\t\n\t\n\t\n\tvar\n\t\t// Use the correct document accordingly with window argument (sandbox)\n\t\tdocument = window.document,\n\t\n\t\tversion = \"2.1.4\",\n\t\n\t\t// Define a local copy of jQuery\n\t\tjQuery = function( selector, context ) {\n\t\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\t\treturn new jQuery.fn.init( selector, context );\n\t\t},\n\t\n\t\t// Support: Android<4.1\n\t\t// Make sure we trim BOM and NBSP\n\t\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\t\n\t\t// Matches dashed string for camelizing\n\t\trmsPrefix = /^-ms-/,\n\t\trdashAlpha = /-([\\da-z])/gi,\n\t\n\t\t// Used by jQuery.camelCase as callback to replace()\n\t\tfcamelCase = function( all, letter ) {\n\t\t\treturn letter.toUpperCase();\n\t\t};\n\t\n\tjQuery.fn = jQuery.prototype = {\n\t\t// The current version of jQuery being used\n\t\tjquery: version,\n\t\n\t\tconstructor: jQuery,\n\t\n\t\t// Start with an empty selector\n\t\tselector: \"\",\n\t\n\t\t// The default length of a jQuery object is 0\n\t\tlength: 0,\n\t\n\t\ttoArray: function() {\n\t\t\treturn slice.call( this );\n\t\t},\n\t\n\t\t// Get the Nth element in the matched element set OR\n\t\t// Get the whole matched element set as a clean array\n\t\tget: function( num ) {\n\t\t\treturn num != null ?\n\t\n\t\t\t\t// Return just the one element from the set\n\t\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\t\n\t\t\t\t// Return all the elements in a clean array\n\t\t\t\tslice.call( this );\n\t\t},\n\t\n\t\t// Take an array of elements and push it onto the stack\n\t\t// (returning the new matched element set)\n\t\tpushStack: function( elems ) {\n\t\n\t\t\t// Build a new jQuery matched element set\n\t\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\t\n\t\t\t// Add the old object onto the stack (as a reference)\n\t\t\tret.prevObject = this;\n\t\t\tret.context = this.context;\n\t\n\t\t\t// Return the newly-formed element set\n\t\t\treturn ret;\n\t\t},\n\t\n\t\t// Execute a callback for every element in the matched set.\n\t\t// (You can seed the arguments with an array of args, but this is\n\t\t// only used internally.)\n\t\teach: function( callback, args ) {\n\t\t\treturn jQuery.each( this, callback, args );\n\t\t},\n\t\n\t\tmap: function( callback ) {\n\t\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\t\treturn callback.call( elem, i, elem );\n\t\t\t}));\n\t\t},\n\t\n\t\tslice: function() {\n\t\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t\t},\n\t\n\t\tfirst: function() {\n\t\t\treturn this.eq( 0 );\n\t\t},\n\t\n\t\tlast: function() {\n\t\t\treturn this.eq( -1 );\n\t\t},\n\t\n\t\teq: function( i ) {\n\t\t\tvar len = this.length,\n\t\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t\t},\n\t\n\t\tend: function() {\n\t\t\treturn this.prevObject || this.constructor(null);\n\t\t},\n\t\n\t\t// For internal use only.\n\t\t// Behaves like an Array's method, not like a jQuery method.\n\t\tpush: push,\n\t\tsort: arr.sort,\n\t\tsplice: arr.splice\n\t};\n\t\n\tjQuery.extend = jQuery.fn.extend = function() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[0] || {},\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif ( typeof target === \"boolean\" ) {\n\t\t\tdeep = target;\n\t\n\t\t\t// Skip the boolean and the target\n\t\t\ttarget = arguments[ i ] || {};\n\t\t\ti++;\n\t\t}\n\t\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\t// Extend jQuery itself if only one argument is passed\n\t\tif ( i === length ) {\n\t\t\ttarget = this;\n\t\t\ti--;\n\t\t}\n\t\n\t\tfor ( ; i < length; i++ ) {\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor ( name in options ) {\n\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\tcopy = options[ name ];\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\t\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\t\n\tjQuery.extend({\n\t\t// Unique for each copy of jQuery on the page\n\t\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\t\n\t\t// Assume jQuery is ready without the ready module\n\t\tisReady: true,\n\t\n\t\terror: function( msg ) {\n\t\t\tthrow new Error( msg );\n\t\t},\n\t\n\t\tnoop: function() {},\n\t\n\t\tisFunction: function( obj ) {\n\t\t\treturn jQuery.type(obj) === \"function\";\n\t\t},\n\t\n\t\tisArray: Array.isArray,\n\t\n\t\tisWindow: function( obj ) {\n\t\t\treturn obj != null && obj === obj.window;\n\t\t},\n\t\n\t\tisNumeric: function( obj ) {\n\t\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\t\treturn !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n\t\t},\n\t\n\t\tisPlainObject: function( obj ) {\n\t\t\t// Not plain objects:\n\t\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t\t// - DOM nodes\n\t\t\t// - window\n\t\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tif ( obj.constructor &&\n\t\t\t\t\t!hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\t// If the function hasn't returned already, we're confident that\n\t\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\t\treturn true;\n\t\t},\n\t\n\t\tisEmptyObject: function( obj ) {\n\t\t\tvar name;\n\t\t\tfor ( name in obj ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\n\t\ttype: function( obj ) {\n\t\t\tif ( obj == null ) {\n\t\t\t\treturn obj + \"\";\n\t\t\t}\n\t\t\t// Support: Android<4.0, iOS<6 (functionish RegExp)\n\t\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\t\ttypeof obj;\n\t\t},\n\t\n\t\t// Evaluates a script in a global context\n\t\tglobalEval: function( code ) {\n\t\t\tvar script,\n\t\t\t\tindirect = eval;\n\t\n\t\t\tcode = jQuery.trim( code );\n\t\n\t\t\tif ( code ) {\n\t\t\t\t// If the code includes a valid, prologue position\n\t\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t\t// script tag into the document.\n\t\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\t\tscript.text = code;\n\t\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t\t} else {\n\t\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t\t// and removal by using an indirect global eval\n\t\t\t\t\tindirect( code );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t// Convert dashed to camelCase; used by the css and data modules\n\t\t// Support: IE9-11+\n\t\t// Microsoft forgot to hump their vendor prefix (#9572)\n\t\tcamelCase: function( string ) {\n\t\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t\t},\n\t\n\t\tnodeName: function( elem, name ) {\n\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t\t},\n\t\n\t\t// args is for internal usage only\n\t\teach: function( obj, callback, args ) {\n\t\t\tvar value,\n\t\t\t\ti = 0,\n\t\t\t\tlength = obj.length,\n\t\t\t\tisArray = isArraylike( obj );\n\t\n\t\t\tif ( args ) {\n\t\t\t\tif ( isArray ) {\n\t\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\t\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\t\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// A special, fast, case for the most common use of each\n\t\t\t} else {\n\t\t\t\tif ( isArray ) {\n\t\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\t\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\t\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn obj;\n\t\t},\n\t\n\t\t// Support: Android<4.1\n\t\ttrim: function( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t\t},\n\t\n\t\t// results is for internal usage only\n\t\tmakeArray: function( arr, results ) {\n\t\t\tvar ret = results || [];\n\t\n\t\t\tif ( arr != null ) {\n\t\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t\t[ arr ] : arr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tpush.call( ret, arr );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn ret;\n\t\t},\n\t\n\t\tinArray: function( elem, arr, i ) {\n\t\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t\t},\n\t\n\t\tmerge: function( first, second ) {\n\t\t\tvar len = +second.length,\n\t\t\t\tj = 0,\n\t\t\t\ti = first.length;\n\t\n\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\t\n\t\t\tfirst.length = i;\n\t\n\t\t\treturn first;\n\t\t},\n\t\n\t\tgrep: function( elems, callback, invert ) {\n\t\t\tvar callbackInverse,\n\t\t\t\tmatches = [],\n\t\t\t\ti = 0,\n\t\t\t\tlength = elems.length,\n\t\t\t\tcallbackExpect = !invert;\n\t\n\t\t\t// Go through the array, only saving the items\n\t\t\t// that pass the validator function\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn matches;\n\t\t},\n\t\n\t\t// arg is for internal usage only\n\t\tmap: function( elems, callback, arg ) {\n\t\t\tvar value,\n\t\t\t\ti = 0,\n\t\t\t\tlength = elems.length,\n\t\t\t\tisArray = isArraylike( elems ),\n\t\t\t\tret = [];\n\t\n\t\t\t// Go through the array, translating each of the items to their new values\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\t\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Go through every key on the object,\n\t\t\t} else {\n\t\t\t\tfor ( i in elems ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\t\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Flatten any nested arrays\n\t\t\treturn concat.apply( [], ret );\n\t\t},\n\t\n\t\t// A global GUID counter for objects\n\t\tguid: 1,\n\t\n\t\t// Bind a function to a context, optionally partially applying any\n\t\t// arguments.\n\t\tproxy: function( fn, context ) {\n\t\t\tvar tmp, args, proxy;\n\t\n\t\t\tif ( typeof context === \"string\" ) {\n\t\t\t\ttmp = fn[ context ];\n\t\t\t\tcontext = fn;\n\t\t\t\tfn = tmp;\n\t\t\t}\n\t\n\t\t\t// Quick check to determine if target is callable, in the spec\n\t\t\t// this throws a TypeError, but we will just return undefined.\n\t\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\n\t\t\t// Simulated bind\n\t\t\targs = slice.call( arguments, 2 );\n\t\t\tproxy = function() {\n\t\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t\t};\n\t\n\t\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\t\n\t\t\treturn proxy;\n\t\t},\n\t\n\t\tnow: Date.now,\n\t\n\t\t// jQuery.support is not used in Core but other projects attach their\n\t\t// properties to it so it needs to exist.\n\t\tsupport: support\n\t});\n\t\n\t// Populate the class2type map\n\tjQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\t});\n\t\n\tfunction isArraylike( obj ) {\n\t\n\t\t// Support: iOS 8.2 (not reproducible in simulator)\n\t\t// `in` check used to prevent JIT error (gh-2145)\n\t\t// hasOwn isn't used here due to false negatives\n\t\t// regarding Nodelist length in IE\n\t\tvar length = \"length\" in obj && obj.length,\n\t\t\ttype = jQuery.type( obj );\n\t\n\t\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tif ( obj.nodeType === 1 && length ) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\treturn type === \"array\" || length === 0 ||\n\t\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n\t}\n\tvar Sizzle =\n\t/*!\n\t * Sizzle CSS Selector Engine v2.2.0-pre\n\t * http://sizzlejs.com/\n\t *\n\t * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2014-12-16\n\t */\n\t(function( window ) {\n\t\n\tvar i,\n\t\tsupport,\n\t\tExpr,\n\t\tgetText,\n\t\tisXML,\n\t\ttokenize,\n\t\tcompile,\n\t\tselect,\n\t\toutermostContext,\n\t\tsortInput,\n\t\thasDuplicate,\n\t\n\t\t// Local document vars\n\t\tsetDocument,\n\t\tdocument,\n\t\tdocElem,\n\t\tdocumentIsHTML,\n\t\trbuggyQSA,\n\t\trbuggyMatches,\n\t\tmatches,\n\t\tcontains,\n\t\n\t\t// Instance-specific data\n\t\texpando = \"sizzle\" + 1 * new Date(),\n\t\tpreferredDoc = window.document,\n\t\tdirruns = 0,\n\t\tdone = 0,\n\t\tclassCache = createCache(),\n\t\ttokenCache = createCache(),\n\t\tcompilerCache = createCache(),\n\t\tsortOrder = function( a, b ) {\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\t\n\t\t// General-purpose constants\n\t\tMAX_NEGATIVE = 1 << 31,\n\t\n\t\t// Instance methods\n\t\thasOwn = ({}).hasOwnProperty,\n\t\tarr = [],\n\t\tpop = arr.pop,\n\t\tpush_native = arr.push,\n\t\tpush = arr.push,\n\t\tslice = arr.slice,\n\t\t// Use a stripped-down indexOf as it's faster than native\n\t\t// http://jsperf.com/thor-indexof-vs-for/5\n\t\tindexOf = function( list, elem ) {\n\t\t\tvar i = 0,\n\t\t\t\tlen = list.length;\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tif ( list[i] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\n\t\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\t\n\t\t// Regular expressions\n\t\n\t\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\t\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t\t// http://www.w3.org/TR/css3-syntax/#characters\n\t\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\t\n\t\t// Loosely modeled on CSS identifier characters\n\t\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\t\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\t\n\t\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\t\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n\t\t\t// Operator (capture 2)\n\t\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\t\"*\\\\]\",\n\t\n\t\tpseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n\t\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t\t// 2. simple (capture 6)\n\t\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t\t// 3. anything else (capture 2)\n\t\t\t\".*\" +\n\t\t\t\")\\\\)|)\",\n\t\n\t\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\t\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\t\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\t\n\t\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\t\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\t\n\t\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\t\n\t\trpseudo = new RegExp( pseudos ),\n\t\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\t\n\t\tmatchExpr = {\n\t\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t\t// For use in libraries implementing .is()\n\t\t\t// We use this for POS matching in `select`\n\t\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t\t},\n\t\n\t\trinputs = /^(?:input|select|textarea|button)$/i,\n\t\trheader = /^h\\d$/i,\n\t\n\t\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\t\n\t\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\t\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t\n\t\trsibling = /[+~]/,\n\t\trescape = /'|\\\\/g,\n\t\n\t\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\t\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\t\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t\t// NaN means non-codepoint\n\t\t\t// Support: Firefox<24\n\t\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\t\treturn high !== high || escapedWhitespace ?\n\t\t\t\tescaped :\n\t\t\t\thigh < 0 ?\n\t\t\t\t\t// BMP codepoint\n\t\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t\t},\n\t\n\t\t// Used for iframes\n\t\t// See setDocument()\n\t\t// Removing the function wrapper causes a \"Permission Denied\"\n\t\t// error in IE\n\t\tunloadHandler = function() {\n\t\t\tsetDocument();\n\t\t};\n\t\n\t// Optimize for push.apply( _, NodeList )\n\ttry {\n\t\tpush.apply(\n\t\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\t\tpreferredDoc.childNodes\n\t\t);\n\t\t// Support: Android<4.0\n\t\t// Detect silently failing push.apply\n\t\tarr[ preferredDoc.childNodes.length ].nodeType;\n\t} catch ( e ) {\n\t\tpush = { apply: arr.length ?\n\t\n\t\t\t// Leverage slice if possible\n\t\t\tfunction( target, els ) {\n\t\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t\t} :\n\t\n\t\t\t// Support: IE<9\n\t\t\t// Otherwise append directly\n\t\t\tfunction( target, els ) {\n\t\t\t\tvar j = target.length,\n\t\t\t\t\ti = 0;\n\t\t\t\t// Can't trust NodeList.length\n\t\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\t\ttarget.length = j - 1;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction Sizzle( selector, context, results, seed ) {\n\t\tvar match, elem, m, nodeType,\n\t\t\t// QSA vars\n\t\t\ti, groups, old, nid, newContext, newSelector;\n\t\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\n\t\tcontext = context || document;\n\t\tresults = results || [];\n\t\tnodeType = context.nodeType;\n\t\n\t\tif ( typeof selector !== \"string\" || !selector ||\n\t\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\t\n\t\t\treturn results;\n\t\t}\n\t\n\t\tif ( !seed && documentIsHTML ) {\n\t\n\t\t\t// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\t\tif ( (m = match[1]) ) {\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Context is not a document\n\t\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\t\n\t\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// QSA path\n\t\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\t\tnid = old = expando;\n\t\t\t\tnewContext = context;\n\t\t\t\tnewSelector = nodeType !== 1 && selector;\n\t\n\t\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t\t// IE 8 doesn't work on object elements\n\t\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\t\tgroups = tokenize( selector );\n\t\n\t\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t\t}\n\t\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\t\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t\t}\n\t\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch(qsaError) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// All others\n\t\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n\t}\n\t\n\t/**\n\t * Create key-value caches of limited size\n\t * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n\t *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n\t *\tdeleting the oldest entry\n\t */\n\tfunction createCache() {\n\t\tvar keys = [];\n\t\n\t\tfunction cache( key, value ) {\n\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t\t// Only keep the most recent entries\n\t\t\t\tdelete cache[ keys.shift() ];\n\t\t\t}\n\t\t\treturn (cache[ key + \" \" ] = value);\n\t\t}\n\t\treturn cache;\n\t}\n\t\n\t/**\n\t * Mark a function for special use by Sizzle\n\t * @param {Function} fn The function to mark\n\t */\n\tfunction markFunction( fn ) {\n\t\tfn[ expando ] = true;\n\t\treturn fn;\n\t}\n\t\n\t/**\n\t * Support testing using an element\n\t * @param {Function} fn Passed the created div and expects a boolean result\n\t */\n\tfunction assert( fn ) {\n\t\tvar div = document.createElement(\"div\");\n\t\n\t\ttry {\n\t\t\treturn !!fn( div );\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t// Remove from its parent by default\n\t\t\tif ( div.parentNode ) {\n\t\t\t\tdiv.parentNode.removeChild( div );\n\t\t\t}\n\t\t\t// release memory in IE\n\t\t\tdiv = null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds the same handler for all of the specified attrs\n\t * @param {String} attrs Pipe-separated list of attributes\n\t * @param {Function} handler The method that will be applied\n\t */\n\tfunction addHandle( attrs, handler ) {\n\t\tvar arr = attrs.split(\"|\"),\n\t\t\ti = attrs.length;\n\t\n\t\twhile ( i-- ) {\n\t\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks document order of two siblings\n\t * @param {Element} a\n\t * @param {Element} b\n\t * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n\t */\n\tfunction siblingCheck( a, b ) {\n\t\tvar cur = b && a,\n\t\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\t\n\t\t// Use IE sourceIndex if available on both nodes\n\t\tif ( diff ) {\n\t\t\treturn diff;\n\t\t}\n\t\n\t\t// Check if b follows a\n\t\tif ( cur ) {\n\t\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\t\tif ( cur === b ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn a ? 1 : -1;\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for input types\n\t * @param {String} type\n\t */\n\tfunction createInputPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === type;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for buttons\n\t * @param {String} type\n\t */\n\tfunction createButtonPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for positionals\n\t * @param {Function} fn\n\t */\n\tfunction createPositionalPseudo( fn ) {\n\t\treturn markFunction(function( argument ) {\n\t\t\targument = +argument;\n\t\t\treturn markFunction(function( seed, matches ) {\n\t\t\t\tvar j,\n\t\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\t\ti = matchIndexes.length;\n\t\n\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\t\n\t/**\n\t * Checks a node for validity as a Sizzle context\n\t * @param {Element|Object=} context\n\t * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n\t */\n\tfunction testContext( context ) {\n\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t}\n\t\n\t// Expose support vars for convenience\n\tsupport = Sizzle.support = {};\n\t\n\t/**\n\t * Detects XML nodes\n\t * @param {Element|Object} elem An element or a document\n\t * @returns {Boolean} True iff elem is a non-HTML XML node\n\t */\n\tisXML = Sizzle.isXML = function( elem ) {\n\t\t// documentElement is verified for cases where it doesn't yet exist\n\t\t// (such as loading iframes in IE - #4833)\n\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\t};\n\t\n\t/**\n\t * Sets document-related variables once based on the current document\n\t * @param {Element|Object} [doc] An element or document object to use to set the document\n\t * @returns {Object} Returns the current document\n\t */\n\tsetDocument = Sizzle.setDocument = function( node ) {\n\t\tvar hasCompare, parent,\n\t\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\t\n\t\t// If no document and documentElement is available, return\n\t\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\t\treturn document;\n\t\t}\n\t\n\t\t// Set our document\n\t\tdocument = doc;\n\t\tdocElem = doc.documentElement;\n\t\tparent = doc.defaultView;\n\t\n\t\t// Support: IE>8\n\t\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t\t// IE6-8 do not support the defaultView property so parent will be undefined\n\t\tif ( parent && parent !== parent.top ) {\n\t\t\t// IE11 does not have attachEvent, so all must suffer\n\t\t\tif ( parent.addEventListener ) {\n\t\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\t\t\t} else if ( parent.attachEvent ) {\n\t\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t\t}\n\t\t}\n\t\n\t\t/* Support tests\n\t\t---------------------------------------------------------------------- */\n\t\tdocumentIsHTML = !isXML( doc );\n\t\n\t\t/* Attributes\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Support: IE<8\n\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t// (excepting IE8 booleans)\n\t\tsupport.attributes = assert(function( div ) {\n\t\t\tdiv.className = \"i\";\n\t\t\treturn !div.getAttribute(\"className\");\n\t\t});\n\t\n\t\t/* getElement(s)By*\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\tsupport.getElementsByTagName = assert(function( div ) {\n\t\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\t\treturn !div.getElementsByTagName(\"*\").length;\n\t\t});\n\t\n\t\t// Support: IE<9\n\t\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\t\n\t\t// Support: IE<10\n\t\t// Check if getElementById returns elements by name\n\t\t// The broken getElementById methods don't pick up programatically-set names,\n\t\t// so use a roundabout getElementsByName test\n\t\tsupport.getById = assert(function( div ) {\n\t\t\tdocElem.appendChild( div ).id = expando;\n\t\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t\t});\n\t\n\t\t// ID find and filter\n\t\tif ( support.getById ) {\n\t\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n\t\t\t\t}\n\t\t\t};\n\t\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t} else {\n\t\t\t// Support: IE6/7\n\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\tdelete Expr.find[\"ID\"];\n\t\n\t\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\t\n\t\t// Tag\n\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\t\tfunction( tag, context ) {\n\t\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\t\treturn context.getElementsByTagName( tag );\n\t\n\t\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t\t} else if ( support.qsa ) {\n\t\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t\t}\n\t\t\t} :\n\t\n\t\t\tfunction( tag, context ) {\n\t\t\t\tvar elem,\n\t\t\t\t\ttmp = [],\n\t\t\t\t\ti = 0,\n\t\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\t\tresults = context.getElementsByTagName( tag );\n\t\n\t\t\t\t// Filter out possible comments\n\t\t\t\tif ( tag === \"*\" ) {\n\t\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\t\n\t\t// Class\n\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\t\tif ( documentIsHTML ) {\n\t\t\t\treturn context.getElementsByClassName( className );\n\t\t\t}\n\t\t};\n\t\n\t\t/* QSA/matchesSelector\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// QSA and matchesSelector support\n\t\n\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\trbuggyMatches = [];\n\t\n\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t// See http://bugs.jquery.com/ticket/13378\n\t\trbuggyQSA = [];\n\t\n\t\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t\t// Build QSA regex\n\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\tassert(function( div ) {\n\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t// since its presence should be enough\n\t\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\t\"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" +\n\t\t\t\t\t\"<option selected=''></option></select>\";\n\t\n\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: IE8\n\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\t\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t}\n\t\n\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t}\n\t\n\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tassert(function( div ) {\n\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\tvar input = doc.createElement(\"input\");\n\t\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\t\n\t\t\t\t// Support: IE8\n\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t\t}\n\t\n\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t});\n\t\t}\n\t\n\t\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\t\tdocElem.webkitMatchesSelector ||\n\t\t\tdocElem.mozMatchesSelector ||\n\t\t\tdocElem.oMatchesSelector ||\n\t\t\tdocElem.msMatchesSelector) )) ) {\n\t\n\t\t\tassert(function( div ) {\n\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\t\n\t\t\t\t// This should fail with an exception\n\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t\t});\n\t\t}\n\t\n\t\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\t\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\t\n\t\t/* Contains\n\t\t---------------------------------------------------------------------- */\n\t\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\t\n\t\t// Element contains another\n\t\t// Purposefully does not implement inclusive descendent\n\t\t// As in, an element does not contain itself\n\t\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\t\tfunction( a, b ) {\n\t\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\t\tbup = b && b.parentNode;\n\t\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\t\tadown.contains ?\n\t\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t\t));\n\t\t\t} :\n\t\t\tfunction( a, b ) {\n\t\t\t\tif ( b ) {\n\t\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t\n\t\t/* Sorting\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Document order sorting\n\t\tsortOrder = hasCompare ?\n\t\tfunction( a, b ) {\n\t\n\t\t\t// Flag for duplicate removal\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\tif ( compare ) {\n\t\t\t\treturn compare;\n\t\t\t}\n\t\n\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\t\ta.compareDocumentPosition( b ) :\n\t\n\t\t\t\t// Otherwise we know they are disconnected\n\t\t\t\t1;\n\t\n\t\t\t// Disconnected nodes\n\t\t\tif ( compare & 1 ||\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\t\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\t\t}\n\t\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\t// Exit early if the nodes are identical\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\taup = a.parentNode,\n\t\t\t\tbup = b.parentNode,\n\t\t\t\tap = [ a ],\n\t\t\t\tbp = [ b ];\n\t\n\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\tif ( !aup || !bup ) {\n\t\t\t\treturn a === doc ? -1 :\n\t\t\t\t\tb === doc ? 1 :\n\t\t\t\t\taup ? -1 :\n\t\t\t\t\tbup ? 1 :\n\t\t\t\t\tsortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\n\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t} else if ( aup === bup ) {\n\t\t\t\treturn siblingCheck( a, b );\n\t\t\t}\n\t\n\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\tcur = a;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tap.unshift( cur );\n\t\t\t}\n\t\t\tcur = b;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tbp.unshift( cur );\n\t\t\t}\n\t\n\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\twhile ( ap[i] === bp[i] ) {\n\t\t\t\ti++;\n\t\t\t}\n\t\n\t\t\treturn i ?\n\t\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\t\n\t\t\t\t// Otherwise nodes in our document sort first\n\t\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t\t0;\n\t\t};\n\t\n\t\treturn doc;\n\t};\n\t\n\tSizzle.matches = function( expr, elements ) {\n\t\treturn Sizzle( expr, null, null, elements );\n\t};\n\t\n\tSizzle.matchesSelector = function( elem, expr ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\t\n\t\t// Make sure that attribute selectors are quoted\n\t\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\t\n\t\tif ( support.matchesSelector && documentIsHTML &&\n\t\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\t\n\t\t\ttry {\n\t\t\t\tvar ret = matches.call( elem, expr );\n\t\n\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t\n\t\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n\t};\n\t\n\tSizzle.contains = function( context, elem ) {\n\t\t// Set document vars if needed\n\t\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\treturn contains( context, elem );\n\t};\n\t\n\tSizzle.attr = function( elem, name ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\t\n\t\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\t\tundefined;\n\t\n\t\treturn val !== undefined ?\n\t\t\tval :\n\t\t\tsupport.attributes || !documentIsHTML ?\n\t\t\t\telem.getAttribute( name ) :\n\t\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t};\n\t\n\tSizzle.error = function( msg ) {\n\t\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n\t};\n\t\n\t/**\n\t * Document sorting and removing duplicates\n\t * @param {ArrayLike} results\n\t */\n\tSizzle.uniqueSort = function( results ) {\n\t\tvar elem,\n\t\t\tduplicates = [],\n\t\t\tj = 0,\n\t\t\ti = 0;\n\t\n\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\thasDuplicate = !support.detectDuplicates;\n\t\tsortInput = !support.sortStable && results.slice( 0 );\n\t\tresults.sort( sortOrder );\n\t\n\t\tif ( hasDuplicate ) {\n\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\t\tj = duplicates.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ( j-- ) {\n\t\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t\t}\n\t\t}\n\t\n\t\t// Clear input after sorting to release objects\n\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\tsortInput = null;\n\t\n\t\treturn results;\n\t};\n\t\n\t/**\n\t * Utility function for retrieving the text value of an array of DOM nodes\n\t * @param {Array|Element} elem\n\t */\n\tgetText = Sizzle.getText = function( elem ) {\n\t\tvar node,\n\t\t\tret = \"\",\n\t\t\ti = 0,\n\t\t\tnodeType = elem.nodeType;\n\t\n\t\tif ( !nodeType ) {\n\t\t\t// If no nodeType, this is expected to be an array\n\t\t\twhile ( (node = elem[i++]) ) {\n\t\t\t\t// Do not traverse comment nodes\n\t\t\t\tret += getText( node );\n\t\t\t}\n\t\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t\t// Use textContent for elements\n\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\t\treturn elem.textContent;\n\t\t\t} else {\n\t\t\t\t// Traverse its children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tret += getText( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\t\treturn elem.nodeValue;\n\t\t}\n\t\t// Do not include comment or processing instruction nodes\n\t\n\t\treturn ret;\n\t};\n\t\n\tExpr = Sizzle.selectors = {\n\t\n\t\t// Can be adjusted by the user\n\t\tcacheLength: 50,\n\t\n\t\tcreatePseudo: markFunction,\n\t\n\t\tmatch: matchExpr,\n\t\n\t\tattrHandle: {},\n\t\n\t\tfind: {},\n\t\n\t\trelative: {\n\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t},\n\t\n\t\tpreFilter: {\n\t\t\t\"ATTR\": function( match ) {\n\t\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\t\n\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\t\n\t\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t}\n\t\n\t\t\t\treturn match.slice( 0, 4 );\n\t\t\t},\n\t\n\t\t\t\"CHILD\": function( match ) {\n\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t\t1 type (only|nth|...)\n\t\t\t\t\t2 what (child|of-type)\n\t\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t\t5 sign of xn-component\n\t\t\t\t\t6 x of xn-component\n\t\t\t\t\t7 sign of y-component\n\t\t\t\t\t8 y of y-component\n\t\t\t\t*/\n\t\t\t\tmatch[1] = match[1].toLowerCase();\n\t\n\t\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\t\n\t\t\t\t// other types prohibit arguments\n\t\t\t\t} else if ( match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\t\n\t\t\t\treturn match;\n\t\t\t},\n\t\n\t\t\t\"PSEUDO\": function( match ) {\n\t\t\t\tvar excess,\n\t\t\t\t\tunquoted = !match[6] && match[2];\n\t\n\t\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\tif ( match[3] ) {\n\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\t\n\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\t\n\t\t\t\t\t// excess is a negative index\n\t\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t\t}\n\t\n\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\treturn match.slice( 0, 3 );\n\t\t\t}\n\t\t},\n\t\n\t\tfilter: {\n\t\n\t\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\t\tfunction() { return true; } :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"CLASS\": function( className ) {\n\t\t\t\tvar pattern = classCache[ className + \" \" ];\n\t\n\t\t\t\treturn pattern ||\n\t\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t\t});\n\t\t\t},\n\t\n\t\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar result = Sizzle.attr( elem, name );\n\t\n\t\t\t\t\tif ( result == null ) {\n\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t}\n\t\t\t\t\tif ( !operator ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tresult += \"\";\n\t\n\t\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\t\tfalse;\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\t\tofType = what === \"of-type\";\n\t\n\t\t\t\treturn first === 1 && last === 0 ?\n\t\n\t\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t\t} :\n\t\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\t\tuseCache = !xml && !ofType;\n\t\n\t\t\t\t\t\tif ( parent ) {\n\t\n\t\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\t\n\t\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\t\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\n\t\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\t\n\t\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\t\tdiff = cache[1];\n\t\n\t\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\t\n\t\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\tvar args,\n\t\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\t\n\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t// just as Sizzle does\n\t\t\t\tif ( fn[ expando ] ) {\n\t\t\t\t\treturn fn( argument );\n\t\t\t\t}\n\t\n\t\t\t\t// But maintain support for old signatures\n\t\t\t\tif ( fn.length > 1 ) {\n\t\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\t\n\t\tpseudos: {\n\t\t\t// Potentially complex pseudos\n\t\t\t\"not\": markFunction(function( selector ) {\n\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t// spaces as combinators\n\t\t\t\tvar input = [],\n\t\t\t\t\tresults = [],\n\t\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\t\n\t\t\t\treturn matcher[ expando ] ?\n\t\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\t\tvar elem,\n\t\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\t\ti = seed.length;\n\t\n\t\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\t\tinput[0] = null;\n\t\t\t\t\t\treturn !results.pop();\n\t\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t\"has\": markFunction(function( selector ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t\"contains\": markFunction(function( text ) {\n\t\t\t\ttext = text.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t// is based solely on the element's language value\n\t\t\t// being equal to the identifier C,\n\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t\t// lang value must be a valid identifier\n\t\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t\t}\n\t\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar elemLang;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\t\n\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t// Miscellaneous\n\t\t\t\"target\": function( elem ) {\n\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t\t},\n\t\n\t\t\t\"root\": function( elem ) {\n\t\t\t\treturn elem === docElem;\n\t\t\t},\n\t\n\t\t\t\"focus\": function( elem ) {\n\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t},\n\t\n\t\t\t// Boolean properties\n\t\t\t\"enabled\": function( elem ) {\n\t\t\t\treturn elem.disabled === false;\n\t\t\t},\n\t\n\t\t\t\"disabled\": function( elem ) {\n\t\t\t\treturn elem.disabled === true;\n\t\t\t},\n\t\n\t\t\t\"checked\": function( elem ) {\n\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t\t},\n\t\n\t\t\t\"selected\": function( elem ) {\n\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t// options in Safari work properly\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t}\n\t\n\t\t\t\treturn elem.selected === true;\n\t\t\t},\n\t\n\t\t\t// Contents\n\t\t\t\"empty\": function( elem ) {\n\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\n\t\t\t\"parent\": function( elem ) {\n\t\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t\t},\n\t\n\t\t\t// Element/input types\n\t\t\t\"header\": function( elem ) {\n\t\t\t\treturn rheader.test( elem.nodeName );\n\t\t\t},\n\t\n\t\t\t\"input\": function( elem ) {\n\t\t\t\treturn rinputs.test( elem.nodeName );\n\t\t\t},\n\t\n\t\t\t\"button\": function( elem ) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t},\n\t\n\t\t\t\"text\": function( elem ) {\n\t\t\t\tvar attr;\n\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\t\telem.type === \"text\" &&\n\t\n\t\t\t\t\t// Support: IE<8\n\t\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t\t},\n\t\n\t\t\t// Position-in-collection\n\t\t\t\"first\": createPositionalPseudo(function() {\n\t\t\t\treturn [ 0 ];\n\t\t\t}),\n\t\n\t\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\treturn [ length - 1 ];\n\t\t\t}),\n\t\n\t\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t\t}),\n\t\n\t\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 1;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t})\n\t\t}\n\t};\n\t\n\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\t\n\t// Add button/input type pseudos\n\tfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\t\tExpr.pseudos[ i ] = createInputPseudo( i );\n\t}\n\tfor ( i in { submit: true, reset: true } ) {\n\t\tExpr.pseudos[ i ] = createButtonPseudo( i );\n\t}\n\t\n\t// Easy API for creating new setFilters\n\tfunction setFilters() {}\n\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\tExpr.setFilters = new setFilters();\n\t\n\ttokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\t\tvar matched, match, tokens, type,\n\t\t\tsoFar, groups, preFilters,\n\t\t\tcached = tokenCache[ selector + \" \" ];\n\t\n\t\tif ( cached ) {\n\t\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t\t}\n\t\n\t\tsoFar = selector;\n\t\tgroups = [];\n\t\tpreFilters = Expr.preFilter;\n\t\n\t\twhile ( soFar ) {\n\t\n\t\t\t// Comma and first run\n\t\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\t\tif ( match ) {\n\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t\t}\n\t\t\t\tgroups.push( (tokens = []) );\n\t\t\t}\n\t\n\t\t\tmatched = false;\n\t\n\t\t\t// Combinators\n\t\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\n\t\t\t// Filters\n\t\t\tfor ( type in Expr.filter ) {\n\t\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tmatches: match\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( !matched ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the length of the invalid excess\n\t\t// if we're just parsing\n\t\t// Otherwise, throw an error or return tokens\n\t\treturn parseOnly ?\n\t\t\tsoFar.length :\n\t\t\tsoFar ?\n\t\t\t\tSizzle.error( selector ) :\n\t\t\t\t// Cache the tokens\n\t\t\t\ttokenCache( selector, groups ).slice( 0 );\n\t};\n\t\n\tfunction toSelector( tokens ) {\n\t\tvar i = 0,\n\t\t\tlen = tokens.length,\n\t\t\tselector = \"\";\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tselector += tokens[i].value;\n\t\t}\n\t\treturn selector;\n\t}\n\t\n\tfunction addCombinator( matcher, combinator, base ) {\n\t\tvar dir = combinator.dir,\n\t\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\t\tdoneName = done++;\n\t\n\t\treturn combinator.first ?\n\t\t\t// Check against closest ancestor/preceding element\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} :\n\t\n\t\t\t// Check against all ancestor/preceding elements\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar oldCache, outerCache,\n\t\t\t\t\tnewCache = [ dirruns, doneName ];\n\t\n\t\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\t\tif ( xml ) {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\t\n\t\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\t\n\t\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t}\n\t\n\tfunction elementMatcher( matchers ) {\n\t\treturn matchers.length > 1 ?\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar i = matchers.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} :\n\t\t\tmatchers[0];\n\t}\n\t\n\tfunction multipleContexts( selector, contexts, results ) {\n\t\tvar i = 0,\n\t\t\tlen = contexts.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tSizzle( selector, contexts[i], results );\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tfunction condense( unmatched, map, filter, context, xml ) {\n\t\tvar elem,\n\t\t\tnewUnmatched = [],\n\t\t\ti = 0,\n\t\t\tlen = unmatched.length,\n\t\t\tmapped = map != null;\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\t\tif ( mapped ) {\n\t\t\t\t\t\tmap.push( i );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn newUnmatched;\n\t}\n\t\n\tfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\t\tif ( postFilter && !postFilter[ expando ] ) {\n\t\t\tpostFilter = setMatcher( postFilter );\n\t\t}\n\t\tif ( postFinder && !postFinder[ expando ] ) {\n\t\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t\t}\n\t\treturn markFunction(function( seed, results, context, xml ) {\n\t\t\tvar temp, i, elem,\n\t\t\t\tpreMap = [],\n\t\t\t\tpostMap = [],\n\t\t\t\tpreexisting = results.length,\n\t\n\t\t\t\t// Get initial elements from seed or context\n\t\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\t\n\t\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\t\telems,\n\t\n\t\t\t\tmatcherOut = matcher ?\n\t\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\t\n\t\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t\t[] :\n\t\n\t\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\t\tresults :\n\t\t\t\t\tmatcherIn;\n\t\n\t\t\t// Find primary matches\n\t\t\tif ( matcher ) {\n\t\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t\t}\n\t\n\t\t\t// Apply postFilter\n\t\t\tif ( postFilter ) {\n\t\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\t\tpostFilter( temp, [], context, xml );\n\t\n\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\ti = temp.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( seed ) {\n\t\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\t\n\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t} else {\n\t\t\t\tmatcherOut = condense(\n\t\t\t\t\tmatcherOut === results ?\n\t\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\t\tmatcherOut\n\t\t\t\t);\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t\t} else {\n\t\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\t\n\tfunction matcherFromTokens( tokens ) {\n\t\tvar checkContext, matcher, j,\n\t\t\tlen = tokens.length,\n\t\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t\ti = leadingRelative ? 1 : 0,\n\t\n\t\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\t\treturn elem === checkContext;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\t\tcheckContext = null;\n\t\t\t\treturn ret;\n\t\t\t} ];\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t\t} else {\n\t\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\t\n\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\tj = ++i;\n\t\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn setMatcher(\n\t\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tmatchers.push( matcher );\n\t\t\t}\n\t\t}\n\t\n\t\treturn elementMatcher( matchers );\n\t}\n\t\n\tfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t\tvar bySet = setMatchers.length > 0,\n\t\t\tbyElement = elementMatchers.length > 0,\n\t\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\t\tvar elem, j, matcher,\n\t\t\t\t\tmatchedCount = 0,\n\t\t\t\t\ti = \"0\",\n\t\t\t\t\tunmatched = seed && [],\n\t\t\t\t\tsetMatched = [],\n\t\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\t\tlen = elems.length;\n\t\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\toutermostContext = context !== document && context;\n\t\t\t\t}\n\t\n\t\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t\t// Support: IE<9, Safari\n\t\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\t\tif ( bySet ) {\n\t\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Apply set filters to unmatched elements\n\t\t\t\tmatchedCount += i;\n\t\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Add matches to results\n\t\t\t\t\tpush.apply( results, setMatched );\n\t\n\t\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\t\n\t\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Override manipulation of globals by nested matchers\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\toutermostContext = contextBackup;\n\t\t\t\t}\n\t\n\t\t\t\treturn unmatched;\n\t\t\t};\n\t\n\t\treturn bySet ?\n\t\t\tmarkFunction( superMatcher ) :\n\t\t\tsuperMatcher;\n\t}\n\t\n\tcompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\t\tvar i,\n\t\t\tsetMatchers = [],\n\t\t\telementMatchers = [],\n\t\t\tcached = compilerCache[ selector + \" \" ];\n\t\n\t\tif ( !cached ) {\n\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\tif ( !match ) {\n\t\t\t\tmatch = tokenize( selector );\n\t\t\t}\n\t\t\ti = match.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\t\tif ( cached[ expando ] ) {\n\t\t\t\t\tsetMatchers.push( cached );\n\t\t\t\t} else {\n\t\t\t\t\telementMatchers.push( cached );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Cache the compiled function\n\t\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t\n\t\t\t// Save selector and tokenization\n\t\t\tcached.selector = selector;\n\t\t}\n\t\treturn cached;\n\t};\n\t\n\t/**\n\t * A low-level selection function that works with Sizzle's compiled\n\t *  selector functions\n\t * @param {String|Function} selector A selector or a pre-compiled\n\t *  selector function built with Sizzle.compile\n\t * @param {Element} context\n\t * @param {Array} [results]\n\t * @param {Array} [seed] A set of elements to match against\n\t */\n\tselect = Sizzle.select = function( selector, context, results, seed ) {\n\t\tvar i, tokens, token, type, find,\n\t\t\tcompiled = typeof selector === \"function\" && selector,\n\t\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\t\n\t\tresults = results || [];\n\t\n\t\t// Try to minimize operations if there is no seed and only one group\n\t\tif ( match.length === 1 ) {\n\t\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\t\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\n\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t} else if ( compiled ) {\n\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t}\n\t\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\t\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\t\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t\t)) ) {\n\t\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Compile and execute a filtering function if one is not provided\n\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t( compiled || compile( selector, match ) )(\n\t\t\tseed,\n\t\t\tcontext,\n\t\t\t!documentIsHTML,\n\t\t\tresults,\n\t\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t\t);\n\t\treturn results;\n\t};\n\t\n\t// One-time assignments\n\t\n\t// Sort stability\n\tsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\t\n\t// Support: Chrome 14-35+\n\t// Always assume duplicates if they aren't passed to the comparison function\n\tsupport.detectDuplicates = !!hasDuplicate;\n\t\n\t// Initialize against the default document\n\tsetDocument();\n\t\n\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t// Detached nodes confoundingly follow *each other*\n\tsupport.sortDetached = assert(function( div1 ) {\n\t\t// Should return 1, but returns 4 (following)\n\t\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n\t});\n\t\n\t// Support: IE<8\n\t// Prevent attribute/property \"interpolation\"\n\t// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\tif ( !assert(function( div ) {\n\t\tdiv.innerHTML = \"<a href='#'></a>\";\n\t\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n\t}) ) {\n\t\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t\t}\n\t\t});\n\t}\n\t\n\t// Support: IE<9\n\t// Use defaultValue in place of getAttribute(\"value\")\n\tif ( !support.attributes || !assert(function( div ) {\n\t\tdiv.innerHTML = \"<input/>\";\n\t\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\t\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n\t}) ) {\n\t\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\t\treturn elem.defaultValue;\n\t\t\t}\n\t\t});\n\t}\n\t\n\t// Support: IE<9\n\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\tif ( !assert(function( div ) {\n\t\treturn div.getAttribute(\"disabled\") == null;\n\t}) ) {\n\t\taddHandle( booleans, function( elem, name, isXML ) {\n\t\t\tvar val;\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t});\n\t}\n\t\n\treturn Sizzle;\n\t\n\t})( window );\n\t\n\t\n\t\n\tjQuery.find = Sizzle;\n\tjQuery.expr = Sizzle.selectors;\n\tjQuery.expr[\":\"] = jQuery.expr.pseudos;\n\tjQuery.unique = Sizzle.uniqueSort;\n\tjQuery.text = Sizzle.getText;\n\tjQuery.isXMLDoc = Sizzle.isXML;\n\tjQuery.contains = Sizzle.contains;\n\t\n\t\n\t\n\tvar rneedsContext = jQuery.expr.match.needsContext;\n\t\n\tvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\t\n\t\n\t\n\tvar risSimple = /^.[^:#\\[\\.,]*$/;\n\t\n\t// Implement the identical functionality for filter and not\n\tfunction winnow( elements, qualifier, not ) {\n\t\tif ( jQuery.isFunction( qualifier ) ) {\n\t\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t\t/* jshint -W018 */\n\t\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t\t});\n\t\n\t\t}\n\t\n\t\tif ( qualifier.nodeType ) {\n\t\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\t\treturn ( elem === qualifier ) !== not;\n\t\t\t});\n\t\n\t\t}\n\t\n\t\tif ( typeof qualifier === \"string\" ) {\n\t\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t\t}\n\t\n\t\t\tqualifier = jQuery.filter( qualifier, elements );\n\t\t}\n\t\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t\t});\n\t}\n\t\n\tjQuery.filter = function( expr, elems, not ) {\n\t\tvar elem = elems[ 0 ];\n\t\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\t\n\t\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\t\treturn elem.nodeType === 1;\n\t\t\t}));\n\t};\n\t\n\tjQuery.fn.extend({\n\t\tfind: function( selector ) {\n\t\t\tvar i,\n\t\t\t\tlen = this.length,\n\t\t\t\tret = [],\n\t\t\t\tself = this;\n\t\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) );\n\t\t\t}\n\t\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t\t}\n\t\n\t\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\t\treturn ret;\n\t\t},\n\t\tfilter: function( selector ) {\n\t\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t\t},\n\t\tnot: function( selector ) {\n\t\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t\t},\n\t\tis: function( selector ) {\n\t\t\treturn !!winnow(\n\t\t\t\tthis,\n\t\n\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\t\tjQuery( selector ) :\n\t\t\t\t\tselector || [],\n\t\t\t\tfalse\n\t\t\t).length;\n\t\t}\n\t});\n\t\n\t\n\t// Initialize a jQuery object\n\t\n\t\n\t// A central reference to the root jQuery(document)\n\tvar rootjQuery,\n\t\n\t\t// A simple way to check for HTML strings\n\t\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t\t// Strict HTML recognition (#11290: must start with <)\n\t\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\t\n\t\tinit = jQuery.fn.init = function( selector, context ) {\n\t\t\tvar match, elem;\n\t\n\t\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\t\tif ( !selector ) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\t// Handle HTML strings\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\tif ( selector[0] === \"<\" && selector[ selector.length - 1 ] === \">\" && selector.length >= 3 ) {\n\t\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\t\tmatch = [ null, selector, null ];\n\t\n\t\t\t\t} else {\n\t\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t\t}\n\t\n\t\t\t\t// Match html or make sure no context is specified for #id\n\t\t\t\tif ( match && (match[1] || !context) ) {\n\t\n\t\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\t\tif ( match[1] ) {\n\t\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\t\n\t\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t) );\n\t\n\t\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\t\n\t\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem = document.getElementById( match[2] );\n\t\n\t\t\t\t\t\t// Support: Blackberry 4.6\n\t\t\t\t\t\t// gEBID returns nodes no longer in the document (#6963)\n\t\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.context = document;\n\t\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\n\t\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\t\n\t\t\t\t// HANDLE: $(expr, context)\n\t\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t\t} else {\n\t\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t\t}\n\t\n\t\t\t// HANDLE: $(DOMElement)\n\t\t\t} else if ( selector.nodeType ) {\n\t\t\t\tthis.context = this[0] = selector;\n\t\t\t\tthis.length = 1;\n\t\t\t\treturn this;\n\t\n\t\t\t// HANDLE: $(function)\n\t\t\t// Shortcut for document ready\n\t\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\t\tselector( jQuery );\n\t\t\t}\n\t\n\t\t\tif ( selector.selector !== undefined ) {\n\t\t\t\tthis.selector = selector.selector;\n\t\t\t\tthis.context = selector.context;\n\t\t\t}\n\t\n\t\t\treturn jQuery.makeArray( selector, this );\n\t\t};\n\t\n\t// Give the init function the jQuery prototype for later instantiation\n\tinit.prototype = jQuery.fn;\n\t\n\t// Initialize central reference\n\trootjQuery = jQuery( document );\n\t\n\t\n\tvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t\t// Methods guaranteed to produce a unique set when starting from a unique set\n\t\tguaranteedUnique = {\n\t\t\tchildren: true,\n\t\t\tcontents: true,\n\t\t\tnext: true,\n\t\t\tprev: true\n\t\t};\n\t\n\tjQuery.extend({\n\t\tdir: function( elem, dir, until ) {\n\t\t\tvar matched = [],\n\t\t\t\ttruncate = until !== undefined;\n\t\n\t\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmatched.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matched;\n\t\t},\n\t\n\t\tsibling: function( n, elem ) {\n\t\t\tvar matched = [];\n\t\n\t\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\t\tmatched.push( n );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn matched;\n\t\t}\n\t});\n\t\n\tjQuery.fn.extend({\n\t\thas: function( target ) {\n\t\t\tvar targets = jQuery( target, this ),\n\t\t\t\tl = targets.length;\n\t\n\t\t\treturn this.filter(function() {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\n\t\tclosest: function( selectors, context ) {\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length,\n\t\t\t\tmatched = [],\n\t\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t\t0;\n\t\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\t\tpos.index(cur) > -1 :\n\t\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\t\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t\t},\n\t\n\t\t// Determine the position of an element within the set\n\t\tindex: function( elem ) {\n\t\n\t\t\t// No argument, return index in parent\n\t\t\tif ( !elem ) {\n\t\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t\t}\n\t\n\t\t\t// Index in selector\n\t\t\tif ( typeof elem === \"string\" ) {\n\t\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t\t}\n\t\n\t\t\t// Locate the position of the desired element\n\t\t\treturn indexOf.call( this,\n\t\n\t\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t\t);\n\t\t},\n\t\n\t\tadd: function( selector, context ) {\n\t\t\treturn this.pushStack(\n\t\t\t\tjQuery.unique(\n\t\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\n\t\taddBack: function( selector ) {\n\t\t\treturn this.add( selector == null ?\n\t\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t\t);\n\t\t}\n\t});\n\t\n\tfunction sibling( cur, dir ) {\n\t\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\t\treturn cur;\n\t}\n\t\n\tjQuery.each({\n\t\tparent: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t\t},\n\t\tparents: function( elem ) {\n\t\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t\t},\n\t\tparentsUntil: function( elem, i, until ) {\n\t\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t\t},\n\t\tnext: function( elem ) {\n\t\t\treturn sibling( elem, \"nextSibling\" );\n\t\t},\n\t\tprev: function( elem ) {\n\t\t\treturn sibling( elem, \"previousSibling\" );\n\t\t},\n\t\tnextAll: function( elem ) {\n\t\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t\t},\n\t\tprevAll: function( elem ) {\n\t\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t\t},\n\t\tnextUntil: function( elem, i, until ) {\n\t\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t\t},\n\t\tprevUntil: function( elem, i, until ) {\n\t\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t\t},\n\t\tsiblings: function( elem ) {\n\t\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t\t},\n\t\tchildren: function( elem ) {\n\t\t\treturn jQuery.sibling( elem.firstChild );\n\t\t},\n\t\tcontents: function( elem ) {\n\t\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t\t}\n\t}, function( name, fn ) {\n\t\tjQuery.fn[ name ] = function( until, selector ) {\n\t\t\tvar matched = jQuery.map( this, fn, until );\n\t\n\t\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\t\tselector = until;\n\t\t\t}\n\t\n\t\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t\t}\n\t\n\t\t\tif ( this.length > 1 ) {\n\t\t\t\t// Remove duplicates\n\t\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\t\tjQuery.unique( matched );\n\t\t\t\t}\n\t\n\t\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\t\tmatched.reverse();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( matched );\n\t\t};\n\t});\n\tvar rnotwhite = (/\\S+/g);\n\t\n\t\n\t\n\t// String to Object options format cache\n\tvar optionsCache = {};\n\t\n\t// Convert String-formatted options into Object-formatted ones and store in cache\n\tfunction createOptions( options ) {\n\t\tvar object = optionsCache[ options ] = {};\n\t\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\t\tobject[ flag ] = true;\n\t\t});\n\t\treturn object;\n\t}\n\t\n\t/*\n\t * Create a callback list using the following parameters:\n\t *\n\t *\toptions: an optional list of space-separated options that will change how\n\t *\t\t\tthe callback list behaves or a more traditional option object\n\t *\n\t * By default a callback list will act like an event callback list and can be\n\t * \"fired\" multiple times.\n\t *\n\t * Possible options:\n\t *\n\t *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n\t *\n\t *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n\t *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n\t *\t\t\t\t\tvalues (like a Deferred)\n\t *\n\t *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n\t *\n\t *\tstopOnFalse:\tinterrupt callings when a callback returns false\n\t *\n\t */\n\tjQuery.Callbacks = function( options ) {\n\t\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ?\n\t\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\t\tjQuery.extend( {}, options );\n\t\n\t\tvar // Last fire value (for non-forgettable lists)\n\t\t\tmemory,\n\t\t\t// Flag to know if list was already fired\n\t\t\tfired,\n\t\t\t// Flag to know if list is currently firing\n\t\t\tfiring,\n\t\t\t// First callback to fire (used internally by add and fireWith)\n\t\t\tfiringStart,\n\t\t\t// End of the loop when firing\n\t\t\tfiringLength,\n\t\t\t// Index of currently firing callback (modified by remove if needed)\n\t\t\tfiringIndex,\n\t\t\t// Actual callback list\n\t\t\tlist = [],\n\t\t\t// Stack of fire calls for repeatable lists\n\t\t\tstack = !options.once && [],\n\t\t\t// Fire callbacks\n\t\t\tfire = function( data ) {\n\t\t\t\tmemory = options.memory && data;\n\t\t\t\tfired = true;\n\t\t\t\tfiringIndex = firingStart || 0;\n\t\t\t\tfiringStart = 0;\n\t\t\t\tfiringLength = list.length;\n\t\t\t\tfiring = true;\n\t\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfiring = false;\n\t\t\t\tif ( list ) {\n\t\t\t\t\tif ( stack ) {\n\t\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tlist = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.disable();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Actual Callbacks object\n\t\t\tself = {\n\t\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\t\tadd: function() {\n\t\t\t\t\tif ( list ) {\n\t\t\t\t\t\t// First, we save the current length\n\t\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})( arguments );\n\t\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t\t// current firing batch?\n\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t\t// we should call right away\n\t\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Remove a callback from the list\n\t\t\t\tremove: function() {\n\t\t\t\t\tif ( list ) {\n\t\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\t\tvar index;\n\t\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Check if a given callback is in the list.\n\t\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\t\thas: function( fn ) {\n\t\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t\t},\n\t\t\t\t// Remove all callbacks from the list\n\t\t\t\tempty: function() {\n\t\t\t\t\tlist = [];\n\t\t\t\t\tfiringLength = 0;\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Have the list do nothing anymore\n\t\t\t\tdisable: function() {\n\t\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Is it disabled?\n\t\t\t\tdisabled: function() {\n\t\t\t\t\treturn !list;\n\t\t\t\t},\n\t\t\t\t// Lock the list in its current state\n\t\t\t\tlock: function() {\n\t\t\t\t\tstack = undefined;\n\t\t\t\t\tif ( !memory ) {\n\t\t\t\t\t\tself.disable();\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Is it locked?\n\t\t\t\tlocked: function() {\n\t\t\t\t\treturn !stack;\n\t\t\t\t},\n\t\t\t\t// Call all callbacks with the given context and arguments\n\t\t\t\tfireWith: function( context, args ) {\n\t\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\t\targs = args || [];\n\t\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfire( args );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Call all the callbacks with the given arguments\n\t\t\t\tfire: function() {\n\t\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// To know if the callbacks have already been called at least once\n\t\t\t\tfired: function() {\n\t\t\t\t\treturn !!fired;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\treturn self;\n\t};\n\t\n\t\n\tjQuery.extend({\n\t\n\t\tDeferred: function( func ) {\n\t\t\tvar tuples = [\n\t\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t\t],\n\t\t\t\tstate = \"pending\",\n\t\t\t\tpromise = {\n\t\t\t\t\tstate: function() {\n\t\t\t\t\t\treturn state;\n\t\t\t\t\t},\n\t\t\t\t\talways: function() {\n\t\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tfns = null;\n\t\t\t\t\t\t}).promise();\n\t\t\t\t\t},\n\t\t\t\t\t// Get a promise for this deferred\n\t\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdeferred = {};\n\t\n\t\t\t// Keep pipe for back-compat\n\t\t\tpromise.pipe = promise.then;\n\t\n\t\t\t// Add list-specific methods\n\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\tvar list = tuple[ 2 ],\n\t\t\t\t\tstateString = tuple[ 3 ];\n\t\n\t\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\t\tpromise[ tuple[1] ] = list.add;\n\t\n\t\t\t\t// Handle state\n\t\t\t\tif ( stateString ) {\n\t\t\t\t\tlist.add(function() {\n\t\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\t\tstate = stateString;\n\t\n\t\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t\t}\n\t\n\t\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t\t});\n\t\n\t\t\t// Make the deferred a promise\n\t\t\tpromise.promise( deferred );\n\t\n\t\t\t// Call given func if any\n\t\t\tif ( func ) {\n\t\t\t\tfunc.call( deferred, deferred );\n\t\t\t}\n\t\n\t\t\t// All done!\n\t\t\treturn deferred;\n\t\t},\n\t\n\t\t// Deferred helper\n\t\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\t\tvar i = 0,\n\t\t\t\tresolveValues = slice.call( arguments ),\n\t\t\t\tlength = resolveValues.length,\n\t\n\t\t\t\t// the count of uncompleted subordinates\n\t\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\t\n\t\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\t\n\t\t\t\t// Update function for both resolve and progress values\n\t\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\t\treturn function( value ) {\n\t\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\t\n\t\t\t\tprogressValues, progressContexts, resolveContexts;\n\t\n\t\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\t\tif ( length > 1 ) {\n\t\t\t\tprogressValues = new Array( length );\n\t\t\t\tprogressContexts = new Array( length );\n\t\t\t\tresolveContexts = new Array( length );\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--remaining;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// If we're not waiting on anything, resolve the master\n\t\t\tif ( !remaining ) {\n\t\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t\t}\n\t\n\t\t\treturn deferred.promise();\n\t\t}\n\t});\n\t\n\t\n\t// The deferred used on DOM ready\n\tvar readyList;\n\t\n\tjQuery.fn.ready = function( fn ) {\n\t\t// Add the callback\n\t\tjQuery.ready.promise().done( fn );\n\t\n\t\treturn this;\n\t};\n\t\n\tjQuery.extend({\n\t\t// Is the DOM ready to be used? Set to true once it occurs.\n\t\tisReady: false,\n\t\n\t\t// A counter to track how many items to wait for before\n\t\t// the ready event fires. See #6781\n\t\treadyWait: 1,\n\t\n\t\t// Hold (or release) the ready event\n\t\tholdReady: function( hold ) {\n\t\t\tif ( hold ) {\n\t\t\t\tjQuery.readyWait++;\n\t\t\t} else {\n\t\t\t\tjQuery.ready( true );\n\t\t\t}\n\t\t},\n\t\n\t\t// Handle when the DOM is ready\n\t\tready: function( wait ) {\n\t\n\t\t\t// Abort if there are pending holds or we're already ready\n\t\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\t\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith( document, [ jQuery ] );\n\t\n\t\t\t// Trigger any bound ready events\n\t\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\t\tjQuery( document ).off( \"ready\" );\n\t\t\t}\n\t\t}\n\t});\n\t\n\t/**\n\t * The ready event handler and self cleanup method\n\t */\n\tfunction completed() {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\t\twindow.removeEventListener( \"load\", completed, false );\n\t\tjQuery.ready();\n\t}\n\t\n\tjQuery.ready.promise = function( obj ) {\n\t\tif ( !readyList ) {\n\t\n\t\t\treadyList = jQuery.Deferred();\n\t\n\t\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t\t// We once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\t\tsetTimeout( jQuery.ready );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// Use the handy event callback\n\t\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\t\n\t\t\t\t// A fallback to window.onload, that will always work\n\t\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t\t}\n\t\t}\n\t\treturn readyList.promise( obj );\n\t};\n\t\n\t// Kick off the DOM ready check even if the user does not\n\tjQuery.ready.promise();\n\t\n\t\n\t\n\t\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\tvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlen = elems.length,\n\t\t\tbulk = key == null;\n\t\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t\t}\n\t\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\t\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\t\n\t\t\tif ( bulk ) {\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\t\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn chainable ?\n\t\t\telems :\n\t\n\t\t\t// Gets\n\t\t\tbulk ?\n\t\t\t\tfn.call( elems ) :\n\t\t\t\tlen ? fn( elems[0], key ) : emptyGet;\n\t};\n\t\n\t\n\t/**\n\t * Determines whether an object can have data\n\t */\n\tjQuery.acceptData = function( owner ) {\n\t\t// Accepts only:\n\t\t//  - Node\n\t\t//    - Node.ELEMENT_NODE\n\t\t//    - Node.DOCUMENT_NODE\n\t\t//  - Object\n\t\t//    - Any\n\t\t/* jshint -W018 */\n\t\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n\t};\n\t\n\t\n\tfunction Data() {\n\t\t// Support: Android<4,\n\t\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t\t// return new empty object instead with no [[set]] accessor\n\t\tObject.defineProperty( this.cache = {}, 0, {\n\t\t\tget: function() {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t});\n\t\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\t\n\tData.uid = 1;\n\tData.accepts = jQuery.acceptData;\n\t\n\tData.prototype = {\n\t\tkey: function( owner ) {\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return the key for a frozen object.\n\t\t\tif ( !Data.accepts( owner ) ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\tvar descriptor = {},\n\t\t\t\t// Check if the owner object already has a cache key\n\t\t\t\tunlock = owner[ this.expando ];\n\t\n\t\t\t// If not, create one\n\t\t\tif ( !unlock ) {\n\t\t\t\tunlock = Data.uid++;\n\t\n\t\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\t\ttry {\n\t\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\t\tObject.defineProperties( owner, descriptor );\n\t\n\t\t\t\t// Support: Android<4\n\t\t\t\t// Fallback to a less secure definition\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Ensure the cache object\n\t\t\tif ( !this.cache[ unlock ] ) {\n\t\t\t\tthis.cache[ unlock ] = {};\n\t\t\t}\n\t\n\t\t\treturn unlock;\n\t\t},\n\t\tset: function( owner, data, value ) {\n\t\t\tvar prop,\n\t\t\t\t// There may be an unlock assigned to this node,\n\t\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\t\tunlock = this.key( owner ),\n\t\t\t\tcache = this.cache[ unlock ];\n\t\n\t\t\t// Handle: [ owner, key, value ] args\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\tcache[ data ] = value;\n\t\n\t\t\t// Handle: [ owner, { properties } ] args\n\t\t\t} else {\n\t\t\t\t// Fresh assignments by object are shallow copied\n\t\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t\t} else {\n\t\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cache;\n\t\t},\n\t\tget: function( owner, key ) {\n\t\t\t// Either a valid cache is found, or will be created.\n\t\t\t// New caches will be created and the unlock returned,\n\t\t\t// allowing direct access to the newly created\n\t\t\t// empty data object. A valid owner object must be provided.\n\t\t\tvar cache = this.cache[ this.key( owner ) ];\n\t\n\t\t\treturn key === undefined ?\n\t\t\t\tcache : cache[ key ];\n\t\t},\n\t\taccess: function( owner, key, value ) {\n\t\t\tvar stored;\n\t\t\t// In cases where either:\n\t\t\t//\n\t\t\t//   1. No key was specified\n\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t//\n\t\t\t// Take the \"read\" path and allow the get method to determine\n\t\t\t// which value to return, respectively either:\n\t\t\t//\n\t\t\t//   1. The entire cache object\n\t\t\t//   2. The data stored at the key\n\t\t\t//\n\t\t\tif ( key === undefined ||\n\t\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\t\n\t\t\t\tstored = this.get( owner, key );\n\t\n\t\t\t\treturn stored !== undefined ?\n\t\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t\t}\n\t\n\t\t\t// [*]When the key is not a string, or both a key and value\n\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t//\n\t\t\t//   1. An object of properties\n\t\t\t//   2. A key and value\n\t\t\t//\n\t\t\tthis.set( owner, key, value );\n\t\n\t\t\t// Since the \"set\" path can have two possible entry points\n\t\t\t// return the expected data based on which path was taken[*]\n\t\t\treturn value !== undefined ? value : key;\n\t\t},\n\t\tremove: function( owner, key ) {\n\t\t\tvar i, name, camel,\n\t\t\t\tunlock = this.key( owner ),\n\t\t\t\tcache = this.cache[ unlock ];\n\t\n\t\t\tif ( key === undefined ) {\n\t\t\t\tthis.cache[ unlock ] = {};\n\t\n\t\t\t} else {\n\t\t\t\t// Support array or space separated string of keys\n\t\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t\t} else {\n\t\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\t\tif ( key in cache ) {\n\t\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\t\tname = camel;\n\t\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\ti = name.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasData: function( owner ) {\n\t\t\treturn !jQuery.isEmptyObject(\n\t\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t\t);\n\t\t},\n\t\tdiscard: function( owner ) {\n\t\t\tif ( owner[ this.expando ] ) {\n\t\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t\t}\n\t\t}\n\t};\n\tvar data_priv = new Data();\n\t\n\tvar data_user = new Data();\n\t\n\t\n\t\n\t//\tImplementation Summary\n\t//\n\t//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t//\t2. Improve the module's maintainability by reducing the storage\n\t//\t\tpaths to a single mechanism.\n\t//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\t\n\tvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t\trmultiDash = /([A-Z])/g;\n\t\n\tfunction dataAttr( elem, key, data ) {\n\t\tvar name;\n\t\n\t\t// If nothing was found internally, try to fetch any\n\t\t// data from the HTML5 data-* attribute\n\t\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\t\tdata = elem.getAttribute( name );\n\t\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\ttry {\n\t\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\t\tdata;\n\t\t\t\t} catch( e ) {}\n\t\n\t\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\t\tdata_user.set( elem, key, data );\n\t\t\t} else {\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\t\n\tjQuery.extend({\n\t\thasData: function( elem ) {\n\t\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t\t},\n\t\n\t\tdata: function( elem, name, data ) {\n\t\t\treturn data_user.access( elem, name, data );\n\t\t},\n\t\n\t\tremoveData: function( elem, name ) {\n\t\t\tdata_user.remove( elem, name );\n\t\t},\n\t\n\t\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t\t// with direct calls to data_priv methods, these can be deprecated.\n\t\t_data: function( elem, name, data ) {\n\t\t\treturn data_priv.access( elem, name, data );\n\t\t},\n\t\n\t\t_removeData: function( elem, name ) {\n\t\t\tdata_priv.remove( elem, name );\n\t\t}\n\t});\n\t\n\tjQuery.fn.extend({\n\t\tdata: function( key, value ) {\n\t\t\tvar i, name, data,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tattrs = elem && elem.attributes;\n\t\n\t\t\t// Gets all values\n\t\t\tif ( key === undefined ) {\n\t\t\t\tif ( this.length ) {\n\t\t\t\t\tdata = data_user.get( elem );\n\t\n\t\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\t\ti = attrs.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\n\t\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\t\t}\n\t\n\t\t\t// Sets multiple values\n\t\t\tif ( typeof key === \"object\" ) {\n\t\t\t\treturn this.each(function() {\n\t\t\t\t\tdata_user.set( this, key );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar data,\n\t\t\t\t\tcamelKey = jQuery.camelCase( key );\n\t\n\t\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// with the key as-is\n\t\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// with the key camelized\n\t\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Set the data...\n\t\t\t\tthis.each(function() {\n\t\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\t\tvar data = data_user.get( this, camelKey );\n\t\n\t\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t\t// This might not apply to all properties...*\n\t\t\t\t\tdata_user.set( this, camelKey, value );\n\t\n\t\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t\t// unchanged property.\n\t\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, null, value, arguments.length > 1, null, true );\n\t\t},\n\t\n\t\tremoveData: function( key ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.remove( this, key );\n\t\t\t});\n\t\t}\n\t});\n\t\n\t\n\tjQuery.extend({\n\t\tqueue: function( elem, type, data ) {\n\t\t\tvar queue;\n\t\n\t\t\tif ( elem ) {\n\t\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\t\tqueue = data_priv.get( elem, type );\n\t\n\t\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.push( data );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn queue || [];\n\t\t\t}\n\t\t},\n\t\n\t\tdequeue: function( elem, type ) {\n\t\t\ttype = type || \"fx\";\n\t\n\t\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\t\tstartLength = queue.length,\n\t\t\t\tfn = queue.shift(),\n\t\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\t\tnext = function() {\n\t\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t\t};\n\t\n\t\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\t\tif ( fn === \"inprogress\" ) {\n\t\t\t\tfn = queue.shift();\n\t\t\t\tstartLength--;\n\t\t\t}\n\t\n\t\t\tif ( fn ) {\n\t\n\t\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t\t// automatically dequeued\n\t\t\t\tif ( type === \"fx\" ) {\n\t\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Clear up the last queue stop function\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tfn.call( elem, next, hooks );\n\t\t\t}\n\t\n\t\t\tif ( !startLength && hooks ) {\n\t\t\t\thooks.empty.fire();\n\t\t\t}\n\t\t},\n\t\n\t\t// Not public - generate a queueHooks object, or return the current one\n\t\t_queueHooks: function( elem, type ) {\n\t\t\tvar key = type + \"queueHooks\";\n\t\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t\t})\n\t\t\t});\n\t\t}\n\t});\n\t\n\tjQuery.fn.extend({\n\t\tqueue: function( type, data ) {\n\t\t\tvar setter = 2;\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tdata = type;\n\t\t\t\ttype = \"fx\";\n\t\t\t\tsetter--;\n\t\t\t}\n\t\n\t\t\tif ( arguments.length < setter ) {\n\t\t\t\treturn jQuery.queue( this[0], type );\n\t\t\t}\n\t\n\t\t\treturn data === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function() {\n\t\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\t\n\t\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\t\tjQuery._queueHooks( this, type );\n\t\n\t\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t},\n\t\tdequeue: function( type ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t});\n\t\t},\n\t\tclearQueue: function( type ) {\n\t\t\treturn this.queue( type || \"fx\", [] );\n\t\t},\n\t\t// Get a promise resolved when queues of a certain type\n\t\t// are emptied (fx is the type by default)\n\t\tpromise: function( type, obj ) {\n\t\t\tvar tmp,\n\t\t\t\tcount = 1,\n\t\t\t\tdefer = jQuery.Deferred(),\n\t\t\t\telements = this,\n\t\t\t\ti = this.length,\n\t\t\t\tresolve = function() {\n\t\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tobj = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\ttype = type || \"fx\";\n\t\n\t\t\twhile ( i-- ) {\n\t\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp.empty.add( resolve );\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve();\n\t\t\treturn defer.promise( obj );\n\t\t}\n\t});\n\tvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\t\n\tvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\t\n\tvar isHidden = function( elem, el ) {\n\t\t\t// isHidden might be called from jQuery#filter function;\n\t\t\t// in that case, element will be second argument\n\t\t\telem = el || elem;\n\t\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t\t};\n\t\n\tvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\t\n\t\n\t\n\t(function() {\n\t\tvar fragment = document.createDocumentFragment(),\n\t\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\t\tinput = document.createElement( \"input\" );\n\t\n\t\t// Support: Safari<=5.1\n\t\t// Check state lost if the name is set (#11217)\n\t\t// Support: Windows Web Apps (WWA)\n\t\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\t\tinput.setAttribute( \"type\", \"radio\" );\n\t\tinput.setAttribute( \"checked\", \"checked\" );\n\t\tinput.setAttribute( \"name\", \"t\" );\n\t\n\t\tdiv.appendChild( input );\n\t\n\t\t// Support: Safari<=5.1, Android<4.2\n\t\t// Older WebKit doesn't clone checked state correctly in fragments\n\t\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\t\n\t\t// Support: IE<=11+\n\t\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\t\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\t})();\n\tvar strundefined = typeof undefined;\n\t\n\t\n\t\n\tsupport.focusinBubbles = \"onfocusin\" in window;\n\t\n\t\n\tvar\n\t\trkeyEvent = /^key/,\n\t\trmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\t\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\t\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\t\n\tfunction returnTrue() {\n\t\treturn true;\n\t}\n\t\n\tfunction returnFalse() {\n\t\treturn false;\n\t}\n\t\n\tfunction safeActiveElement() {\n\t\ttry {\n\t\t\treturn document.activeElement;\n\t\t} catch ( err ) { }\n\t}\n\t\n\t/*\n\t * Helper functions for managing events -- not part of the public interface.\n\t * Props to Dean Edwards' addEvent library for many of the ideas.\n\t */\n\tjQuery.event = {\n\t\n\t\tglobal: {},\n\t\n\t\tadd: function( elem, types, handler, data, selector ) {\n\t\n\t\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = data_priv.get( elem );\n\t\n\t\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\t\tif ( !elemData ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\t\tif ( handler.handler ) {\n\t\t\t\thandleObjIn = handler;\n\t\t\t\thandler = handleObjIn.handler;\n\t\t\t\tselector = handleObjIn.selector;\n\t\t\t}\n\t\n\t\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\t\tif ( !handler.guid ) {\n\t\t\t\thandler.guid = jQuery.guid++;\n\t\t\t}\n\t\n\t\t\t// Init the element's event structure and main handler, if this is the first\n\t\t\tif ( !(events = elemData.events) ) {\n\t\t\t\tevents = elemData.events = {};\n\t\t\t}\n\t\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\t\treturn typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n\t\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Handle multiple events separated by a space\n\t\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\t\n\t\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\n\t\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\n\t\t\t\t// Update special based on newly reset type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\n\t\t\t\t// handleObj is passed to all event handlers\n\t\t\t\thandleObj = jQuery.extend({\n\t\t\t\t\ttype: type,\n\t\t\t\t\torigType: origType,\n\t\t\t\t\tdata: data,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\tguid: handler.guid,\n\t\t\t\t\tselector: selector,\n\t\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t\t}, handleObjIn );\n\t\n\t\t\t\t// Init the event handler queue if we're the first\n\t\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\t\thandlers.delegateCount = 0;\n\t\n\t\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( special.add ) {\n\t\t\t\t\tspecial.add.call( elem, handleObj );\n\t\n\t\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Add to the element's handler list, delegates in front\n\t\t\t\tif ( selector ) {\n\t\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t\t} else {\n\t\t\t\t\thandlers.push( handleObj );\n\t\t\t\t}\n\t\n\t\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\t\tjQuery.event.global[ type ] = true;\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// Detach an event or set of events from an element\n\t\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\t\n\t\t\tvar j, origCount, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\t\n\t\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Once for each type.namespace in types; type may be omitted\n\t\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\t\n\t\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tfor ( type in events ) {\n\t\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\t\thandlers = events[ type ] || [];\n\t\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\t\n\t\t\t\t// Remove matching events\n\t\t\t\torigCount = j = handlers.length;\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\thandleObj = handlers[ j ];\n\t\n\t\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\t\thandlers.splice( j, 1 );\n\t\n\t\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdelete events[ type ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\t\tdelete elemData.handle;\n\t\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t\t}\n\t\t},\n\t\n\t\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\n\t\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\t\teventPath = [ elem || document ],\n\t\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\t\n\t\t\tcur = tmp = elem = elem || document;\n\t\n\t\t\t// Don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\t\tnamespaces = type.split(\".\");\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\tnamespaces.sort();\n\t\t\t}\n\t\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\t\n\t\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\t\tevent = event[ jQuery.expando ] ?\n\t\t\t\tevent :\n\t\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\t\n\t\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\t\tevent.namespace = namespaces.join(\".\");\n\t\t\tevent.namespace_re = event.namespace ?\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\t\tnull;\n\t\n\t\t\t// Clean up the event in case it is being reused\n\t\t\tevent.result = undefined;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = elem;\n\t\t\t}\n\t\n\t\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\t\tdata = data == null ?\n\t\t\t\t[ event ] :\n\t\t\t\tjQuery.makeArray( data, [ event ] );\n\t\n\t\t\t// Allow special events to draw outside the lines\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\tbubbleType = special.delegateType || type;\n\t\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\t\teventPath.push( cur );\n\t\t\t\t\ttmp = cur;\n\t\t\t\t}\n\t\n\t\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Fire handlers on the event path\n\t\t\ti = 0;\n\t\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\t\n\t\t\t\tevent.type = i > 1 ?\n\t\t\t\t\tbubbleType :\n\t\t\t\t\tspecial.bindType || type;\n\t\n\t\t\t\t// jQuery handler\n\t\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\t\tif ( handle ) {\n\t\t\t\t\thandle.apply( cur, data );\n\t\t\t\t}\n\t\n\t\t\t\t// Native handler\n\t\t\t\thandle = ontype && cur[ ontype ];\n\t\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.type = type;\n\t\n\t\t\t// If nobody prevented the default action, do it now\n\t\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\t\n\t\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\t\tjQuery.acceptData( elem ) ) {\n\t\n\t\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\t\ttmp = elem[ ontype ];\n\t\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t\tjQuery.event.triggered = undefined;\n\t\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn event.result;\n\t\t},\n\t\n\t\tdispatch: function( event ) {\n\t\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tevent = jQuery.event.fix( event );\n\t\n\t\t\tvar i, j, ret, matched, handleObj,\n\t\t\t\thandlerQueue = [],\n\t\t\t\targs = slice.call( arguments ),\n\t\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\t\n\t\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\t\targs[0] = event;\n\t\t\tevent.delegateTarget = this;\n\t\n\t\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Determine handlers\n\t\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\t\n\t\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\t\ti = 0;\n\t\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\t\tevent.currentTarget = matched.elem;\n\t\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\t\n\t\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\t\n\t\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\t\tevent.data = handleObj.data;\n\t\n\t\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t\t.apply( matched.elem, args );\n\t\n\t\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Call the postDispatch hook for the mapped type\n\t\t\tif ( special.postDispatch ) {\n\t\t\t\tspecial.postDispatch.call( this, event );\n\t\t\t}\n\t\n\t\t\treturn event.result;\n\t\t},\n\t\n\t\thandlers: function( event, handlers ) {\n\t\t\tvar i, matches, sel, handleObj,\n\t\t\t\thandlerQueue = [],\n\t\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\t\tcur = event.target;\n\t\n\t\t\t// Find delegate handlers\n\t\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\t\n\t\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\t\n\t\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\t\tmatches = [];\n\t\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\t\thandleObj = handlers[ i ];\n\t\n\t\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\t\n\t\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Add the remaining (directly-bound) handlers\n\t\t\tif ( delegateCount < handlers.length ) {\n\t\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t\t}\n\t\n\t\t\treturn handlerQueue;\n\t\t},\n\t\n\t\t// Includes some event props shared by KeyEvent and MouseEvent\n\t\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\t\n\t\tfixHooks: {},\n\t\n\t\tkeyHooks: {\n\t\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\t\tfilter: function( event, original ) {\n\t\n\t\t\t\t// Add which for key events\n\t\t\t\tif ( event.which == null ) {\n\t\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t\t}\n\t\n\t\t\t\treturn event;\n\t\t\t}\n\t\t},\n\t\n\t\tmouseHooks: {\n\t\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\t\tfilter: function( event, original ) {\n\t\t\t\tvar eventDoc, doc, body,\n\t\t\t\t\tbutton = original.button;\n\t\n\t\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\t\tbody = eventDoc.body;\n\t\n\t\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t\t}\n\t\n\t\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t\t// Note: button is not normalized, so don't use it\n\t\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t\t}\n\t\n\t\t\t\treturn event;\n\t\t\t}\n\t\t},\n\t\n\t\tfix: function( event ) {\n\t\t\tif ( event[ jQuery.expando ] ) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\n\t\t\t// Create a writable copy of the event object and normalize some properties\n\t\t\tvar i, prop, copy,\n\t\t\t\ttype = event.type,\n\t\t\t\toriginalEvent = event,\n\t\t\t\tfixHook = this.fixHooks[ type ];\n\t\n\t\t\tif ( !fixHook ) {\n\t\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t\t{};\n\t\t\t}\n\t\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\t\n\t\t\tevent = new jQuery.Event( originalEvent );\n\t\n\t\t\ti = copy.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tprop = copy[ i ];\n\t\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t\t}\n\t\n\t\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t\t// All events should have a target; Cordova deviceready doesn't\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = document;\n\t\t\t}\n\t\n\t\t\t// Support: Safari 6.0+, Chrome<28\n\t\t\t// Target should not be a text node (#504, #13143)\n\t\t\tif ( event.target.nodeType === 3 ) {\n\t\t\t\tevent.target = event.target.parentNode;\n\t\t\t}\n\t\n\t\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t\t},\n\t\n\t\tspecial: {\n\t\t\tload: {\n\t\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\t\tnoBubble: true\n\t\t\t},\n\t\t\tfocus: {\n\t\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusin\"\n\t\t\t},\n\t\t\tblur: {\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusout\"\n\t\t\t},\n\t\t\tclick: {\n\t\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\t\tthis.click();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t\t_default: function( event ) {\n\t\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tbeforeunload: {\n\t\t\t\tpostDispatch: function( event ) {\n\t\n\t\t\t\t\t// Support: Firefox 20+\n\t\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tsimulate: function( type, elem, event, bubble ) {\n\t\t\t// Piggyback on a donor event to simulate a different one.\n\t\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t\t// simulated event prevents default then we do the same on the donor.\n\t\t\tvar e = jQuery.extend(\n\t\t\t\tnew jQuery.Event(),\n\t\t\t\tevent,\n\t\t\t\t{\n\t\t\t\t\ttype: type,\n\t\t\t\t\tisSimulated: true,\n\t\t\t\t\toriginalEvent: {}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( bubble ) {\n\t\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t\t} else {\n\t\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t\t}\n\t\t\tif ( e.isDefaultPrevented() ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.removeEvent = function( elem, type, handle ) {\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle, false );\n\t\t}\n\t};\n\t\n\tjQuery.Event = function( src, props ) {\n\t\t// Allow instantiation without the 'new' keyword\n\t\tif ( !(this instanceof jQuery.Event) ) {\n\t\t\treturn new jQuery.Event( src, props );\n\t\t}\n\t\n\t\t// Event object\n\t\tif ( src && src.type ) {\n\t\t\tthis.originalEvent = src;\n\t\t\tthis.type = src.type;\n\t\n\t\t\t// Events bubbling up the document may have been marked as prevented\n\t\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\t\t// Support: Android<4.0\n\t\t\t\t\tsrc.returnValue === false ?\n\t\t\t\treturnTrue :\n\t\t\t\treturnFalse;\n\t\n\t\t// Event type\n\t\t} else {\n\t\t\tthis.type = src;\n\t\t}\n\t\n\t\t// Put explicitly provided properties onto the event object\n\t\tif ( props ) {\n\t\t\tjQuery.extend( this, props );\n\t\t}\n\t\n\t\t// Create a timestamp if incoming event doesn't have one\n\t\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\t\n\t\t// Mark it as fixed\n\t\tthis[ jQuery.expando ] = true;\n\t};\n\t\n\t// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tjQuery.Event.prototype = {\n\t\tisDefaultPrevented: returnFalse,\n\t\tisPropagationStopped: returnFalse,\n\t\tisImmediatePropagationStopped: returnFalse,\n\t\n\t\tpreventDefault: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isDefaultPrevented = returnTrue;\n\t\n\t\t\tif ( e && e.preventDefault ) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t},\n\t\tstopPropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isPropagationStopped = returnTrue;\n\t\n\t\t\tif ( e && e.stopPropagation ) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tstopImmediatePropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\n\t\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\t\n\t\t\tthis.stopPropagation();\n\t\t}\n\t};\n\t\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\t// Support: Chrome 15+\n\tjQuery.each({\n\t\tmouseenter: \"mouseover\",\n\t\tmouseleave: \"mouseout\",\n\t\tpointerenter: \"pointerover\",\n\t\tpointerleave: \"pointerout\"\n\t}, function( orig, fix ) {\n\t\tjQuery.event.special[ orig ] = {\n\t\t\tdelegateType: fix,\n\t\t\tbindType: fix,\n\t\n\t\t\thandle: function( event ) {\n\t\t\t\tvar ret,\n\t\t\t\t\ttarget = this,\n\t\t\t\t\trelated = event.relatedTarget,\n\t\t\t\t\thandleObj = event.handleObj;\n\t\n\t\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\t\tevent.type = fix;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t};\n\t});\n\t\n\t// Support: Firefox, Chrome, Safari\n\t// Create \"bubbling\" focus and blur events\n\tif ( !support.focusinBubbles ) {\n\t\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\t\n\t\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\t\tvar handler = function( event ) {\n\t\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t\t};\n\t\n\t\t\tjQuery.event.special[ fix ] = {\n\t\t\t\tsetup: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = data_priv.access( doc, fix );\n\t\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = data_priv.access( doc, fix ) - 1;\n\t\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\t\tdata_priv.remove( doc, fix );\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata_priv.access( doc, fix, attaches );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\t\n\tjQuery.fn.extend({\n\t\n\t\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\t\tvar origFn, type;\n\t\n\t\t\t// Types can be a map of types/handlers\n\t\t\tif ( typeof types === \"object\" ) {\n\t\t\t\t// ( types-Object, selector, data )\n\t\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t\t// ( types-Object, data )\n\t\t\t\t\tdata = data || selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\tif ( data == null && fn == null ) {\n\t\t\t\t// ( types, fn )\n\t\t\t\tfn = selector;\n\t\t\t\tdata = selector = undefined;\n\t\t\t} else if ( fn == null ) {\n\t\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t\t// ( types, selector, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = undefined;\n\t\t\t\t} else {\n\t\t\t\t\t// ( types, data, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( fn === false ) {\n\t\t\t\tfn = returnFalse;\n\t\t\t} else if ( !fn ) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\tif ( one === 1 ) {\n\t\t\t\torigFn = fn;\n\t\t\t\tfn = function( event ) {\n\t\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\t\tjQuery().off( event );\n\t\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t\t};\n\t\t\t\t// Use same guid so caller can remove using origFn\n\t\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t\t});\n\t\t},\n\t\tone: function( types, selector, data, fn ) {\n\t\t\treturn this.on( types, selector, data, fn, 1 );\n\t\t},\n\t\toff: function( types, selector, fn ) {\n\t\t\tvar handleObj, type;\n\t\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\t\thandleObj = types.handleObj;\n\t\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\t\thandleObj.selector,\n\t\t\t\t\thandleObj.handler\n\t\t\t\t);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( typeof types === \"object\" ) {\n\t\t\t\t// ( types-object [, selector] )\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t\t// ( types [, fn] )\n\t\t\t\tfn = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tif ( fn === false ) {\n\t\t\t\tfn = returnFalse;\n\t\t\t}\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t\t});\n\t\t},\n\t\n\t\ttrigger: function( type, data ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.event.trigger( type, data, this );\n\t\t\t});\n\t\t},\n\t\ttriggerHandler: function( type, data ) {\n\t\t\tvar elem = this[0];\n\t\t\tif ( elem ) {\n\t\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t\t}\n\t\t}\n\t});\n\t\n\t\n\tvar\n\t\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\t\trtagName = /<([\\w:]+)/,\n\t\trhtml = /<|&#?\\w+;/,\n\t\trnoInnerhtml = /<(?:script|style|link)/i,\n\t\t// checked=\"checked\" or checked\n\t\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\t\trscriptTypeMasked = /^true\\/(.*)/,\n\t\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\t\n\t\t// We have to close these tags to support XHTML (#13200)\n\t\twrapMap = {\n\t\n\t\t\t// Support: IE9\n\t\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\n\t\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\t\n\t\t\t_default: [ 0, \"\", \"\" ]\n\t\t};\n\t\n\t// Support: IE9\n\twrapMap.optgroup = wrapMap.option;\n\t\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n\t\n\t// Support: 1.x compatibility\n\t// Manipulating tables requires a tbody\n\tfunction manipulationTarget( elem, content ) {\n\t\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\t\n\t\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\t\telem;\n\t}\n\t\n\t// Replace/restore the type attribute of script elements for safe DOM manipulation\n\tfunction disableScript( elem ) {\n\t\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\t\treturn elem;\n\t}\n\tfunction restoreScript( elem ) {\n\t\tvar match = rscriptTypeMasked.exec( elem.type );\n\t\n\t\tif ( match ) {\n\t\t\telem.type = match[ 1 ];\n\t\t} else {\n\t\t\telem.removeAttribute(\"type\");\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\t// Mark scripts as having already been evaluated\n\tfunction setGlobalEval( elems, refElements ) {\n\t\tvar i = 0,\n\t\t\tl = elems.length;\n\t\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tdata_priv.set(\n\t\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t\t);\n\t\t}\n\t}\n\t\n\tfunction cloneCopyEvent( src, dest ) {\n\t\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\t\n\t\tif ( dest.nodeType !== 1 ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// 1. Copy private data: events, handlers, etc.\n\t\tif ( data_priv.hasData( src ) ) {\n\t\t\tpdataOld = data_priv.access( src );\n\t\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\t\tevents = pdataOld.events;\n\t\n\t\t\tif ( events ) {\n\t\t\t\tdelete pdataCur.handle;\n\t\t\t\tpdataCur.events = {};\n\t\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// 2. Copy user data\n\t\tif ( data_user.hasData( src ) ) {\n\t\t\tudataOld = data_user.access( src );\n\t\t\tudataCur = jQuery.extend( {}, udataOld );\n\t\n\t\t\tdata_user.set( dest, udataCur );\n\t\t}\n\t}\n\t\n\tfunction getAll( context, tag ) {\n\t\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t\t[];\n\t\n\t\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\t\tjQuery.merge( [ context ], ret ) :\n\t\t\tret;\n\t}\n\t\n\t// Fix IE bugs, see support tests\n\tfunction fixInput( src, dest ) {\n\t\tvar nodeName = dest.nodeName.toLowerCase();\n\t\n\t\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\t\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\t\tdest.checked = src.checked;\n\t\n\t\t// Fails to return the selected option to the default selected state when cloning options\n\t\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\t\tdest.defaultValue = src.defaultValue;\n\t\t}\n\t}\n\t\n\tjQuery.extend({\n\t\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\t\tvar i, l, srcElements, destElements,\n\t\t\t\tclone = elem.cloneNode( true ),\n\t\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\t\n\t\t\t// Fix IE cloning issues\n\t\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\t\n\t\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\t\tdestElements = getAll( clone );\n\t\t\t\tsrcElements = getAll( elem );\n\t\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Copy the events from the original to the clone\n\t\t\tif ( dataAndEvents ) {\n\t\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\t\tdestElements = destElements || getAll( clone );\n\t\n\t\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Preserve script evaluation history\n\t\t\tdestElements = getAll( clone, \"script\" );\n\t\t\tif ( destElements.length > 0 ) {\n\t\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t\t}\n\t\n\t\t\t// Return the cloned set\n\t\t\treturn clone;\n\t\t},\n\t\n\t\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\t\tfragment = context.createDocumentFragment(),\n\t\t\t\tnodes = [],\n\t\t\t\ti = 0,\n\t\t\t\tl = elems.length;\n\t\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\telem = elems[ i ];\n\t\n\t\t\t\tif ( elem || elem === 0 ) {\n\t\n\t\t\t\t\t// Add nodes directly\n\t\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\t\n\t\t\t\t\t// Convert non-html into a text node\n\t\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\t\n\t\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\t\n\t\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\t\n\t\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\t\n\t\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\t\ttmp = fragment.firstChild;\n\t\n\t\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Remove wrapper from fragment\n\t\t\tfragment.textContent = \"\";\n\t\n\t\t\ti = 0;\n\t\t\twhile ( (elem = nodes[ i++ ]) ) {\n\t\n\t\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t\t// that element, do not do anything\n\t\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\t\n\t\t\t\t// Append to fragment\n\t\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\t\n\t\t\t\t// Preserve script evaluation history\n\t\t\t\tif ( contains ) {\n\t\t\t\t\tsetGlobalEval( tmp );\n\t\t\t\t}\n\t\n\t\t\t\t// Capture executables\n\t\t\t\tif ( scripts ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn fragment;\n\t\t},\n\t\n\t\tcleanData: function( elems ) {\n\t\t\tvar data, elem, type, key,\n\t\t\t\tspecial = jQuery.event.special,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\t\tif ( jQuery.acceptData( elem ) ) {\n\t\t\t\t\tkey = elem[ data_priv.expando ];\n\t\n\t\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\t\n\t\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Discard any remaining `user` data\n\t\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t\t}\n\t\t}\n\t});\n\t\n\tjQuery.fn.extend({\n\t\ttext: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\tjQuery.text( this ) :\n\t\t\t\t\tthis.empty().each(function() {\n\t\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\t\n\t\tappend: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.appendChild( elem );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\n\t\tprepend: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\n\t\tbefore: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\n\t\tafter: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\n\t\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\t\tvar elem,\n\t\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t\t}\n\t\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tempty: function() {\n\t\t\tvar elem,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\n\t\t\t\t\t// Prevent memory leaks\n\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\n\t\t\t\t\t// Remove any remaining nodes\n\t\t\t\t\telem.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\t\n\t\t\treturn this.map(function() {\n\t\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t\t});\n\t\t},\n\t\n\t\thtml: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\t\ti = 0,\n\t\t\t\t\tl = this.length;\n\t\n\t\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\t\treturn elem.innerHTML;\n\t\t\t\t}\n\t\n\t\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\t\n\t\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\t\telem = this[ i ] || {};\n\t\n\t\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\telem = 0;\n\t\n\t\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t\t} catch( e ) {}\n\t\t\t\t}\n\t\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tthis.empty().append( value );\n\t\t\t\t}\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\t\n\t\treplaceWith: function() {\n\t\t\tvar arg = arguments[ 0 ];\n\t\n\t\t\t// Make the changes, replacing each context element with the new content\n\t\t\tthis.domManip( arguments, function( elem ) {\n\t\t\t\targ = this.parentNode;\n\t\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\n\t\t\t\tif ( arg ) {\n\t\t\t\t\targ.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t\t},\n\t\n\t\tdetach: function( selector ) {\n\t\t\treturn this.remove( selector, true );\n\t\t},\n\t\n\t\tdomManip: function( args, callback ) {\n\t\n\t\t\t// Flatten any nested arrays\n\t\t\targs = concat.apply( [], args );\n\t\n\t\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length,\n\t\t\t\tset = this,\n\t\t\t\tiNoClone = l - 1,\n\t\t\t\tvalue = args[ 0 ],\n\t\t\t\tisFunction = jQuery.isFunction( value );\n\t\n\t\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\t\tif ( isFunction ||\n\t\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\t\treturn this.each(function( index ) {\n\t\t\t\t\tvar self = set.eq( index );\n\t\t\t\t\tif ( isFunction ) {\n\t\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t\t}\n\t\t\t\t\tself.domManip( args, callback );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tif ( l ) {\n\t\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\t\tfirst = fragment.firstChild;\n\t\n\t\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\t\tfragment = first;\n\t\t\t\t}\n\t\n\t\t\t\tif ( first ) {\n\t\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\t\thasScripts = scripts.length;\n\t\n\t\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\tnode = fragment;\n\t\n\t\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\t\n\t\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\t\n\t\t\t\t\t\t// Reenable scripts\n\t\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\t\n\t\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\t\n\t\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t}\n\t});\n\t\n\tjQuery.each({\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function( name, original ) {\n\t\tjQuery.fn[ name ] = function( selector ) {\n\t\t\tvar elems,\n\t\t\t\tret = [],\n\t\t\t\tinsert = jQuery( selector ),\n\t\t\t\tlast = insert.length - 1,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; i <= last; i++ ) {\n\t\t\t\telems = i === last ? this : this.clone( true );\n\t\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\t\n\t\t\t\t// Support: QtWebKit\n\t\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\t\tpush.apply( ret, elems.get() );\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( ret );\n\t\t};\n\t});\n\t\n\t\n\tvar iframe,\n\t\telemdisplay = {};\n\t\n\t/**\n\t * Retrieve the actual display of a element\n\t * @param {String} name nodeName of the element\n\t * @param {Object} doc Document object\n\t */\n\t// Called only from within defaultDisplay\n\tfunction actualDisplay( name, doc ) {\n\t\tvar style,\n\t\t\telem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\t\n\t\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\t\tdisplay = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\t\n\t\t\t\t// Use of this method is a temporary fix (more like optimization) until something better comes along,\n\t\t\t\t// since it was removed from specification and supported only in FF\n\t\t\t\tstyle.display : jQuery.css( elem[ 0 ], \"display\" );\n\t\n\t\t// We don't have any data stored on the element,\n\t\t// so use \"detach\" method as fast way to get rid of the element\n\t\telem.detach();\n\t\n\t\treturn display;\n\t}\n\t\n\t/**\n\t * Try to determine the default display value of an element\n\t * @param {String} nodeName\n\t */\n\tfunction defaultDisplay( nodeName ) {\n\t\tvar doc = document,\n\t\t\tdisplay = elemdisplay[ nodeName ];\n\t\n\t\tif ( !display ) {\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\n\t\t\t// If the simple way fails, read from inside an iframe\n\t\t\tif ( display === \"none\" || !display ) {\n\t\n\t\t\t\t// Use the already-created iframe if possible\n\t\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\t\n\t\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\t\tdoc = iframe[ 0 ].contentDocument;\n\t\n\t\t\t\t// Support: IE\n\t\t\t\tdoc.write();\n\t\t\t\tdoc.close();\n\t\n\t\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\t\tiframe.detach();\n\t\t\t}\n\t\n\t\t\t// Store the correct default display\n\t\t\telemdisplay[ nodeName ] = display;\n\t\t}\n\t\n\t\treturn display;\n\t}\n\tvar rmargin = (/^margin/);\n\t\n\tvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\t\n\tvar getStyles = function( elem ) {\n\t\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t\t// IE throws on elements created in popups\n\t\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\t\tif ( elem.ownerDocument.defaultView.opener ) {\n\t\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t\t\t}\n\t\n\t\t\treturn window.getComputedStyle( elem, null );\n\t\t};\n\t\n\t\n\t\n\tfunction curCSS( elem, name, computed ) {\n\t\tvar width, minWidth, maxWidth, ret,\n\t\t\tstyle = elem.style;\n\t\n\t\tcomputed = computed || getStyles( elem );\n\t\n\t\t// Support: IE9\n\t\t// getPropertyValue is only needed for .css('filter') (#12537)\n\t\tif ( computed ) {\n\t\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t\t}\n\t\n\t\tif ( computed ) {\n\t\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\t\n\t\t\t// Support: iOS < 6\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\t\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\t\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\t\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\t\n\t\treturn ret !== undefined ?\n\t\t\t// Support: IE\n\t\t\t// IE returns zIndex value as an integer.\n\t\t\tret + \"\" :\n\t\t\tret;\n\t}\n\t\n\t\n\tfunction addGetHookIf( conditionFn, hookFn ) {\n\t\t// Define the hook, we'll check on the first run if it's really needed.\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\tif ( conditionFn() ) {\n\t\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t\t// to missing dependency), remove it.\n\t\t\t\t\tdelete this.get;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t\t}\n\t\t};\n\t}\n\t\n\t\n\t(function() {\n\t\tvar pixelPositionVal, boxSizingReliableVal,\n\t\t\tdocElem = document.documentElement,\n\t\t\tcontainer = document.createElement( \"div\" ),\n\t\t\tdiv = document.createElement( \"div\" );\n\t\n\t\tif ( !div.style ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Support: IE9-11+\n\t\t// Style of cloned element affects source element cloned (#8908)\n\t\tdiv.style.backgroundClip = \"content-box\";\n\t\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\t\n\t\tcontainer.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" +\n\t\t\t\"position:absolute\";\n\t\tcontainer.appendChild( div );\n\t\n\t\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t\t// so they're executed at the same time to save the second computation.\n\t\tfunction computePixelPositionAndBoxSizingReliable() {\n\t\t\tdiv.style.cssText =\n\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\t\"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n\t\t\t\t\"border:1px;padding:1px;width:4px;position:absolute\";\n\t\t\tdiv.innerHTML = \"\";\n\t\t\tdocElem.appendChild( container );\n\t\n\t\t\tvar divStyle = window.getComputedStyle( div, null );\n\t\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\t\n\t\t\tdocElem.removeChild( container );\n\t\t}\n\t\n\t\t// Support: node.js jsdom\n\t\t// Don't assume that getComputedStyle is a property of the global object\n\t\tif ( window.getComputedStyle ) {\n\t\t\tjQuery.extend( support, {\n\t\t\t\tpixelPosition: function() {\n\t\n\t\t\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t\t\t// No need to check if the test was already performed, though.\n\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t\treturn pixelPositionVal;\n\t\t\t\t},\n\t\t\t\tboxSizingReliable: function() {\n\t\t\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t\t}\n\t\t\t\t\treturn boxSizingReliableVal;\n\t\t\t\t},\n\t\t\t\treliableMarginRight: function() {\n\t\n\t\t\t\t\t// Support: Android 2.3\n\t\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\t\t\tvar ret,\n\t\t\t\t\t\tmarginDiv = div.appendChild( document.createElement( \"div\" ) );\n\t\n\t\t\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\t\t\tmarginDiv.style.cssText = div.style.cssText =\n\t\t\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\t\t\tdiv.style.width = \"1px\";\n\t\t\t\t\tdocElem.appendChild( container );\n\t\n\t\t\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n\t\n\t\t\t\t\tdocElem.removeChild( container );\n\t\t\t\t\tdiv.removeChild( marginDiv );\n\t\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t})();\n\t\n\t\n\t// A method for quickly swapping in/out CSS properties to get correct calculations.\n\tjQuery.swap = function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\t\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\t\n\t\tret = callback.apply( elem, args || [] );\n\t\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\t\n\t\treturn ret;\n\t};\n\t\n\t\n\tvar\n\t\t// Swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\t\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\t\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\t\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\t\n\t\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t\tcssNormalTransform = {\n\t\t\tletterSpacing: \"0\",\n\t\t\tfontWeight: \"400\"\n\t\t},\n\t\n\t\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\t\n\t// Return a css property mapped to a potentially vendor prefixed property\n\tfunction vendorPropName( style, name ) {\n\t\n\t\t// Shortcut for names that are not vendor prefixed\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t\n\t\t// Check for vendor prefixed names\n\t\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\t\torigName = name,\n\t\t\ti = cssPrefixes.length;\n\t\n\t\twhile ( i-- ) {\n\t\t\tname = cssPrefixes[ i ] + capName;\n\t\t\tif ( name in style ) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\t\n\t\treturn origName;\n\t}\n\t\n\tfunction setPositiveNumber( elem, value, subtract ) {\n\t\tvar matches = rnumsplit.exec( value );\n\t\treturn matches ?\n\t\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\t\tvalue;\n\t}\n\t\n\tfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\t\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t\t// If we already have the right measurement, avoid augmentation\n\t\t\t4 :\n\t\t\t// Otherwise initialize for horizontal or vertical properties\n\t\t\tname === \"width\" ? 1 : 0,\n\t\n\t\t\tval = 0;\n\t\n\t\tfor ( ; i < 4; i += 2 ) {\n\t\t\t// Both box models exclude margin, so add it if we want it\n\t\t\tif ( extra === \"margin\" ) {\n\t\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t\t}\n\t\n\t\t\tif ( isBorderBox ) {\n\t\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\t\tif ( extra === \"content\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t\t}\n\t\n\t\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// At this point, extra isn't content, so add padding\n\t\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\n\t\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn val;\n\t}\n\t\n\tfunction getWidthOrHeight( elem, name, extra ) {\n\t\n\t\t// Start with offset property, which is equivalent to the border-box value\n\t\tvar valueIsBorderBox = true,\n\t\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\t\tstyles = getStyles( elem ),\n\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\t\n\t\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\t\tif ( val <= 0 || val == null ) {\n\t\t\t// Fall back to computed then uncomputed css if necessary\n\t\t\tval = curCSS( elem, name, styles );\n\t\t\tif ( val < 0 || val == null ) {\n\t\t\t\tval = elem.style[ name ];\n\t\t\t}\n\t\n\t\t\t// Computed unit is not pixels. Stop here and return.\n\t\t\tif ( rnumnonpx.test(val) ) {\n\t\t\t\treturn val;\n\t\t\t}\n\t\n\t\t\t// Check for style in case a browser which returns unreliable values\n\t\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\t\n\t\t\t// Normalize \"\", auto, and prepare for extra\n\t\t\tval = parseFloat( val ) || 0;\n\t\t}\n\t\n\t\t// Use the active box-sizing model to add/subtract irrelevant styles\n\t\treturn ( val +\n\t\t\taugmentWidthOrHeight(\n\t\t\t\telem,\n\t\t\t\tname,\n\t\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\t\tvalueIsBorderBox,\n\t\t\t\tstyles\n\t\t\t)\n\t\t) + \"px\";\n\t}\n\t\n\tfunction showHide( elements, show ) {\n\t\tvar display, elem, hidden,\n\t\t\tvalues = [],\n\t\t\tindex = 0,\n\t\t\tlength = elements.length;\n\t\n\t\tfor ( ; index < length; index++ ) {\n\t\t\telem = elements[ index ];\n\t\t\tif ( !elem.style ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\t\tdisplay = elem.style.display;\n\t\t\tif ( show ) {\n\t\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t\t// being hidden by cascaded rules or not\n\t\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\n\t\t\t\t// Set elements which have been overridden with display: none\n\t\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t\t// for such an element\n\t\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thidden = isHidden( elem );\n\t\n\t\t\t\tif ( display !== \"none\" || !hidden ) {\n\t\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Set the display of most of the elements in a second loop\n\t\t// to avoid the constant reflow\n\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\telem = elements[ index ];\n\t\t\tif ( !elem.style ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t\t}\n\t\t}\n\t\n\t\treturn elements;\n\t}\n\t\n\tjQuery.extend({\n\t\n\t\t// Add in style property hooks for overriding the default\n\t\t// behavior of getting and setting a style property\n\t\tcssHooks: {\n\t\t\topacity: {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\n\t\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t// Don't automatically add \"px\" to these possibly-unitless properties\n\t\tcssNumber: {\n\t\t\t\"columnCount\": true,\n\t\t\t\"fillOpacity\": true,\n\t\t\t\"flexGrow\": true,\n\t\t\t\"flexShrink\": true,\n\t\t\t\"fontWeight\": true,\n\t\t\t\"lineHeight\": true,\n\t\t\t\"opacity\": true,\n\t\t\t\"order\": true,\n\t\t\t\"orphans\": true,\n\t\t\t\"widows\": true,\n\t\t\t\"zIndex\": true,\n\t\t\t\"zoom\": true\n\t\t},\n\t\n\t\t// Add in properties whose names you wish to fix before\n\t\t// setting or getting the value\n\t\tcssProps: {\n\t\t\t\"float\": \"cssFloat\"\n\t\t},\n\t\n\t\t// Get and set the style property on a DOM Node\n\t\tstyle: function( elem, name, value, extra ) {\n\t\n\t\t\t// Don't set styles on text and comment nodes\n\t\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Make sure that we're working with the right name\n\t\t\tvar ret, type, hooks,\n\t\t\t\torigName = jQuery.camelCase( name ),\n\t\t\t\tstyle = elem.style;\n\t\n\t\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\t\n\t\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\t\n\t\t\t// Check if we're setting a value\n\t\t\tif ( value !== undefined ) {\n\t\t\t\ttype = typeof value;\n\t\n\t\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t\t// Fixes bug #9237\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t}\n\t\n\t\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\t\tif ( value == null || value !== value ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// If a number, add 'px' to the (except for certain CSS properties)\n\t\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\t\tvalue += \"px\";\n\t\t\t\t}\n\t\n\t\t\t\t// Support: IE9-11+\n\t\t\t\t// background-* props affect original clone's values\n\t\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t\t}\n\t\n\t\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\t// Otherwise just get the value from the style object\n\t\t\t\treturn style[ name ];\n\t\t\t}\n\t\t},\n\t\n\t\tcss: function( elem, name, extra, styles ) {\n\t\t\tvar val, num, hooks,\n\t\t\t\torigName = jQuery.camelCase( name );\n\t\n\t\t\t// Make sure that we're working with the right name\n\t\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\t\n\t\t\t// Try prefixed name followed by the unprefixed name\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\t\n\t\t\t// If a hook was provided get the computed value from there\n\t\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\t\tval = hooks.get( elem, true, extra );\n\t\t\t}\n\t\n\t\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t\tif ( val === undefined ) {\n\t\t\t\tval = curCSS( elem, name, styles );\n\t\t\t}\n\t\n\t\t\t// Convert \"normal\" to computed value\n\t\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\t\tval = cssNormalTransform[ name ];\n\t\t\t}\n\t\n\t\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\t\tif ( extra === \"\" || extra ) {\n\t\t\t\tnum = parseFloat( val );\n\t\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t});\n\t\n\tjQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\t\tjQuery.cssHooks[ name ] = {\n\t\t\tget: function( elem, computed, extra ) {\n\t\t\t\tif ( computed ) {\n\t\n\t\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n\t\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tset: function( elem, value, extra ) {\n\t\t\t\tvar styles = extra && getStyles( elem );\n\t\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) : 0\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t});\n\t\n\t// Support: Android 2.3\n\tjQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t\t}\n\t\t}\n\t);\n\t\n\t// These hooks are used by animate to expand properties\n\tjQuery.each({\n\t\tmargin: \"\",\n\t\tpadding: \"\",\n\t\tborder: \"Width\"\n\t}, function( prefix, suffix ) {\n\t\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\t\texpand: function( value ) {\n\t\t\t\tvar i = 0,\n\t\t\t\t\texpanded = {},\n\t\n\t\t\t\t\t// Assumes a single number if not a string\n\t\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\t\n\t\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t\t}\n\t\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\t\n\t\tif ( !rmargin.test( prefix ) ) {\n\t\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t\t}\n\t});\n\t\n\tjQuery.fn.extend({\n\t\tcss: function( name, value ) {\n\t\t\treturn access( this, function( elem, name, value ) {\n\t\t\t\tvar styles, len,\n\t\t\t\t\tmap = {},\n\t\t\t\t\ti = 0;\n\t\n\t\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\t\tstyles = getStyles( elem );\n\t\t\t\t\tlen = name.length;\n\t\n\t\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\t\n\t\t\t\treturn value !== undefined ?\n\t\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\t\tjQuery.css( elem, name );\n\t\t\t}, name, value, arguments.length > 1 );\n\t\t},\n\t\tshow: function() {\n\t\t\treturn showHide( this, true );\n\t\t},\n\t\thide: function() {\n\t\t\treturn showHide( this );\n\t\t},\n\t\ttoggle: function( state ) {\n\t\t\tif ( typeof state === \"boolean\" ) {\n\t\t\t\treturn state ? this.show() : this.hide();\n\t\t\t}\n\t\n\t\t\treturn this.each(function() {\n\t\t\t\tif ( isHidden( this ) ) {\n\t\t\t\t\tjQuery( this ).show();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery( this ).hide();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\t\n\t\n\tfunction Tween( elem, options, prop, end, easing ) {\n\t\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n\t}\n\tjQuery.Tween = Tween;\n\t\n\tTween.prototype = {\n\t\tconstructor: Tween,\n\t\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\t\tthis.elem = elem;\n\t\t\tthis.prop = prop;\n\t\t\tthis.easing = easing || \"swing\";\n\t\t\tthis.options = options;\n\t\t\tthis.start = this.now = this.cur();\n\t\t\tthis.end = end;\n\t\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t\t},\n\t\tcur: function() {\n\t\t\tvar hooks = Tween.propHooks[ this.prop ];\n\t\n\t\t\treturn hooks && hooks.get ?\n\t\t\t\thooks.get( this ) :\n\t\t\t\tTween.propHooks._default.get( this );\n\t\t},\n\t\trun: function( percent ) {\n\t\t\tvar eased,\n\t\t\t\thooks = Tween.propHooks[ this.prop ];\n\t\n\t\t\tif ( this.options.duration ) {\n\t\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.pos = eased = percent;\n\t\t\t}\n\t\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\t\n\t\t\tif ( this.options.step ) {\n\t\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t\t}\n\t\n\t\t\tif ( hooks && hooks.set ) {\n\t\t\t\thooks.set( this );\n\t\t\t} else {\n\t\t\t\tTween.propHooks._default.set( this );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t};\n\t\n\tTween.prototype.init.prototype = Tween.prototype;\n\t\n\tTween.propHooks = {\n\t\t_default: {\n\t\t\tget: function( tween ) {\n\t\t\t\tvar result;\n\t\n\t\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t\t}\n\t\n\t\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t\t},\n\t\t\tset: function( tween ) {\n\t\t\t\t// Use step hook for back compat.\n\t\t\t\t// Use cssHook if its there.\n\t\t\t\t// Use .style if available and use plain properties where available.\n\t\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t\t} else {\n\t\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// Support: IE9\n\t// Panic based approach to setting things on disconnected nodes\n\tTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\t\tset: function( tween ) {\n\t\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.easing = {\n\t\tlinear: function( p ) {\n\t\t\treturn p;\n\t\t},\n\t\tswing: function( p ) {\n\t\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t\t}\n\t};\n\t\n\tjQuery.fx = Tween.prototype.init;\n\t\n\t// Back Compat <1.8 extension point\n\tjQuery.fx.step = {};\n\t\n\t\n\t\n\t\n\tvar\n\t\tfxNow, timerId,\n\t\trfxtypes = /^(?:toggle|show|hide)$/,\n\t\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\t\trrun = /queueHooks$/,\n\t\tanimationPrefilters = [ defaultPrefilter ],\n\t\ttweeners = {\n\t\t\t\"*\": [ function( prop, value ) {\n\t\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\t\ttarget = tween.cur(),\n\t\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\t\n\t\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\t\tscale = 1,\n\t\t\t\t\tmaxIterations = 20;\n\t\n\t\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\t\tunit = unit || start[ 3 ];\n\t\n\t\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\t\tparts = parts || [];\n\t\n\t\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\t\tstart = +target || 1;\n\t\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\t\t\t\tscale = scale || \".5\";\n\t\n\t\t\t\t\t\t// Adjust and apply\n\t\t\t\t\t\tstart = start / scale;\n\t\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\t\n\t\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur(),\n\t\t\t\t\t// break the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t\t}\n\t\n\t\t\t\t// Update tween properties\n\t\t\t\tif ( parts ) {\n\t\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\t\ttween.unit = unit;\n\t\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t\t+parts[ 2 ];\n\t\t\t\t}\n\t\n\t\t\t\treturn tween;\n\t\t\t} ]\n\t\t};\n\t\n\t// Animations created synchronously will run synchronously\n\tfunction createFxNow() {\n\t\tsetTimeout(function() {\n\t\t\tfxNow = undefined;\n\t\t});\n\t\treturn ( fxNow = jQuery.now() );\n\t}\n\t\n\t// Generate parameters to create a standard animation\n\tfunction genFx( type, includeWidth ) {\n\t\tvar which,\n\t\t\ti = 0,\n\t\t\tattrs = { height: type };\n\t\n\t\t// If we include width, step value is 1 to do all cssExpand values,\n\t\t// otherwise step value is 2 to skip over Left and Right\n\t\tincludeWidth = includeWidth ? 1 : 0;\n\t\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\t\twhich = cssExpand[ i ];\n\t\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t\t}\n\t\n\t\tif ( includeWidth ) {\n\t\t\tattrs.opacity = attrs.width = type;\n\t\t}\n\t\n\t\treturn attrs;\n\t}\n\t\n\tfunction createTween( value, prop, animation ) {\n\t\tvar tween,\n\t\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\t\tindex = 0,\n\t\t\tlength = collection.length;\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\t\n\t\t\t\t// We're done with this property\n\t\t\t\treturn tween;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction defaultPrefilter( elem, props, opts ) {\n\t\t/* jshint validthis: true */\n\t\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\t\tanim = this,\n\t\t\torig = {},\n\t\t\tstyle = elem.style,\n\t\t\thidden = elem.nodeType && isHidden( elem ),\n\t\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\t\n\t\t// Handle queue: false promises\n\t\tif ( !opts.queue ) {\n\t\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\t\tif ( hooks.unqueued == null ) {\n\t\t\t\thooks.unqueued = 0;\n\t\t\t\toldfire = hooks.empty.fire;\n\t\t\t\thooks.empty.fire = function() {\n\t\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\t\toldfire();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\thooks.unqueued++;\n\t\n\t\t\tanim.always(function() {\n\t\t\t\t// Ensure the complete handler is called before this completes\n\t\t\t\tanim.always(function() {\n\t\t\t\t\thooks.unqueued--;\n\t\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\t\thooks.empty.fire();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\n\t\t// Height/width overflow pass\n\t\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t\t// Make sure that nothing sneaks out\n\t\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t\t// change the overflow attribute when overflowX and\n\t\t\t// overflowY are set to the same value\n\t\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\t\n\t\t\t// Set display property to inline-block for height/width\n\t\t\t// animations on inline elements that are having width/height animated\n\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\n\t\t\t// Test default display if display is currently \"none\"\n\t\t\tcheckDisplay = display === \"none\" ?\n\t\t\t\tdata_priv.get( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\t\n\t\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t\n\t\tif ( opts.overflow ) {\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tanim.always(function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t});\n\t\t}\n\t\n\t\t// show/hide pass\n\t\tfor ( prop in props ) {\n\t\t\tvalue = props[ prop ];\n\t\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\t\tdelete props[ prop ];\n\t\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\t\n\t\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\t\thidden = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\n\t\t\t// Any non-fx value stops us from restoring the original display value\n\t\t\t} else {\n\t\t\t\tdisplay = undefined;\n\t\t\t}\n\t\t}\n\t\n\t\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t\t}\n\t\n\t\t\t// Store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\t\t\tif ( hidden ) {\n\t\t\t\tjQuery( elem ).show();\n\t\t\t} else {\n\t\t\t\tanim.done(function() {\n\t\t\t\t\tjQuery( elem ).hide();\n\t\t\t\t});\n\t\t\t}\n\t\t\tanim.done(function() {\n\t\t\t\tvar prop;\n\t\n\t\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor ( prop in orig ) {\n\t\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\n\t\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\t\tif ( hidden ) {\n\t\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t\t} else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n\t\t\tstyle.display = display;\n\t\t}\n\t}\n\t\n\tfunction propFilter( props, specialEasing ) {\n\t\tvar index, name, easing, value, hooks;\n\t\n\t\t// camelCase, specialEasing and expand cssHook pass\n\t\tfor ( index in props ) {\n\t\t\tname = jQuery.camelCase( index );\n\t\t\teasing = specialEasing[ name ];\n\t\t\tvalue = props[ index ];\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\teasing = value[ 1 ];\n\t\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t\t}\n\t\n\t\t\tif ( index !== name ) {\n\t\t\t\tprops[ name ] = value;\n\t\t\t\tdelete props[ index ];\n\t\t\t}\n\t\n\t\t\thooks = jQuery.cssHooks[ name ];\n\t\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\t\tvalue = hooks.expand( value );\n\t\t\t\tdelete props[ name ];\n\t\n\t\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\t\tfor ( index in value ) {\n\t\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tspecialEasing[ name ] = easing;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction Animation( elem, properties, options ) {\n\t\tvar result,\n\t\t\tstopped,\n\t\t\tindex = 0,\n\t\t\tlength = animationPrefilters.length,\n\t\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t\t// Don't match elem in the :animated selector\n\t\t\t\tdelete tick.elem;\n\t\t\t}),\n\t\t\ttick = function() {\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t\t// Support: Android 2.3\n\t\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\t\tpercent = 1 - temp,\n\t\t\t\t\tindex = 0,\n\t\t\t\t\tlength = animation.tweens.length;\n\t\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t\t}\n\t\n\t\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\t\n\t\t\t\tif ( percent < 1 && length ) {\n\t\t\t\t\treturn remaining;\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation = deferred.promise({\n\t\t\t\telem: elem,\n\t\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\t\toriginalProperties: properties,\n\t\t\t\toriginalOptions: options,\n\t\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\t\tduration: options.duration,\n\t\t\t\ttweens: [],\n\t\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\t\treturn tween;\n\t\t\t\t},\n\t\t\t\tstop: function( gotoEnd ) {\n\t\t\t\t\tvar index = 0,\n\t\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\t\tif ( stopped ) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t\tstopped = true;\n\t\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}),\n\t\t\tprops = animation.props;\n\t\n\t\tpropFilter( props, animation.opts.specialEasing );\n\t\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\t\tif ( result ) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\n\t\tjQuery.map( props, createTween, animation );\n\t\n\t\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\t\tanimation.opts.start.call( elem, animation );\n\t\t}\n\t\n\t\tjQuery.fx.timer(\n\t\t\tjQuery.extend( tick, {\n\t\t\t\telem: elem,\n\t\t\t\tanim: animation,\n\t\t\t\tqueue: animation.opts.queue\n\t\t\t})\n\t\t);\n\t\n\t\t// attach callbacks from options\n\t\treturn animation.progress( animation.opts.progress )\n\t\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t\t.fail( animation.opts.fail )\n\t\t\t.always( animation.opts.always );\n\t}\n\t\n\tjQuery.Animation = jQuery.extend( Animation, {\n\t\n\t\ttweener: function( props, callback ) {\n\t\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\t\tcallback = props;\n\t\t\t\tprops = [ \"*\" ];\n\t\t\t} else {\n\t\t\t\tprops = props.split(\" \");\n\t\t\t}\n\t\n\t\t\tvar prop,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = props.length;\n\t\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tprop = props[ index ];\n\t\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\t\ttweeners[ prop ].unshift( callback );\n\t\t\t}\n\t\t},\n\t\n\t\tprefilter: function( callback, prepend ) {\n\t\t\tif ( prepend ) {\n\t\t\t\tanimationPrefilters.unshift( callback );\n\t\t\t} else {\n\t\t\t\tanimationPrefilters.push( callback );\n\t\t\t}\n\t\t}\n\t});\n\t\n\tjQuery.speed = function( speed, easing, fn ) {\n\t\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\t\tcomplete: fn || !fn && easing ||\n\t\t\t\tjQuery.isFunction( speed ) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t\t};\n\t\n\t\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\t\n\t\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\t\tif ( opt.queue == null || opt.queue === true ) {\n\t\t\topt.queue = \"fx\";\n\t\t}\n\t\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\t\n\t\topt.complete = function() {\n\t\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\t\topt.old.call( this );\n\t\t\t}\n\t\n\t\t\tif ( opt.queue ) {\n\t\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t\t}\n\t\t};\n\t\n\t\treturn opt;\n\t};\n\t\n\tjQuery.fn.extend({\n\t\tfadeTo: function( speed, to, easing, callback ) {\n\t\n\t\t\t// Show any hidden elements after setting opacity to 0\n\t\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\t\n\t\t\t\t// Animate to the value specified\n\t\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t\t},\n\t\tanimate: function( prop, speed, easing, callback ) {\n\t\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\t\tdoAnimation = function() {\n\t\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\t\n\t\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\t\tanim.stop( true );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tdoAnimation.finish = doAnimation;\n\t\n\t\t\treturn empty || optall.queue === false ?\n\t\t\t\tthis.each( doAnimation ) :\n\t\t\t\tthis.queue( optall.queue, doAnimation );\n\t\t},\n\t\tstop: function( type, clearQueue, gotoEnd ) {\n\t\t\tvar stopQueue = function( hooks ) {\n\t\t\t\tvar stop = hooks.stop;\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tstop( gotoEnd );\n\t\t\t};\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tgotoEnd = clearQueue;\n\t\t\t\tclearQueue = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tif ( clearQueue && type !== false ) {\n\t\t\t\tthis.queue( type || \"fx\", [] );\n\t\t\t}\n\t\n\t\t\treturn this.each(function() {\n\t\t\t\tvar dequeue = true,\n\t\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tdata = data_priv.get( this );\n\t\n\t\t\t\tif ( index ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( index in data ) {\n\t\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\t\tdequeue = false;\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tfinish: function( type ) {\n\t\t\tif ( type !== false ) {\n\t\t\t\ttype = type || \"fx\";\n\t\t\t}\n\t\t\treturn this.each(function() {\n\t\t\t\tvar index,\n\t\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tlength = queue ? queue.length : 0;\n\t\n\t\t\t\t// Enable finishing flag on private data\n\t\t\t\tdata.finish = true;\n\t\n\t\t\t\t// Empty the queue first\n\t\t\t\tjQuery.queue( this, type, [] );\n\t\n\t\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\t\thooks.stop.call( this, true );\n\t\t\t\t}\n\t\n\t\t\t\t// Look for any active animations, and finish them\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Look for any animations in the old queue and finish them\n\t\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Turn off finishing flag\n\t\t\t\tdelete data.finish;\n\t\t\t});\n\t\t}\n\t});\n\t\n\tjQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\t\tvar cssFn = jQuery.fn[ name ];\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\t\tcssFn.apply( this, arguments ) :\n\t\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t\t};\n\t});\n\t\n\t// Generate shortcuts for custom animations\n\tjQuery.each({\n\t\tslideDown: genFx(\"show\"),\n\t\tslideUp: genFx(\"hide\"),\n\t\tslideToggle: genFx(\"toggle\"),\n\t\tfadeIn: { opacity: \"show\" },\n\t\tfadeOut: { opacity: \"hide\" },\n\t\tfadeToggle: { opacity: \"toggle\" }\n\t}, function( name, props ) {\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn this.animate( props, speed, easing, callback );\n\t\t};\n\t});\n\t\n\tjQuery.timers = [];\n\tjQuery.fx.tick = function() {\n\t\tvar timer,\n\t\t\ti = 0,\n\t\t\ttimers = jQuery.timers;\n\t\n\t\tfxNow = jQuery.now();\n\t\n\t\tfor ( ; i < timers.length; i++ ) {\n\t\t\ttimer = timers[ i ];\n\t\t\t// Checks the timer has not already been removed\n\t\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\t\ttimers.splice( i--, 1 );\n\t\t\t}\n\t\t}\n\t\n\t\tif ( !timers.length ) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t\tfxNow = undefined;\n\t};\n\t\n\tjQuery.fx.timer = function( timer ) {\n\t\tjQuery.timers.push( timer );\n\t\tif ( timer() ) {\n\t\t\tjQuery.fx.start();\n\t\t} else {\n\t\t\tjQuery.timers.pop();\n\t\t}\n\t};\n\t\n\tjQuery.fx.interval = 13;\n\t\n\tjQuery.fx.start = function() {\n\t\tif ( !timerId ) {\n\t\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t\t}\n\t};\n\t\n\tjQuery.fx.stop = function() {\n\t\tclearInterval( timerId );\n\t\ttimerId = null;\n\t};\n\t\n\tjQuery.fx.speeds = {\n\t\tslow: 600,\n\t\tfast: 200,\n\t\t// Default speed\n\t\t_default: 400\n\t};\n\t\n\t\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tjQuery.fn.delay = function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\t\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\tclearTimeout( timeout );\n\t\t\t};\n\t\t});\n\t};\n\t\n\t\n\t(function() {\n\t\tvar input = document.createElement( \"input\" ),\n\t\t\tselect = document.createElement( \"select\" ),\n\t\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\t\n\t\tinput.type = \"checkbox\";\n\t\n\t\t// Support: iOS<=5.1, Android<=4.2+\n\t\t// Default value for a checkbox should be \"on\"\n\t\tsupport.checkOn = input.value !== \"\";\n\t\n\t\t// Support: IE<=11+\n\t\t// Must access selectedIndex to make default options select\n\t\tsupport.optSelected = opt.selected;\n\t\n\t\t// Support: Android<=2.3\n\t\t// Options inside disabled selects are incorrectly marked as disabled\n\t\tselect.disabled = true;\n\t\tsupport.optDisabled = !opt.disabled;\n\t\n\t\t// Support: IE<=11+\n\t\t// An input loses its value after becoming a radio\n\t\tinput = document.createElement( \"input\" );\n\t\tinput.value = \"t\";\n\t\tinput.type = \"radio\";\n\t\tsupport.radioValue = input.value === \"t\";\n\t})();\n\t\n\t\n\tvar nodeHook, boolHook,\n\t\tattrHandle = jQuery.expr.attrHandle;\n\t\n\tjQuery.fn.extend({\n\t\tattr: function( name, value ) {\n\t\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t\t},\n\t\n\t\tremoveAttr: function( name ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.removeAttr( this, name );\n\t\t\t});\n\t\t}\n\t});\n\t\n\tjQuery.extend({\n\t\tattr: function( elem, name, value ) {\n\t\t\tvar hooks, ret,\n\t\t\t\tnType = elem.nodeType;\n\t\n\t\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Fallback to prop when attributes are not supported\n\t\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\t\treturn jQuery.prop( elem, name, value );\n\t\t\t}\n\t\n\t\t\t// All attributes are lowercase\n\t\t\t// Grab necessary hook if one is defined\n\t\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\t\tname = name.toLowerCase();\n\t\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t\t}\n\t\n\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\tif ( value === null ) {\n\t\t\t\t\tjQuery.removeAttr( elem, name );\n\t\n\t\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\n\t\t\t\t} else {\n\t\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\n\t\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\t\treturn ret;\n\t\n\t\t\t} else {\n\t\t\t\tret = jQuery.find.attr( elem, name );\n\t\n\t\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\t\treturn ret == null ?\n\t\t\t\t\tundefined :\n\t\t\t\t\tret;\n\t\t\t}\n\t\t},\n\t\n\t\tremoveAttr: function( elem, value ) {\n\t\t\tvar name, propName,\n\t\t\t\ti = 0,\n\t\t\t\tattrNames = value && value.match( rnotwhite );\n\t\n\t\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\t\n\t\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t}\n\t\n\t\t\t\t\telem.removeAttribute( name );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tattrHooks: {\n\t\t\ttype: {\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\t// Hooks for boolean attributes\n\tboolHook = {\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( value === false ) {\n\t\t\t\t// Remove boolean attributes when set to false\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, name );\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\t};\n\tjQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\t\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\t\n\t\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\t\tvar ret, handle;\n\t\t\tif ( !isXML ) {\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[ name ];\n\t\t\t\tattrHandle[ name ] = ret;\n\t\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\tnull;\n\t\t\t\tattrHandle[ name ] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t});\n\t\n\t\n\t\n\t\n\tvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\t\n\tjQuery.fn.extend({\n\t\tprop: function( name, value ) {\n\t\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t\t},\n\t\n\t\tremoveProp: function( name ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t\t});\n\t\t}\n\t});\n\t\n\tjQuery.extend({\n\t\tpropFix: {\n\t\t\t\"for\": \"htmlFor\",\n\t\t\t\"class\": \"className\"\n\t\t},\n\t\n\t\tprop: function( elem, name, value ) {\n\t\t\tvar ret, hooks, notxml,\n\t\t\t\tnType = elem.nodeType;\n\t\n\t\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\t\n\t\t\tif ( notxml ) {\n\t\t\t\t// Fix name and attach hooks\n\t\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\t\thooks = jQuery.propHooks[ name ];\n\t\t\t}\n\t\n\t\t\tif ( value !== undefined ) {\n\t\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\t\tret :\n\t\t\t\t\t( elem[ name ] = value );\n\t\n\t\t\t} else {\n\t\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\t\tret :\n\t\t\t\t\telem[ name ];\n\t\t\t}\n\t\t},\n\t\n\t\tpropHooks: {\n\t\t\ttabIndex: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t\t-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\tif ( !support.optSelected ) {\n\t\tjQuery.propHooks.selected = {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tjQuery.each([\n\t\t\"tabIndex\",\n\t\t\"readOnly\",\n\t\t\"maxLength\",\n\t\t\"cellSpacing\",\n\t\t\"cellPadding\",\n\t\t\"rowSpan\",\n\t\t\"colSpan\",\n\t\t\"useMap\",\n\t\t\"frameBorder\",\n\t\t\"contentEditable\"\n\t], function() {\n\t\tjQuery.propFix[ this.toLowerCase() ] = this;\n\t});\n\t\n\t\n\t\n\t\n\tvar rclass = /[\\t\\r\\n\\f]/g;\n\t\n\tjQuery.fn.extend({\n\t\taddClass: function( value ) {\n\t\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\t\tproceed = typeof value === \"string\" && value,\n\t\t\t\ti = 0,\n\t\t\t\tlen = this.length;\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each(function( j ) {\n\t\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tif ( proceed ) {\n\t\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\t\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\telem = this[ i ];\n\t\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\t\" \"\n\t\t\t\t\t);\n\t\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tremoveClass: function( value ) {\n\t\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value,\n\t\t\t\ti = 0,\n\t\t\t\tlen = this.length;\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each(function( j ) {\n\t\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t\t});\n\t\t\t}\n\t\t\tif ( proceed ) {\n\t\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\t\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\telem = this[ i ];\n\t\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\t\"\"\n\t\t\t\t\t);\n\t\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\ttoggleClass: function( value, stateVal ) {\n\t\t\tvar type = typeof value;\n\t\n\t\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t\t}\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each(function( i ) {\n\t\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\treturn this.each(function() {\n\t\t\t\tif ( type === \"string\" ) {\n\t\t\t\t\t// Toggle individual class names\n\t\t\t\t\tvar className,\n\t\t\t\t\t\ti = 0,\n\t\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\t\n\t\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t// Toggle whole class name\n\t\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\t\tif ( this.className ) {\n\t\t\t\t\t\t// store className if set\n\t\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\n\t\thasClass: function( selector ) {\n\t\t\tvar className = \" \" + selector + \" \",\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t}\n\t});\n\t\n\t\n\t\n\t\n\tvar rreturn = /\\r/g;\n\t\n\tjQuery.fn.extend({\n\t\tval: function( value ) {\n\t\t\tvar hooks, ret, isFunction,\n\t\t\t\telem = this[0];\n\t\n\t\t\tif ( !arguments.length ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\t\n\t\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tret = elem.value;\n\t\n\t\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t\t}\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tisFunction = jQuery.isFunction( value );\n\t\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tvar val;\n\t\n\t\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t\t} else {\n\t\t\t\t\tval = value;\n\t\t\t\t}\n\t\n\t\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\t\tif ( val == null ) {\n\t\t\t\t\tval = \"\";\n\t\n\t\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\t\tval += \"\";\n\t\n\t\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\t\n\t\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\t\tthis.value = val;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\t\n\tjQuery.extend({\n\t\tvalHooks: {\n\t\t\toption: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\t\treturn val != null ?\n\t\t\t\t\t\tval :\n\t\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t\tjQuery.trim( jQuery.text( elem ) );\n\t\t\t\t}\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\tvar value, option,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\t\tmax :\n\t\t\t\t\t\t\tone ? index : 0;\n\t\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\n\t\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute( \"disabled\" ) === null ) &&\n\t\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\t\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery( option ).val();\n\t\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\t\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tvar optionSet, option,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\t\ti = options.length;\n\t\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\t\t\t\t\tif ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {\n\t\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\t// Radios and checkboxes getter/setter\n\tjQuery.each([ \"radio\", \"checkbox\" ], function() {\n\t\tjQuery.valHooks[ this ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif ( !support.checkOn ) {\n\t\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t\t};\n\t\t}\n\t});\n\t\n\t\n\t\n\t\n\t// Return jQuery for attributes-only inclusion\n\t\n\t\n\tjQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\t\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t});\n\t\n\tjQuery.fn.extend({\n\t\thover: function( fnOver, fnOut ) {\n\t\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t\t},\n\t\n\t\tbind: function( types, data, fn ) {\n\t\t\treturn this.on( types, null, data, fn );\n\t\t},\n\t\tunbind: function( types, fn ) {\n\t\t\treturn this.off( types, null, fn );\n\t\t},\n\t\n\t\tdelegate: function( selector, types, data, fn ) {\n\t\t\treturn this.on( types, selector, data, fn );\n\t\t},\n\t\tundelegate: function( selector, types, fn ) {\n\t\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t\t}\n\t});\n\t\n\t\n\tvar nonce = jQuery.now();\n\t\n\tvar rquery = (/\\?/);\n\t\n\t\n\t\n\t// Support: Android 2.3\n\t// Workaround failure to string-cast null input\n\tjQuery.parseJSON = function( data ) {\n\t\treturn JSON.parse( data + \"\" );\n\t};\n\t\n\t\n\t// Cross-browser xml parsing\n\tjQuery.parseXML = function( data ) {\n\t\tvar xml, tmp;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\t// Support: IE9\n\t\ttry {\n\t\t\ttmp = new DOMParser();\n\t\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t\t} catch ( e ) {\n\t\t\txml = undefined;\n\t\t}\n\t\n\t\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t};\n\t\n\t\n\tvar\n\t\trhash = /#.*$/,\n\t\trts = /([?&])_=[^&]*/,\n\t\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t\t// #7653, #8125, #8152: local protocol detection\n\t\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t\trnoContent = /^(?:GET|HEAD)$/,\n\t\trprotocol = /^\\/\\//,\n\t\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\t\n\t\t/* Prefilters\n\t\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t\t * 2) These are called:\n\t\t *    - BEFORE asking for a transport\n\t\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t\t * 3) key is the dataType\n\t\t * 4) the catchall symbol \"*\" can be used\n\t\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t\t */\n\t\tprefilters = {},\n\t\n\t\t/* Transports bindings\n\t\t * 1) key is the dataType\n\t\t * 2) the catchall symbol \"*\" can be used\n\t\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t\t */\n\t\ttransports = {},\n\t\n\t\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\t\tallTypes = \"*/\".concat( \"*\" ),\n\t\n\t\t// Document location\n\t\tajaxLocation = window.location.href,\n\t\n\t\t// Segment location into parts\n\t\tajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\t\n\t// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\tfunction addToPrefiltersOrTransports( structure ) {\n\t\n\t\t// dataTypeExpression is optional and defaults to \"*\"\n\t\treturn function( dataTypeExpression, func ) {\n\t\n\t\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = \"*\";\n\t\t\t}\n\t\n\t\t\tvar dataType,\n\t\t\t\ti = 0,\n\t\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\t\n\t\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\t\n\t\t\t\t\t// Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\t// Base inspection function for prefilters and transports\n\tfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\t\n\t\tvar inspected = {},\n\t\t\tseekingTransport = ( structure === transports );\n\t\n\t\tfunction inspect( dataType ) {\n\t\t\tvar selected;\n\t\t\tinspected[ dataType ] = true;\n\t\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\t\treturn false;\n\t\t\t\t} else if ( seekingTransport ) {\n\t\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn selected;\n\t\t}\n\t\n\t\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n\t}\n\t\n\t// A special extend for ajax options\n\t// that takes \"flat\" options (not to be deep extended)\n\t// Fixes #9887\n\tfunction ajaxExtend( target, src ) {\n\t\tvar key, deep,\n\t\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\t\n\t\tfor ( key in src ) {\n\t\t\tif ( src[ key ] !== undefined ) {\n\t\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t\t}\n\t\t}\n\t\tif ( deep ) {\n\t\t\tjQuery.extend( true, target, deep );\n\t\t}\n\t\n\t\treturn target;\n\t}\n\t\n\t/* Handles responses to an ajax request:\n\t * - finds the right dataType (mediates between content-type and expected dataType)\n\t * - returns the corresponding response\n\t */\n\tfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\t\n\t\tvar ct, type, finalDataType, firstDataType,\n\t\t\tcontents = s.contents,\n\t\t\tdataTypes = s.dataTypes;\n\t\n\t\t// Remove auto dataType and get content-type in the process\n\t\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\t\tdataTypes.shift();\n\t\t\tif ( ct === undefined ) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t\t}\n\t\t}\n\t\n\t\t// Check if we're dealing with a known content-type\n\t\tif ( ct ) {\n\t\t\tfor ( type in contents ) {\n\t\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\t\tdataTypes.unshift( type );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Check to see if we have a response for the expected dataType\n\t\tif ( dataTypes[ 0 ] in responses ) {\n\t\t\tfinalDataType = dataTypes[ 0 ];\n\t\t} else {\n\t\t\t// Try convertible dataTypes\n\t\t\tfor ( type in responses ) {\n\t\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( !firstDataType ) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Or just use first one\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t}\n\t\n\t\t// If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\t\tif ( finalDataType ) {\n\t\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\t\tdataTypes.unshift( finalDataType );\n\t\t\t}\n\t\t\treturn responses[ finalDataType ];\n\t\t}\n\t}\n\t\n\t/* Chain conversions given the request and the original response\n\t * Also sets the responseXXX fields on the jqXHR instance\n\t */\n\tfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\t\tvar conv2, current, conv, tmp, prev,\n\t\t\tconverters = {},\n\t\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\t\tdataTypes = s.dataTypes.slice();\n\t\n\t\t// Create converters map with lowercased keys\n\t\tif ( dataTypes[ 1 ] ) {\n\t\t\tfor ( conv in s.converters ) {\n\t\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t\t}\n\t\t}\n\t\n\t\tcurrent = dataTypes.shift();\n\t\n\t\t// Convert to each sequential dataType\n\t\twhile ( current ) {\n\t\n\t\t\tif ( s.responseFields[ current ] ) {\n\t\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t\t}\n\t\n\t\t\t// Apply the dataFilter if provided\n\t\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t\t}\n\t\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\t\n\t\t\tif ( current ) {\n\t\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\t\tif ( current === \"*\" ) {\n\t\n\t\t\t\t\tcurrent = prev;\n\t\n\t\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\t\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\t\n\t\t\t\t\t// If none found, seek a pair\n\t\t\t\t\tif ( !conv ) {\n\t\t\t\t\t\tfor ( conv2 in converters ) {\n\t\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\t\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\t\n\t\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\t\tif ( conv !== true ) {\n\t\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn { state: \"success\", data: response };\n\t}\n\t\n\tjQuery.extend({\n\t\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\t\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\t\n\t\tajaxSettings: {\n\t\t\turl: ajaxLocation,\n\t\t\ttype: \"GET\",\n\t\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t\t/*\n\t\t\ttimeout: 0,\n\t\t\tdata: null,\n\t\t\tdataType: null,\n\t\t\tusername: null,\n\t\t\tpassword: null,\n\t\t\tcache: null,\n\t\t\tthrows: false,\n\t\t\ttraditional: false,\n\t\t\theaders: {},\n\t\t\t*/\n\t\n\t\t\taccepts: {\n\t\t\t\t\"*\": allTypes,\n\t\t\t\ttext: \"text/plain\",\n\t\t\t\thtml: \"text/html\",\n\t\t\t\txml: \"application/xml, text/xml\",\n\t\t\t\tjson: \"application/json, text/javascript\"\n\t\t\t},\n\t\n\t\t\tcontents: {\n\t\t\t\txml: /xml/,\n\t\t\t\thtml: /html/,\n\t\t\t\tjson: /json/\n\t\t\t},\n\t\n\t\t\tresponseFields: {\n\t\t\t\txml: \"responseXML\",\n\t\t\t\ttext: \"responseText\",\n\t\t\t\tjson: \"responseJSON\"\n\t\t\t},\n\t\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\t\tconverters: {\n\t\n\t\t\t\t// Convert anything to text\n\t\t\t\t\"* text\": String,\n\t\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t\"text html\": true,\n\t\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t\"text json\": jQuery.parseJSON,\n\t\n\t\t\t\t// Parse text as xml\n\t\t\t\t\"text xml\": jQuery.parseXML\n\t\t\t},\n\t\n\t\t\t// For options that shouldn't be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn't be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\t\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function( target, settings ) {\n\t\t\treturn settings ?\n\t\n\t\t\t\t// Building a settings object\n\t\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\t\n\t\t\t\t// Extending ajaxSettings\n\t\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t\t},\n\t\n\t\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\t\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\t\n\t\t// Main method\n\t\tajax: function( url, options ) {\n\t\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ( typeof url === \"object\" ) {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t}\n\t\n\t\t\t// Force options to be an object\n\t\t\toptions = options || {};\n\t\n\t\t\tvar transport,\n\t\t\t\t// URL without anti-cache param\n\t\t\t\tcacheURL,\n\t\t\t\t// Response headers\n\t\t\t\tresponseHeadersString,\n\t\t\t\tresponseHeaders,\n\t\t\t\t// timeout handle\n\t\t\t\ttimeoutTimer,\n\t\t\t\t// Cross-domain detection vars\n\t\t\t\tparts,\n\t\t\t\t// To know if global events are to be dispatched\n\t\t\t\tfireGlobals,\n\t\t\t\t// Loop variable\n\t\t\t\ti,\n\t\t\t\t// Create the final options object\n\t\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t\t// Callbacks context\n\t\t\t\tcallbackContext = s.context || s,\n\t\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\t\t\t\t// Deferreds\n\t\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode = s.statusCode || {},\n\t\t\t\t// Headers (they are sent all at once)\n\t\t\t\trequestHeaders = {},\n\t\t\t\trequestHeadersNames = {},\n\t\t\t\t// The jqXHR state\n\t\t\t\tstate = 0,\n\t\t\t\t// Default abort message\n\t\t\t\tstrAbort = \"canceled\",\n\t\t\t\t// Fake xhr\n\t\t\t\tjqXHR = {\n\t\t\t\t\treadyState: 0,\n\t\n\t\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\t\tvar match;\n\t\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Raw string\n\t\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Caches the header\n\t\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Overrides response content-type header\n\t\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Status-dependent callbacks\n\t\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\t\tvar code;\n\t\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Cancel the request\n\t\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t// Attach deferreds\n\t\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\t\tjqXHR.success = jqXHR.done;\n\t\t\tjqXHR.error = jqXHR.fail;\n\t\n\t\t\t// Remove hash character (#7531: and string promotion)\n\t\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\t\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\t\n\t\t\t// Alias method option to type as per ticket #12004\n\t\t\ts.type = options.method || options.type || s.method || s.type;\n\t\n\t\t\t// Extract dataTypes list\n\t\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\t\n\t\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\t\tif ( s.crossDomain == null ) {\n\t\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t\t);\n\t\t\t}\n\t\n\t\t\t// Convert data if not already a string\n\t\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t\t}\n\t\n\t\t\t// Apply prefilters\n\t\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\t\n\t\t\t// If request was aborted inside a prefilter, stop there\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\t\n\t\t\t// We can fire global events as of now if asked to\n\t\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\t\tfireGlobals = jQuery.event && s.global;\n\t\n\t\t\t// Watch for a new set of requests\n\t\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t\t}\n\t\n\t\t\t// Uppercase the type\n\t\t\ts.type = s.type.toUpperCase();\n\t\n\t\t\t// Determine if request has content\n\t\t\ts.hasContent = !rnoContent.test( s.type );\n\t\n\t\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\t\t\tcacheURL = s.url;\n\t\n\t\t\t// More options handling for requests with no content\n\t\t\tif ( !s.hasContent ) {\n\t\n\t\t\t\t// If data is available, append data to url\n\t\t\t\tif ( s.data ) {\n\t\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\t\tdelete s.data;\n\t\t\t\t}\n\t\n\t\t\t\t// Add anti-cache in url if needed\n\t\t\t\tif ( s.cache === false ) {\n\t\t\t\t\ts.url = rts.test( cacheURL ) ?\n\t\n\t\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\t\n\t\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif ( s.ifModified ) {\n\t\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t\t}\n\t\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t\t}\n\t\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\tjqXHR.setRequestHeader(\n\t\t\t\t\"Accept\",\n\t\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\t\ts.accepts[ \"*\" ]\n\t\t\t);\n\t\n\t\t\t// Check for headers option\n\t\t\tfor ( i in s.headers ) {\n\t\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t\t}\n\t\n\t\t\t// Allow custom headers/mimetypes and early abort\n\t\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t}\n\t\n\t\t\t// Aborting is no longer a cancellation\n\t\t\tstrAbort = \"abort\";\n\t\n\t\t\t// Install callbacks on deferreds\n\t\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t\t}\n\t\n\t\t\t// Get transport\n\t\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\t\n\t\t\t// If no transport, we auto-abort\n\t\t\tif ( !transport ) {\n\t\t\t\tdone( -1, \"No Transport\" );\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1;\n\t\n\t\t\t\t// Send global event\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t\t}\n\t\t\t\t// Timeout\n\t\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t\t}, s.timeout );\n\t\t\t\t}\n\t\n\t\t\t\ttry {\n\t\t\t\t\tstate = 1;\n\t\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\t// Propagate exception as error if not done\n\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\tdone( -1, e );\n\t\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Callback for when everything is done\n\t\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\t\tstatusText = nativeStatusText;\n\t\n\t\t\t\t// Called once\n\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// State is \"done\" now\n\t\t\t\tstate = 2;\n\t\n\t\t\t\t// Clear timeout if it exists\n\t\t\t\tif ( timeoutTimer ) {\n\t\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t\t}\n\t\n\t\t\t\t// Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\t\ttransport = undefined;\n\t\n\t\t\t\t// Cache response headers\n\t\t\t\tresponseHeadersString = headers || \"\";\n\t\n\t\t\t\t// Set readyState\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\t\n\t\t\t\t// Determine if successful\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\t\n\t\t\t\t// Get response data\n\t\t\t\tif ( responses ) {\n\t\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t\t}\n\t\n\t\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\t\n\t\t\t\t// If successful, handle type chaining\n\t\t\t\tif ( isSuccess ) {\n\t\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// if no content\n\t\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\t\tstatusText = \"nocontent\";\n\t\n\t\t\t\t\t// if not modified\n\t\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\t\tstatusText = \"notmodified\";\n\t\n\t\t\t\t\t// If we have data, let's convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\t\terror = statusText;\n\t\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Set data for the fake xhr object\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\t\n\t\t\t\t// Success/Error\n\t\t\t\tif ( isSuccess ) {\n\t\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t\t}\n\t\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tjqXHR.statusCode( statusCode );\n\t\t\t\tstatusCode = undefined;\n\t\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t\t}\n\t\n\t\t\t\t// Complete\n\t\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\t\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn jqXHR;\n\t\t},\n\t\n\t\tgetJSON: function( url, data, callback ) {\n\t\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t\t},\n\t\n\t\tgetScript: function( url, callback ) {\n\t\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t\t}\n\t});\n\t\n\tjQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\t\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t\t// Shift arguments if data argument was omitted\n\t\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\n\t\t\treturn jQuery.ajax({\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t});\n\t\t};\n\t});\n\t\n\t\n\tjQuery._evalUrl = function( url ) {\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t});\n\t};\n\t\n\t\n\tjQuery.fn.extend({\n\t\twrapAll: function( html ) {\n\t\t\tvar wrap;\n\t\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\treturn this.each(function( i ) {\n\t\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tif ( this[ 0 ] ) {\n\t\n\t\t\t\t// The elements to wrap the target around\n\t\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\t\n\t\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\twrap.map(function() {\n\t\t\t\t\tvar elem = this;\n\t\n\t\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn elem;\n\t\t\t\t}).append( this );\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\twrapInner: function( html ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\treturn this.each(function( i ) {\n\t\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\treturn this.each(function() {\n\t\t\t\tvar self = jQuery( this ),\n\t\t\t\t\tcontents = self.contents();\n\t\n\t\t\t\tif ( contents.length ) {\n\t\t\t\t\tcontents.wrapAll( html );\n\t\n\t\t\t\t} else {\n\t\t\t\t\tself.append( html );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\n\t\twrap: function( html ) {\n\t\t\tvar isFunction = jQuery.isFunction( html );\n\t\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t\t});\n\t\t},\n\t\n\t\tunwrap: function() {\n\t\t\treturn this.parent().each(function() {\n\t\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t\t}\n\t\t\t}).end();\n\t\t}\n\t});\n\t\n\t\n\tjQuery.expr.filters.hidden = function( elem ) {\n\t\t// Support: Opera <= 12.12\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n\t};\n\tjQuery.expr.filters.visible = function( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t};\n\t\n\t\n\t\n\t\n\tvar r20 = /%20/g,\n\t\trbracket = /\\[\\]$/,\n\t\trCRLF = /\\r?\\n/g,\n\t\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\t\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\t\n\tfunction buildParams( prefix, obj, traditional, add ) {\n\t\tvar name;\n\t\n\t\tif ( jQuery.isArray( obj ) ) {\n\t\t\t// Serialize array item.\n\t\t\tjQuery.each( obj, function( i, v ) {\n\t\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\tadd( prefix, v );\n\t\n\t\t\t\t} else {\n\t\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t\t// Serialize object item.\n\t\t\tfor ( name in obj ) {\n\t\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t\t}\n\t\n\t\t} else {\n\t\t\t// Serialize scalar item.\n\t\t\tadd( prefix, obj );\n\t\t}\n\t}\n\t\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tjQuery.param = function( a, traditional ) {\n\t\tvar prefix,\n\t\t\ts = [],\n\t\t\tadd = function( key, value ) {\n\t\t\t\t// If value is a function, invoke it and return its value\n\t\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t\t};\n\t\n\t\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\t\tif ( traditional === undefined ) {\n\t\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t\t}\n\t\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each( a, function() {\n\t\t\t\tadd( this.name, this.value );\n\t\t\t});\n\t\n\t\t} else {\n\t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor ( prefix in a ) {\n\t\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the resulting serialization\n\t\treturn s.join( \"&\" ).replace( r20, \"+\" );\n\t};\n\t\n\tjQuery.fn.extend({\n\t\tserialize: function() {\n\t\t\treturn jQuery.param( this.serializeArray() );\n\t\t},\n\t\tserializeArray: function() {\n\t\t\treturn this.map(function() {\n\t\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t\t})\n\t\t\t.filter(function() {\n\t\t\t\tvar type = this.type;\n\t\n\t\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t\t})\n\t\t\t.map(function( i, elem ) {\n\t\t\t\tvar val = jQuery( this ).val();\n\t\n\t\t\t\treturn val == null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t}).get();\n\t\t}\n\t});\n\t\n\t\n\tjQuery.ajaxSettings.xhr = function() {\n\t\ttry {\n\t\t\treturn new XMLHttpRequest();\n\t\t} catch( e ) {}\n\t};\n\t\n\tvar xhrId = 0,\n\t\txhrCallbacks = {},\n\t\txhrSuccessStatus = {\n\t\t\t// file protocol always yields status code 0, assume 200\n\t\t\t0: 200,\n\t\t\t// Support: IE9\n\t\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t\t1223: 204\n\t\t},\n\t\txhrSupported = jQuery.ajaxSettings.xhr();\n\t\n\t// Support: IE9\n\t// Open requests must be manually aborted on unload (#5280)\n\t// See https://support.microsoft.com/kb/2856746 for more info\n\tif ( window.attachEvent ) {\n\t\twindow.attachEvent( \"onunload\", function() {\n\t\t\tfor ( var key in xhrCallbacks ) {\n\t\t\t\txhrCallbacks[ key ]();\n\t\t\t}\n\t\t});\n\t}\n\t\n\tsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n\tsupport.ajax = xhrSupported = !!xhrSupported;\n\t\n\tjQuery.ajaxTransport(function( options ) {\n\t\tvar callback;\n\t\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\t\tid = ++xhrId;\n\t\n\t\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\t\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Callback\n\t\t\t\t\tcallback = function( type ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\t\n\t\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t\t// file: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// Listen to events\n\t\t\t\t\txhr.onload = callback();\n\t\t\t\t\txhr.onerror = callback(\"error\");\n\t\n\t\t\t\t\t// Create the abort callback\n\t\t\t\t\tcallback = xhrCallbacks[ id ] = callback(\"abort\");\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\t\n\t\n\t\n\t\n\t// Install script dataType\n\tjQuery.ajaxSetup({\n\t\taccepts: {\n\t\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t\t},\n\t\tcontents: {\n\t\t\tscript: /(?:java|ecma)script/\n\t\t},\n\t\tconverters: {\n\t\t\t\"text script\": function( text ) {\n\t\t\t\tjQuery.globalEval( text );\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t});\n\t\n\t// Handle cache's special case and crossDomain\n\tjQuery.ajaxPrefilter( \"script\", function( s ) {\n\t\tif ( s.cache === undefined ) {\n\t\t\ts.cache = false;\n\t\t}\n\t\tif ( s.crossDomain ) {\n\t\t\ts.type = \"GET\";\n\t\t}\n\t});\n\t\n\t// Bind script tag hack transport\n\tjQuery.ajaxTransport( \"script\", function( s ) {\n\t\t// This transport only deals with cross domain requests\n\t\tif ( s.crossDomain ) {\n\t\t\tvar script, callback;\n\t\t\treturn {\n\t\t\t\tsend: function( _, complete ) {\n\t\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\t\tasync: true,\n\t\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\t\tsrc: s.url\n\t\t\t\t\t}).on(\n\t\t\t\t\t\t\"load error\",\n\t\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t\t},\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\t\n\t\n\t\n\t\n\tvar oldCallbacks = [],\n\t\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\t\n\t// Default jsonp settings\n\tjQuery.ajaxSetup({\n\t\tjsonp: \"callback\",\n\t\tjsonpCallback: function() {\n\t\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\t\tthis[ callback ] = true;\n\t\t\treturn callback;\n\t\t}\n\t});\n\t\n\t// Detect, normalize options and install callbacks for jsonp requests\n\tjQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\t\n\t\tvar callbackName, overwritten, responseContainer,\n\t\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\t\"url\" :\n\t\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t\t);\n\t\n\t\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\t\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\t\n\t\t\t// Get callback name, remembering preexisting value associated with it\n\t\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\t\ts.jsonpCallback() :\n\t\t\t\ts.jsonpCallback;\n\t\n\t\t\t// Insert callback into url or form data\n\t\t\tif ( jsonProp ) {\n\t\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t\t} else if ( s.jsonp !== false ) {\n\t\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t\t}\n\t\n\t\t\t// Use data converter to retrieve json after script execution\n\t\t\ts.converters[\"script json\"] = function() {\n\t\t\t\tif ( !responseContainer ) {\n\t\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t\t}\n\t\t\t\treturn responseContainer[ 0 ];\n\t\t\t};\n\t\n\t\t\t// force json dataType\n\t\t\ts.dataTypes[ 0 ] = \"json\";\n\t\n\t\t\t// Install callback\n\t\t\toverwritten = window[ callbackName ];\n\t\t\twindow[ callbackName ] = function() {\n\t\t\t\tresponseContainer = arguments;\n\t\t\t};\n\t\n\t\t\t// Clean-up function (fires after converters)\n\t\t\tjqXHR.always(function() {\n\t\t\t\t// Restore preexisting value\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\n\t\t\t\t// Save back as free\n\t\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\t\n\t\t\t\t\t// save the callback name for future use\n\t\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t\t}\n\t\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\tresponseContainer = overwritten = undefined;\n\t\t\t});\n\t\n\t\t\t// Delegate to script\n\t\t\treturn \"script\";\n\t\t}\n\t});\n\t\n\t\n\t\n\t\n\t// data: string of html\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tjQuery.parseHTML = function( data, context, keepScripts ) {\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\tcontext = context || document;\n\t\n\t\tvar parsed = rsingleTag.exec( data ),\n\t\t\tscripts = !keepScripts && [];\n\t\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[1] ) ];\n\t\t}\n\t\n\t\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\t\n\t\tif ( scripts && scripts.length ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\t\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t};\n\t\n\t\n\t// Keep a copy of the old load method\n\tvar _load = jQuery.fn.load;\n\t\n\t/**\n\t * Load a url into a page\n\t */\n\tjQuery.fn.load = function( url, params, callback ) {\n\t\tif ( typeof url !== \"string\" && _load ) {\n\t\t\treturn _load.apply( this, arguments );\n\t\t}\n\t\n\t\tvar selector, type, response,\n\t\t\tself = this,\n\t\t\toff = url.indexOf(\" \");\n\t\n\t\tif ( off >= 0 ) {\n\t\t\tselector = jQuery.trim( url.slice( off ) );\n\t\t\turl = url.slice( 0, off );\n\t\t}\n\t\n\t\t// If it's a function\n\t\tif ( jQuery.isFunction( params ) ) {\n\t\n\t\t\t// We assume that it's the callback\n\t\t\tcallback = params;\n\t\t\tparams = undefined;\n\t\n\t\t// Otherwise, build a param string\n\t\t} else if ( params && typeof params === \"object\" ) {\n\t\t\ttype = \"POST\";\n\t\t}\n\t\n\t\t// If we have elements to modify, make the request\n\t\tif ( self.length > 0 ) {\n\t\t\tjQuery.ajax({\n\t\t\t\turl: url,\n\t\n\t\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\t\ttype: type,\n\t\t\t\tdataType: \"html\",\n\t\t\t\tdata: params\n\t\t\t}).done(function( responseText ) {\n\t\n\t\t\t\t// Save response for use in complete callback\n\t\t\t\tresponse = arguments;\n\t\n\t\t\t\tself.html( selector ?\n\t\n\t\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\t\n\t\t\t\t\t// Otherwise use the full result\n\t\t\t\t\tresponseText );\n\t\n\t\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t});\n\t\t}\n\t\n\t\treturn this;\n\t};\n\t\n\t\n\t\n\t\n\t// Attach a bunch of functions for handling common AJAX events\n\tjQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\t\tjQuery.fn[ type ] = function( fn ) {\n\t\t\treturn this.on( type, fn );\n\t\t};\n\t});\n\t\n\t\n\t\n\t\n\tjQuery.expr.filters.animated = function( elem ) {\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n\t\n\t\n\t\n\t\n\tvar docElem = window.document.documentElement;\n\t\n\t/**\n\t * Gets a window from an element\n\t */\n\tfunction getWindow( elem ) {\n\t\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n\t}\n\t\n\tjQuery.offset = {\n\t\tsetOffset: function( elem, options, i ) {\n\t\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\t\tcurElem = jQuery( elem ),\n\t\t\t\tprops = {};\n\t\n\t\t\t// Set position first, in-case top/left are set even on static elem\n\t\t\tif ( position === \"static\" ) {\n\t\t\t\telem.style.position = \"relative\";\n\t\t\t}\n\t\n\t\t\tcurOffset = curElem.offset();\n\t\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t\t( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\t\n\t\t\t// Need to be able to calculate position if either\n\t\t\t// top or left is auto and position is either absolute or fixed\n\t\t\tif ( calculatePosition ) {\n\t\t\t\tcurPosition = curElem.position();\n\t\t\t\tcurTop = curPosition.top;\n\t\t\t\tcurLeft = curPosition.left;\n\t\n\t\t\t} else {\n\t\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t\t}\n\t\n\t\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\t\toptions = options.call( elem, i, curOffset );\n\t\t\t}\n\t\n\t\t\tif ( options.top != null ) {\n\t\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t\t}\n\t\t\tif ( options.left != null ) {\n\t\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t\t}\n\t\n\t\t\tif ( \"using\" in options ) {\n\t\t\t\toptions.using.call( elem, props );\n\t\n\t\t\t} else {\n\t\t\t\tcurElem.css( props );\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.fn.extend({\n\t\toffset: function( options ) {\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn options === undefined ?\n\t\t\t\t\tthis :\n\t\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tvar docElem, win,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tbox = { top: 0, left: 0 },\n\t\t\t\tdoc = elem && elem.ownerDocument;\n\t\n\t\t\tif ( !doc ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tdocElem = doc.documentElement;\n\t\n\t\t\t// Make sure it's not a disconnected DOM node\n\t\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\t\treturn box;\n\t\t\t}\n\t\n\t\t\t// Support: BlackBerry 5, iOS 3 (original iPhone)\n\t\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\t\tbox = elem.getBoundingClientRect();\n\t\t\t}\n\t\t\twin = getWindow( doc );\n\t\t\treturn {\n\t\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t\t};\n\t\t},\n\t\n\t\tposition: function() {\n\t\t\tif ( !this[ 0 ] ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar offsetParent, offset,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tparentOffset = { top: 0, left: 0 };\n\t\n\t\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\t\toffset = elem.getBoundingClientRect();\n\t\n\t\t\t} else {\n\t\t\t\t// Get *real* offsetParent\n\t\t\t\toffsetParent = this.offsetParent();\n\t\n\t\t\t\t// Get correct offsets\n\t\t\t\toffset = this.offset();\n\t\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t\t}\n\t\n\t\t\t\t// Add offsetParent borders\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t\t}\n\t\n\t\t\t// Subtract parent offsets and element margins\n\t\t\treturn {\n\t\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t\t};\n\t\t},\n\t\n\t\toffsetParent: function() {\n\t\t\treturn this.map(function() {\n\t\t\t\tvar offsetParent = this.offsetParent || docElem;\n\t\n\t\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t\t}\n\t\n\t\t\t\treturn offsetParent || docElem;\n\t\t\t});\n\t\t}\n\t});\n\t\n\t// Create scrollLeft and scrollTop methods\n\tjQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\t\tvar top = \"pageYOffset\" === prop;\n\t\n\t\tjQuery.fn[ method ] = function( val ) {\n\t\t\treturn access( this, function( elem, method, val ) {\n\t\t\t\tvar win = getWindow( elem );\n\t\n\t\t\t\tif ( val === undefined ) {\n\t\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t\t}\n\t\n\t\t\t\tif ( win ) {\n\t\t\t\t\twin.scrollTo(\n\t\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t\t);\n\t\n\t\t\t\t} else {\n\t\t\t\t\telem[ method ] = val;\n\t\t\t\t}\n\t\t\t}, method, val, arguments.length, null );\n\t\t};\n\t});\n\t\n\t// Support: Safari<7+, Chrome<37+\n\t// Add the top/left cssHooks using jQuery.fn.position\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n\t// getComputedStyle returns percent when specified for top/left/bottom/right;\n\t// rather than make the css module depend on the offset module, just check for it here\n\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\t\tfunction( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\tcomputed;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t});\n\t\n\t\n\t// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\tjQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\t\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t\t// Margin is only for outerHeight, outerWidth\n\t\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\t\n\t\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\t\tvar doc;\n\t\n\t\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Get document width or height\n\t\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\t\tdoc = elem.documentElement;\n\t\n\t\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t\t// whichever is greatest\n\t\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn value === undefined ?\n\t\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\t\n\t\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t\t};\n\t\t});\n\t});\n\t\n\t\n\t// The number of elements contained in the matched element set\n\tjQuery.fn.size = function() {\n\t\treturn this.length;\n\t};\n\t\n\tjQuery.fn.andSelf = jQuery.fn.addBack;\n\t\n\t\n\t\n\t\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\t\n\t// Note that for maximum portability, libraries that are not jQuery should\n\t// declare themselves as anonymous modules, and avoid setting a global if an\n\t// AMD loader is present. jQuery is a special case. For more information, see\n\t// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\t\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\treturn jQuery;\n\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\t\n\t\n\t\n\t\n\tvar\n\t\t// Map over jQuery in case of overwrite\n\t\t_jQuery = window.jQuery,\n\t\n\t\t// Map over the $ in case of overwrite\n\t\t_$ = window.$;\n\t\n\tjQuery.noConflict = function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\t\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\t\n\t\treturn jQuery;\n\t};\n\t\n\t// Expose jQuery and $ identifiers, even in AMD\n\t// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n\t// and CommonJS for browser emulators (#13566)\n\tif ( typeof noGlobal === strundefined ) {\n\t\twindow.jQuery = window.$ = jQuery;\n\t}\n\t\n\t\n\t\n\t\n\treturn jQuery;\n\t\n\t}));\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/*\n\t * Foundation Responsive Library\n\t * http://foundation.zurb.com\n\t * Copyright 2015, ZURB\n\t * Free to use under the MIT license.\n\t * http://www.opensource.org/licenses/mit-license.php\n\t*/\n\t\n\t(function ($, window, document, undefined) {\n\t  'use strict';\n\t\n\t  var header_helpers = function (class_array) {\n\t    var head = $('head');\n\t    head.prepend($.map(class_array, function (class_name) {\n\t      if (head.has('.' + class_name).length === 0) {\n\t        return '<meta class=\"' + class_name + '\" />';\n\t      }\n\t    }));\n\t  };\n\t\n\t  header_helpers([\n\t    'foundation-mq-small',\n\t    'foundation-mq-small-only',\n\t    'foundation-mq-medium',\n\t    'foundation-mq-medium-only',\n\t    'foundation-mq-large',\n\t    'foundation-mq-large-only',\n\t    'foundation-mq-xlarge',\n\t    'foundation-mq-xlarge-only',\n\t    'foundation-mq-xxlarge',\n\t    'foundation-data-attribute-namespace']);\n\t\n\t  // Enable FastClick if present\n\t\n\t  $(function () {\n\t    if (typeof FastClick !== 'undefined') {\n\t      // Don't attach to body if undefined\n\t      if (typeof document.body !== 'undefined') {\n\t        FastClick.attach(document.body);\n\t      }\n\t    }\n\t  });\n\t\n\t  // private Fast Selector wrapper,\n\t  // returns jQuery object. Only use where\n\t  // getElementById is not available.\n\t  var S = function (selector, context) {\n\t    if (typeof selector === 'string') {\n\t      if (context) {\n\t        var cont;\n\t        if (context.jquery) {\n\t          cont = context[0];\n\t          if (!cont) {\n\t            return context;\n\t          }\n\t        } else {\n\t          cont = context;\n\t        }\n\t        return $(cont.querySelectorAll(selector));\n\t      }\n\t\n\t      return $(document.querySelectorAll(selector));\n\t    }\n\t\n\t    return $(selector, context);\n\t  };\n\t\n\t  // Namespace functions.\n\t\n\t  var attr_name = function (init) {\n\t    var arr = [];\n\t    if (!init) {\n\t      arr.push('data');\n\t    }\n\t    if (this.namespace.length > 0) {\n\t      arr.push(this.namespace);\n\t    }\n\t    arr.push(this.name);\n\t\n\t    return arr.join('-');\n\t  };\n\t\n\t  var add_namespace = function (str) {\n\t    var parts = str.split('-'),\n\t        i = parts.length,\n\t        arr = [];\n\t\n\t    while (i--) {\n\t      if (i !== 0) {\n\t        arr.push(parts[i]);\n\t      } else {\n\t        if (this.namespace.length > 0) {\n\t          arr.push(this.namespace, parts[i]);\n\t        } else {\n\t          arr.push(parts[i]);\n\t        }\n\t      }\n\t    }\n\t\n\t    return arr.reverse().join('-');\n\t  };\n\t\n\t  // Event binding and data-options updating.\n\t\n\t  var bindings = function (method, options) {\n\t    var self = this,\n\t        bind = function(){\n\t          var $this = S(this),\n\t              should_bind_events = !$this.data(self.attr_name(true) + '-init');\n\t          $this.data(self.attr_name(true) + '-init', $.extend({}, self.settings, (options || method), self.data_options($this)));\n\t\n\t          if (should_bind_events) {\n\t            self.events(this);\n\t          }\n\t        };\n\t\n\t    if (S(this.scope).is('[' + this.attr_name() +']')) {\n\t      bind.call(this.scope);\n\t    } else {\n\t      S('[' + this.attr_name() +']', this.scope).each(bind);\n\t    }\n\t    // # Patch to fix #5043 to move this *after* the if/else clause in order for Backbone and similar frameworks to have improved control over event binding and data-options updating.\n\t    if (typeof method === 'string') {\n\t      return this[method].call(this, options);\n\t    }\n\t\n\t  };\n\t\n\t  var single_image_loaded = function (image, callback) {\n\t    function loaded () {\n\t      callback(image[0]);\n\t    }\n\t\n\t    function bindLoad () {\n\t      this.one('load', loaded);\n\t\n\t      if (/MSIE (\\d+\\.\\d+);/.test(navigator.userAgent)) {\n\t        var src = this.attr( 'src' ),\n\t            param = src.match( /\\?/ ) ? '&' : '?';\n\t\n\t        param += 'random=' + (new Date()).getTime();\n\t        this.attr('src', src + param);\n\t      }\n\t    }\n\t\n\t    if (!image.attr('src')) {\n\t      loaded();\n\t      return;\n\t    }\n\t\n\t    if (image[0].complete || image[0].readyState === 4) {\n\t      loaded();\n\t    } else {\n\t      bindLoad.call(image);\n\t    }\n\t  };\n\t\n\t  /*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */\n\t\n\t  window.matchMedia || (window.matchMedia = function() {\n\t      \"use strict\";\n\t\n\t      // For browsers that support matchMedium api such as IE 9 and webkit\n\t      var styleMedia = (window.styleMedia || window.media);\n\t\n\t      // For those that don't support matchMedium\n\t      if (!styleMedia) {\n\t          var style       = document.createElement('style'),\n\t              script      = document.getElementsByTagName('script')[0],\n\t              info        = null;\n\t\n\t          style.type  = 'text/css';\n\t          style.id    = 'matchmediajs-test';\n\t\n\t          script.parentNode.insertBefore(style, script);\n\t\n\t          // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n\t          info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;\n\t\n\t          styleMedia = {\n\t              matchMedium: function(media) {\n\t                  var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\n\t\n\t                  // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n\t                  if (style.styleSheet) {\n\t                      style.styleSheet.cssText = text;\n\t                  } else {\n\t                      style.textContent = text;\n\t                  }\n\t\n\t                  // Test if media query is true or false\n\t                  return info.width === '1px';\n\t              }\n\t          };\n\t      }\n\t\n\t      return function(media) {\n\t          return {\n\t              matches: styleMedia.matchMedium(media || 'all'),\n\t              media: media || 'all'\n\t          };\n\t      };\n\t  }());\n\t\n\t  /*\n\t   * jquery.requestAnimationFrame\n\t   * https://github.com/gnarf37/jquery-requestAnimationFrame\n\t   * Requires jQuery 1.8+\n\t   *\n\t   * Copyright (c) 2012 Corey Frang\n\t   * Licensed under the MIT license.\n\t   */\n\t\n\t  (function(jQuery) {\n\t\n\t\n\t  // requestAnimationFrame polyfill adapted from Erik Möller\n\t  // fixes from Paul Irish and Tino Zijdel\n\t  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\t  // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\t\n\t  var animating,\n\t      lastTime = 0,\n\t      vendors = ['webkit', 'moz'],\n\t      requestAnimationFrame = window.requestAnimationFrame,\n\t      cancelAnimationFrame = window.cancelAnimationFrame,\n\t      jqueryFxAvailable = 'undefined' !== typeof jQuery.fx;\n\t\n\t  for (; lastTime < vendors.length && !requestAnimationFrame; lastTime++) {\n\t    requestAnimationFrame = window[ vendors[lastTime] + 'RequestAnimationFrame' ];\n\t    cancelAnimationFrame = cancelAnimationFrame ||\n\t      window[ vendors[lastTime] + 'CancelAnimationFrame' ] ||\n\t      window[ vendors[lastTime] + 'CancelRequestAnimationFrame' ];\n\t  }\n\t\n\t  function raf() {\n\t    if (animating) {\n\t      requestAnimationFrame(raf);\n\t\n\t      if (jqueryFxAvailable) {\n\t        jQuery.fx.tick();\n\t      }\n\t    }\n\t  }\n\t\n\t  if (requestAnimationFrame) {\n\t    // use rAF\n\t    window.requestAnimationFrame = requestAnimationFrame;\n\t    window.cancelAnimationFrame = cancelAnimationFrame;\n\t\n\t    if (jqueryFxAvailable) {\n\t      jQuery.fx.timer = function (timer) {\n\t        if (timer() && jQuery.timers.push(timer) && !animating) {\n\t          animating = true;\n\t          raf();\n\t        }\n\t      };\n\t\n\t      jQuery.fx.stop = function () {\n\t        animating = false;\n\t      };\n\t    }\n\t  } else {\n\t    // polyfill\n\t    window.requestAnimationFrame = function (callback) {\n\t      var currTime = new Date().getTime(),\n\t        timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n\t        id = window.setTimeout(function () {\n\t          callback(currTime + timeToCall);\n\t        }, timeToCall);\n\t      lastTime = currTime + timeToCall;\n\t      return id;\n\t    };\n\t\n\t    window.cancelAnimationFrame = function (id) {\n\t      clearTimeout(id);\n\t    };\n\t\n\t  }\n\t\n\t  }( $ ));\n\t\n\t  function removeQuotes (string) {\n\t    if (typeof string === 'string' || string instanceof String) {\n\t      string = string.replace(/^['\\\\/\"]+|(;\\s?})+|['\\\\/\"]+$/g, '');\n\t    }\n\t\n\t    return string;\n\t  }\n\t\n\t  function MediaQuery(selector) {\n\t    this.selector = selector;\n\t    this.query = '';\n\t  }\n\t\n\t  MediaQuery.prototype.toString = function () {\n\t    return this.query || (this.query = S(this.selector).css('font-family').replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, ''));\n\t  };\n\t\n\t  window.Foundation = {\n\t    name : 'Foundation',\n\t\n\t    version : '5.5.3',\n\t\n\t    media_queries : {\n\t      'small'       : new MediaQuery('.foundation-mq-small'),\n\t      'small-only'  : new MediaQuery('.foundation-mq-small-only'),\n\t      'medium'      : new MediaQuery('.foundation-mq-medium'),\n\t      'medium-only' : new MediaQuery('.foundation-mq-medium-only'),\n\t      'large'       : new MediaQuery('.foundation-mq-large'),\n\t      'large-only'  : new MediaQuery('.foundation-mq-large-only'),\n\t      'xlarge'      : new MediaQuery('.foundation-mq-xlarge'),\n\t      'xlarge-only' : new MediaQuery('.foundation-mq-xlarge-only'),\n\t      'xxlarge'     : new MediaQuery('.foundation-mq-xxlarge')\n\t    },\n\t\n\t    stylesheet : $('<style></style>').appendTo('head')[0].sheet,\n\t\n\t    global : {\n\t      namespace : undefined\n\t    },\n\t\n\t    init : function (scope, libraries, method, options, response) {\n\t      var args = [scope, method, options, response],\n\t          responses = [];\n\t\n\t      // check RTL\n\t      this.rtl = /rtl/i.test(S('html').attr('dir'));\n\t\n\t      // set foundation global scope\n\t      this.scope = scope || this.scope;\n\t\n\t      this.set_namespace();\n\t\n\t      if (libraries && typeof libraries === 'string' && !/reflow/i.test(libraries)) {\n\t        if (this.libs.hasOwnProperty(libraries)) {\n\t          responses.push(this.init_lib(libraries, args));\n\t        }\n\t      } else {\n\t        for (var lib in this.libs) {\n\t          responses.push(this.init_lib(lib, libraries));\n\t        }\n\t      }\n\t\n\t      S(window).load(function () {\n\t        S(window)\n\t          .trigger('resize.fndtn.clearing')\n\t          .trigger('resize.fndtn.dropdown')\n\t          .trigger('resize.fndtn.equalizer')\n\t          .trigger('resize.fndtn.interchange')\n\t          .trigger('resize.fndtn.joyride')\n\t          .trigger('resize.fndtn.magellan')\n\t          .trigger('resize.fndtn.topbar')\n\t          .trigger('resize.fndtn.slider');\n\t      });\n\t\n\t      return scope;\n\t    },\n\t\n\t    init_lib : function (lib, args) {\n\t      if (this.libs.hasOwnProperty(lib)) {\n\t        this.patch(this.libs[lib]);\n\t\n\t        if (args && args.hasOwnProperty(lib)) {\n\t            if (typeof this.libs[lib].settings !== 'undefined') {\n\t              $.extend(true, this.libs[lib].settings, args[lib]);\n\t            } else if (typeof this.libs[lib].defaults !== 'undefined') {\n\t              $.extend(true, this.libs[lib].defaults, args[lib]);\n\t            }\n\t          return this.libs[lib].init.apply(this.libs[lib], [this.scope, args[lib]]);\n\t        }\n\t\n\t        args = args instanceof Array ? args : new Array(args);\n\t        return this.libs[lib].init.apply(this.libs[lib], args);\n\t      }\n\t\n\t      return function () {};\n\t    },\n\t\n\t    patch : function (lib) {\n\t      lib.scope = this.scope;\n\t      lib.namespace = this.global.namespace;\n\t      lib.rtl = this.rtl;\n\t      lib['data_options'] = this.utils.data_options;\n\t      lib['attr_name'] = attr_name;\n\t      lib['add_namespace'] = add_namespace;\n\t      lib['bindings'] = bindings;\n\t      lib['S'] = this.utils.S;\n\t    },\n\t\n\t    inherit : function (scope, methods) {\n\t      var methods_arr = methods.split(' '),\n\t          i = methods_arr.length;\n\t\n\t      while (i--) {\n\t        if (this.utils.hasOwnProperty(methods_arr[i])) {\n\t          scope[methods_arr[i]] = this.utils[methods_arr[i]];\n\t        }\n\t      }\n\t    },\n\t\n\t    set_namespace : function () {\n\t\n\t      // Description:\n\t      //    Don't bother reading the namespace out of the meta tag\n\t      //    if the namespace has been set globally in javascript\n\t      //\n\t      // Example:\n\t      //    Foundation.global.namespace = 'my-namespace';\n\t      // or make it an empty string:\n\t      //    Foundation.global.namespace = '';\n\t      //\n\t      //\n\t\n\t      // If the namespace has not been set (is undefined), try to read it out of the meta element.\n\t      // Otherwise use the globally defined namespace, even if it's empty ('')\n\t      var namespace = ( this.global.namespace === undefined ) ? $('.foundation-data-attribute-namespace').css('font-family') : this.global.namespace;\n\t\n\t      // Finally, if the namsepace is either undefined or false, set it to an empty string.\n\t      // Otherwise use the namespace value.\n\t      this.global.namespace = ( namespace === undefined || /false/i.test(namespace) ) ? '' : namespace;\n\t    },\n\t\n\t    libs : {},\n\t\n\t    // methods that can be inherited in libraries\n\t    utils : {\n\t\n\t      // Description:\n\t      //    Fast Selector wrapper returns jQuery object. Only use where getElementById\n\t      //    is not available.\n\t      //\n\t      // Arguments:\n\t      //    Selector (String): CSS selector describing the element(s) to be\n\t      //    returned as a jQuery object.\n\t      //\n\t      //    Scope (String): CSS selector describing the area to be searched. Default\n\t      //    is document.\n\t      //\n\t      // Returns:\n\t      //    Element (jQuery Object): jQuery object containing elements matching the\n\t      //    selector within the scope.\n\t      S : S,\n\t\n\t      // Description:\n\t      //    Executes a function a max of once every n milliseconds\n\t      //\n\t      // Arguments:\n\t      //    Func (Function): Function to be throttled.\n\t      //\n\t      //    Delay (Integer): Function execution threshold in milliseconds.\n\t      //\n\t      // Returns:\n\t      //    Lazy_function (Function): Function with throttling applied.\n\t      throttle : function (func, delay) {\n\t        var timer = null;\n\t\n\t        return function () {\n\t          var context = this, args = arguments;\n\t\n\t          if (timer == null) {\n\t            timer = setTimeout(function () {\n\t              func.apply(context, args);\n\t              timer = null;\n\t            }, delay);\n\t          }\n\t        };\n\t      },\n\t\n\t      // Description:\n\t      //    Executes a function when it stops being invoked for n seconds\n\t      //    Modified version of _.debounce() http://underscorejs.org\n\t      //\n\t      // Arguments:\n\t      //    Func (Function): Function to be debounced.\n\t      //\n\t      //    Delay (Integer): Function execution threshold in milliseconds.\n\t      //\n\t      //    Immediate (Bool): Whether the function should be called at the beginning\n\t      //    of the delay instead of the end. Default is false.\n\t      //\n\t      // Returns:\n\t      //    Lazy_function (Function): Function with debouncing applied.\n\t      debounce : function (func, delay, immediate) {\n\t        var timeout, result;\n\t        return function () {\n\t          var context = this, args = arguments;\n\t          var later = function () {\n\t            timeout = null;\n\t            if (!immediate) {\n\t              result = func.apply(context, args);\n\t            }\n\t          };\n\t          var callNow = immediate && !timeout;\n\t          clearTimeout(timeout);\n\t          timeout = setTimeout(later, delay);\n\t          if (callNow) {\n\t            result = func.apply(context, args);\n\t          }\n\t          return result;\n\t        };\n\t      },\n\t\n\t      // Description:\n\t      //    Parses data-options attribute\n\t      //\n\t      // Arguments:\n\t      //    El (jQuery Object): Element to be parsed.\n\t      //\n\t      // Returns:\n\t      //    Options (Javascript Object): Contents of the element's data-options\n\t      //    attribute.\n\t      data_options : function (el, data_attr_name) {\n\t        data_attr_name = data_attr_name || 'options';\n\t        var opts = {}, ii, p, opts_arr,\n\t            data_options = function (el) {\n\t              var namespace = Foundation.global.namespace;\n\t\n\t              if (namespace.length > 0) {\n\t                return el.data(namespace + '-' + data_attr_name);\n\t              }\n\t\n\t              return el.data(data_attr_name);\n\t            };\n\t\n\t        var cached_options = data_options(el);\n\t\n\t        if (typeof cached_options === 'object') {\n\t          return cached_options;\n\t        }\n\t\n\t        opts_arr = (cached_options || ':').split(';');\n\t        ii = opts_arr.length;\n\t\n\t        function isNumber (o) {\n\t          return !isNaN (o - 0) && o !== null && o !== '' && o !== false && o !== true;\n\t        }\n\t\n\t        function trim (str) {\n\t          if (typeof str === 'string') {\n\t            return $.trim(str);\n\t          }\n\t          return str;\n\t        }\n\t\n\t        while (ii--) {\n\t          p = opts_arr[ii].split(':');\n\t          p = [p[0], p.slice(1).join(':')];\n\t\n\t          if (/true/i.test(p[1])) {\n\t            p[1] = true;\n\t          }\n\t          if (/false/i.test(p[1])) {\n\t            p[1] = false;\n\t          }\n\t          if (isNumber(p[1])) {\n\t            if (p[1].indexOf('.') === -1) {\n\t              p[1] = parseInt(p[1], 10);\n\t            } else {\n\t              p[1] = parseFloat(p[1]);\n\t            }\n\t          }\n\t\n\t          if (p.length === 2 && p[0].length > 0) {\n\t            opts[trim(p[0])] = trim(p[1]);\n\t          }\n\t        }\n\t\n\t        return opts;\n\t      },\n\t\n\t      // Description:\n\t      //    Adds JS-recognizable media queries\n\t      //\n\t      // Arguments:\n\t      //    Media (String): Key string for the media query to be stored as in\n\t      //    Foundation.media_queries\n\t      //\n\t      //    Class (String): Class name for the generated <meta> tag\n\t      register_media : function (media, media_class) {\n\t        if (Foundation.media_queries[media] === undefined) {\n\t          $('head').append('<meta class=\"' + media_class + '\"/>');\n\t          Foundation.media_queries[media] = removeQuotes($('.' + media_class).css('font-family'));\n\t        }\n\t      },\n\t\n\t      // Description:\n\t      //    Add custom CSS within a JS-defined media query\n\t      //\n\t      // Arguments:\n\t      //    Rule (String): CSS rule to be appended to the document.\n\t      //\n\t      //    Media (String): Optional media query string for the CSS rule to be\n\t      //    nested under.\n\t      add_custom_rule : function (rule, media) {\n\t        if (media === undefined && Foundation.stylesheet) {\n\t          Foundation.stylesheet.insertRule(rule, Foundation.stylesheet.cssRules.length);\n\t        } else {\n\t          var query = Foundation.media_queries[media];\n\t\n\t          if (query !== undefined) {\n\t            Foundation.stylesheet.insertRule('@media ' +\n\t              Foundation.media_queries[media] + '{ ' + rule + ' }', Foundation.stylesheet.cssRules.length);\n\t          }\n\t        }\n\t      },\n\t\n\t      // Description:\n\t      //    Performs a callback function when an image is fully loaded\n\t      //\n\t      // Arguments:\n\t      //    Image (jQuery Object): Image(s) to check if loaded.\n\t      //\n\t      //    Callback (Function): Function to execute when image is fully loaded.\n\t      image_loaded : function (images, callback) {\n\t        var self = this,\n\t            unloaded = images.length;\n\t\n\t        function pictures_has_height(images) {\n\t          var pictures_number = images.length;\n\t\n\t          for (var i = pictures_number - 1; i >= 0; i--) {\n\t            if(images.attr('height') === undefined) {\n\t              return false;\n\t            };\n\t          };\n\t\n\t          return true;\n\t        }\n\t\n\t        if (unloaded === 0 || pictures_has_height(images)) {\n\t          callback(images);\n\t        }\n\t\n\t        images.each(function () {\n\t          single_image_loaded(self.S(this), function () {\n\t            unloaded -= 1;\n\t            if (unloaded === 0) {\n\t              callback(images);\n\t            }\n\t          });\n\t        });\n\t      },\n\t\n\t      // Description:\n\t      //    Returns a random, alphanumeric string\n\t      //\n\t      // Arguments:\n\t      //    Length (Integer): Length of string to be generated. Defaults to random\n\t      //    integer.\n\t      //\n\t      // Returns:\n\t      //    Rand (String): Pseudo-random, alphanumeric string.\n\t      random_str : function () {\n\t        if (!this.fidx) {\n\t          this.fidx = 0;\n\t        }\n\t        this.prefix = this.prefix || [(this.name || 'F'), (+new Date).toString(36)].join('-');\n\t\n\t        return this.prefix + (this.fidx++).toString(36);\n\t      },\n\t\n\t      // Description:\n\t      //    Helper for window.matchMedia\n\t      //\n\t      // Arguments:\n\t      //    mq (String): Media query\n\t      //\n\t      // Returns:\n\t      //    (Boolean): Whether the media query passes or not\n\t      match : function (mq) {\n\t        return window.matchMedia(mq).matches;\n\t      },\n\t\n\t      // Description:\n\t      //    Helpers for checking Foundation default media queries with JS\n\t      //\n\t      // Returns:\n\t      //    (Boolean): Whether the media query passes or not\n\t\n\t      is_small_up : function () {\n\t        return this.match(Foundation.media_queries.small);\n\t      },\n\t\n\t      is_medium_up : function () {\n\t        return this.match(Foundation.media_queries.medium);\n\t      },\n\t\n\t      is_large_up : function () {\n\t        return this.match(Foundation.media_queries.large);\n\t      },\n\t\n\t      is_xlarge_up : function () {\n\t        return this.match(Foundation.media_queries.xlarge);\n\t      },\n\t\n\t      is_xxlarge_up : function () {\n\t        return this.match(Foundation.media_queries.xxlarge);\n\t      },\n\t\n\t      is_small_only : function () {\n\t        return !this.is_medium_up() && !this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();\n\t      },\n\t\n\t      is_medium_only : function () {\n\t        return this.is_medium_up() && !this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();\n\t      },\n\t\n\t      is_large_only : function () {\n\t        return this.is_medium_up() && this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();\n\t      },\n\t\n\t      is_xlarge_only : function () {\n\t        return this.is_medium_up() && this.is_large_up() && this.is_xlarge_up() && !this.is_xxlarge_up();\n\t      },\n\t\n\t      is_xxlarge_only : function () {\n\t        return this.is_medium_up() && this.is_large_up() && this.is_xlarge_up() && this.is_xxlarge_up();\n\t      }\n\t    }\n\t  };\n\t\n\t  $.fn.foundation = function () {\n\t    var args = Array.prototype.slice.call(arguments, 0);\n\t\n\t    return this.each(function () {\n\t      Foundation.init.apply(Foundation, [this].concat(args));\n\t      return this;\n\t    });\n\t  };\n\t\n\t}(jQuery, window, window.document));\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t;(function ($, window, document, undefined) {\n\t  'use strict';\n\t\n\t  Foundation.libs.interchange = {\n\t    name : 'interchange',\n\t\n\t    version : '5.5.3',\n\t\n\t    cache : {},\n\t\n\t    images_loaded : false,\n\t    nodes_loaded : false,\n\t\n\t    settings : {\n\t      load_attr : 'interchange',\n\t\n\t      named_queries : {\n\t        'default'     : 'only screen',\n\t        'small'       : Foundation.media_queries['small'],\n\t        'small-only'  : Foundation.media_queries['small-only'],\n\t        'medium'      : Foundation.media_queries['medium'],\n\t        'medium-only' : Foundation.media_queries['medium-only'],\n\t        'large'       : Foundation.media_queries['large'],\n\t        'large-only'  : Foundation.media_queries['large-only'],\n\t        'xlarge'      : Foundation.media_queries['xlarge'],\n\t        'xlarge-only' : Foundation.media_queries['xlarge-only'],\n\t        'xxlarge'     : Foundation.media_queries['xxlarge'],\n\t        'landscape'   : 'only screen and (orientation: landscape)',\n\t        'portrait'    : 'only screen and (orientation: portrait)',\n\t        'retina'      : 'only screen and (-webkit-min-device-pixel-ratio: 2),' +\n\t          'only screen and (min--moz-device-pixel-ratio: 2),' +\n\t          'only screen and (-o-min-device-pixel-ratio: 2/1),' +\n\t          'only screen and (min-device-pixel-ratio: 2),' +\n\t          'only screen and (min-resolution: 192dpi),' +\n\t          'only screen and (min-resolution: 2dppx)'\n\t      },\n\t\n\t      directives : {\n\t        replace : function (el, path, trigger) {\n\t          // The trigger argument, if called within the directive, fires\n\t          // an event named after the directive on the element, passing\n\t          // any parameters along to the event that you pass to trigger.\n\t          //\n\t          // ex. trigger(), trigger([a, b, c]), or trigger(a, b, c)\n\t          //\n\t          // This allows you to bind a callback like so:\n\t          // $('#interchangeContainer').on('replace', function (e, a, b, c) {\n\t          //   console.log($(this).html(), a, b, c);\n\t          // });\n\t\n\t          if (el !== null && /IMG/.test(el[0].nodeName)) {\n\t            var orig_path = $.each(el, function(){this.src = path;});\n\t            // var orig_path = el[0].src;\n\t\n\t            if (new RegExp(path, 'i').test(orig_path)) {\n\t              return;\n\t            }\n\t\n\t            el.attr(\"src\", path);\n\t\n\t            return trigger(el[0].src);\n\t          }\n\t          var last_path = el.data(this.data_attr + '-last-path'),\n\t              self = this;\n\t\n\t          if (last_path == path) {\n\t            return;\n\t          }\n\t\n\t          if (/\\.(gif|jpg|jpeg|tiff|png)([?#].*)?/i.test(path)) {\n\t            $(el).css('background-image', 'url(' + path + ')');\n\t            el.data('interchange-last-path', path);\n\t            return trigger(path);\n\t          }\n\t\n\t          return $.get(path, function (response) {\n\t            el.html(response);\n\t            el.data(self.data_attr + '-last-path', path);\n\t            trigger();\n\t          });\n\t\n\t        }\n\t      }\n\t    },\n\t\n\t    init : function (scope, method, options) {\n\t      Foundation.inherit(this, 'throttle random_str');\n\t\n\t      this.data_attr = this.set_data_attr();\n\t      $.extend(true, this.settings, method, options);\n\t      this.bindings(method, options);\n\t      this.reflow();\n\t    },\n\t\n\t    get_media_hash : function () {\n\t        var mediaHash = '';\n\t        for (var queryName in this.settings.named_queries ) {\n\t            mediaHash += matchMedia(this.settings.named_queries[queryName]).matches.toString();\n\t        }\n\t        return mediaHash;\n\t    },\n\t\n\t    events : function () {\n\t      var self = this, prevMediaHash;\n\t\n\t      $(window)\n\t        .off('.interchange')\n\t        .on('resize.fndtn.interchange', self.throttle(function () {\n\t            var currMediaHash = self.get_media_hash();\n\t            if (currMediaHash !== prevMediaHash) {\n\t                self.resize();\n\t            }\n\t            prevMediaHash = currMediaHash;\n\t        }, 50));\n\t\n\t      return this;\n\t    },\n\t\n\t    resize : function () {\n\t      var cache = this.cache;\n\t\n\t      if (!this.images_loaded || !this.nodes_loaded) {\n\t        setTimeout($.proxy(this.resize, this), 50);\n\t        return;\n\t      }\n\t\n\t      for (var uuid in cache) {\n\t        if (cache.hasOwnProperty(uuid)) {\n\t          var passed = this.results(uuid, cache[uuid]);\n\t          if (passed) {\n\t            this.settings.directives[passed\n\t              .scenario[1]].call(this, passed.el, passed.scenario[0], (function (passed) {\n\t                if (arguments[0] instanceof Array) {\n\t                  var args = arguments[0];\n\t                } else {\n\t                  var args = Array.prototype.slice.call(arguments, 0);\n\t                }\n\t\n\t                return function() {\n\t                  passed.el.trigger(passed.scenario[1], args);\n\t                }\n\t              }(passed)));\n\t          }\n\t        }\n\t      }\n\t\n\t    },\n\t\n\t    results : function (uuid, scenarios) {\n\t      var count = scenarios.length;\n\t\n\t      if (count > 0) {\n\t        var el = this.S('[' + this.add_namespace('data-uuid') + '=\"' + uuid + '\"]');\n\t\n\t        while (count--) {\n\t          var mq, rule = scenarios[count][2];\n\t          if (this.settings.named_queries.hasOwnProperty(rule)) {\n\t            mq = matchMedia(this.settings.named_queries[rule]);\n\t          } else {\n\t            mq = matchMedia(rule);\n\t          }\n\t          if (mq.matches) {\n\t            return {el : el, scenario : scenarios[count]};\n\t          }\n\t        }\n\t      }\n\t\n\t      return false;\n\t    },\n\t\n\t    load : function (type, force_update) {\n\t      if (typeof this['cached_' + type] === 'undefined' || force_update) {\n\t        this['update_' + type]();\n\t      }\n\t\n\t      return this['cached_' + type];\n\t    },\n\t\n\t    update_images : function () {\n\t      var images = this.S('img[' + this.data_attr + ']'),\n\t          count = images.length,\n\t          i = count,\n\t          loaded_count = 0,\n\t          data_attr = this.data_attr;\n\t\n\t      this.cache = {};\n\t      this.cached_images = [];\n\t      this.images_loaded = (count === 0);\n\t\n\t      while (i--) {\n\t        loaded_count++;\n\t        if (images[i]) {\n\t          var str = images[i].getAttribute(data_attr) || '';\n\t\n\t          if (str.length > 0) {\n\t            this.cached_images.push(images[i]);\n\t          }\n\t        }\n\t\n\t        if (loaded_count === count) {\n\t          this.images_loaded = true;\n\t          this.enhance('images');\n\t        }\n\t      }\n\t\n\t      return this;\n\t    },\n\t\n\t    update_nodes : function () {\n\t      var nodes = this.S('[' + this.data_attr + ']').not('img'),\n\t          count = nodes.length,\n\t          i = count,\n\t          loaded_count = 0,\n\t          data_attr = this.data_attr;\n\t\n\t      this.cached_nodes = [];\n\t      this.nodes_loaded = (count === 0);\n\t\n\t      while (i--) {\n\t        loaded_count++;\n\t        var str = nodes[i].getAttribute(data_attr) || '';\n\t\n\t        if (str.length > 0) {\n\t          this.cached_nodes.push(nodes[i]);\n\t        }\n\t\n\t        if (loaded_count === count) {\n\t          this.nodes_loaded = true;\n\t          this.enhance('nodes');\n\t        }\n\t      }\n\t\n\t      return this;\n\t    },\n\t\n\t    enhance : function (type) {\n\t      var i = this['cached_' + type].length;\n\t\n\t      while (i--) {\n\t        this.object($(this['cached_' + type][i]));\n\t      }\n\t\n\t      return $(window).trigger('resize.fndtn.interchange');\n\t    },\n\t\n\t    convert_directive : function (directive) {\n\t\n\t      var trimmed = this.trim(directive);\n\t\n\t      if (trimmed.length > 0) {\n\t        return trimmed;\n\t      }\n\t\n\t      return 'replace';\n\t    },\n\t\n\t    parse_scenario : function (scenario) {\n\t      // This logic had to be made more complex since some users were using commas in the url path\n\t      // So we cannot simply just split on a comma\n\t\n\t      var directive_match = scenario[0].match(/(.+),\\s*(\\w+)\\s*$/),\n\t      // getting the mq has gotten a bit complicated since we started accounting for several use cases\n\t      // of URLs. For now we'll continue to match these scenarios, but we may consider having these scenarios\n\t      // as nested objects or arrays in F6.\n\t      // regex: match everything before close parenthesis for mq\n\t      media_query         = scenario[1].match(/(.*)\\)/);\n\t\n\t      if (directive_match) {\n\t        var path  = directive_match[1],\n\t        directive = directive_match[2];\n\t\n\t      } else {\n\t        var cached_split = scenario[0].split(/,\\s*$/),\n\t        path             = cached_split[0],\n\t        directive        = '';\n\t      }\n\t\n\t      return [this.trim(path), this.convert_directive(directive), this.trim(media_query[1])];\n\t    },\n\t\n\t    object : function (el) {\n\t      var raw_arr = this.parse_data_attr(el),\n\t          scenarios = [],\n\t          i = raw_arr.length;\n\t\n\t      if (i > 0) {\n\t        while (i--) {\n\t          // split array between comma delimited content and mq\n\t          // regex: comma, optional space, open parenthesis\n\t          var scenario = raw_arr[i].split(/,\\s?\\(/);\n\t\n\t          if (scenario.length > 1) {\n\t            var params = this.parse_scenario(scenario);\n\t            scenarios.push(params);\n\t          }\n\t        }\n\t      }\n\t\n\t      return this.store(el, scenarios);\n\t    },\n\t\n\t    store : function (el, scenarios) {\n\t      var uuid = this.random_str(),\n\t          current_uuid = el.data(this.add_namespace('uuid', true));\n\t\n\t      if (this.cache[current_uuid]) {\n\t        return this.cache[current_uuid];\n\t      }\n\t\n\t      el.attr(this.add_namespace('data-uuid'), uuid);\n\t      return this.cache[uuid] = scenarios;\n\t    },\n\t\n\t    trim : function (str) {\n\t\n\t      if (typeof str === 'string') {\n\t        return $.trim(str);\n\t      }\n\t\n\t      return str;\n\t    },\n\t\n\t    set_data_attr : function (init) {\n\t      if (init) {\n\t        if (this.namespace.length > 0) {\n\t          return this.namespace + '-' + this.settings.load_attr;\n\t        }\n\t\n\t        return this.settings.load_attr;\n\t      }\n\t\n\t      if (this.namespace.length > 0) {\n\t        return 'data-' + this.namespace + '-' + this.settings.load_attr;\n\t      }\n\t\n\t      return 'data-' + this.settings.load_attr;\n\t    },\n\t\n\t    parse_data_attr : function (el) {\n\t      var raw = el.attr(this.attr_name()).split(/\\[(.*?)\\]/),\n\t          i = raw.length,\n\t          output = [];\n\t\n\t      while (i--) {\n\t        if (raw[i].replace(/[\\W\\d]+/, '').length > 4) {\n\t          output.push(raw[i]);\n\t        }\n\t      }\n\t\n\t      return output;\n\t    },\n\t\n\t    reflow : function () {\n\t      this.load('images', true);\n\t      this.load('nodes', true);\n\t    }\n\t\n\t  };\n\t\n\t}(jQuery, window, window.document));\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t;(function ($, window, document, undefined) {\n\t  'use strict';\n\t\n\t  var openModals = [];\n\t\n\t  Foundation.libs.reveal = {\n\t    name : 'reveal',\n\t\n\t    version : '5.5.3',\n\t\n\t    locked : false,\n\t\n\t    settings : {\n\t      animation : 'fadeAndPop',\n\t      animation_speed : 250,\n\t      close_on_background_click : true,\n\t      close_on_esc : true,\n\t      dismiss_modal_class : 'close-reveal-modal',\n\t      multiple_opened : false,\n\t      bg_class : 'reveal-modal-bg',\n\t      root_element : 'body',\n\t      open : function(){},\n\t      opened : function(){},\n\t      close : function(){},\n\t      closed : function(){},\n\t      on_ajax_error: $.noop,\n\t      bg : $('.reveal-modal-bg'),\n\t      css : {\n\t        open : {\n\t          'opacity' : 0,\n\t          'visibility' : 'visible',\n\t          'display' : 'block'\n\t        },\n\t        close : {\n\t          'opacity' : 1,\n\t          'visibility' : 'hidden',\n\t          'display' : 'none'\n\t        }\n\t      }\n\t    },\n\t\n\t    init : function (scope, method, options) {\n\t      $.extend(true, this.settings, method, options);\n\t      this.bindings(method, options);\n\t    },\n\t\n\t    events : function (scope) {\n\t      var self = this,\n\t          S = self.S;\n\t\n\t      S(this.scope)\n\t        .off('.reveal')\n\t        .on('click.fndtn.reveal', '[' + this.add_namespace('data-reveal-id') + ']:not([disabled])', function (e) {\n\t          e.preventDefault();\n\t\n\t          if (!self.locked) {\n\t            var element = S(this),\n\t                ajax = element.data(self.data_attr('reveal-ajax')),\n\t                replaceContentSel = element.data(self.data_attr('reveal-replace-content'));\n\t\n\t            self.locked = true;\n\t\n\t            if (typeof ajax === 'undefined') {\n\t              self.open.call(self, element);\n\t            } else {\n\t              var url = ajax === true ? element.attr('href') : ajax;\n\t              self.open.call(self, element, {url : url}, { replaceContentSel : replaceContentSel });\n\t            }\n\t          }\n\t        });\n\t\n\t      S(document)\n\t        .on('click.fndtn.reveal', this.close_targets(), function (e) {\n\t          e.preventDefault();\n\t          if (!self.locked) {\n\t            var settings = S('[' + self.attr_name() + '].open').data(self.attr_name(true) + '-init') || self.settings,\n\t                bg_clicked = S(e.target)[0] === S('.' + settings.bg_class)[0];\n\t\n\t            if (bg_clicked) {\n\t              if (settings.close_on_background_click) {\n\t                e.stopPropagation();\n\t              } else {\n\t                return;\n\t              }\n\t            }\n\t\n\t            self.locked = true;\n\t            self.close.call(self, bg_clicked ? S('[' + self.attr_name() + '].open:not(.toback)') : S(this).closest('[' + self.attr_name() + ']'));\n\t          }\n\t        });\n\t\n\t      if (S('[' + self.attr_name() + ']', this.scope).length > 0) {\n\t        S(this.scope)\n\t          // .off('.reveal')\n\t          .on('open.fndtn.reveal', this.settings.open)\n\t          .on('opened.fndtn.reveal', this.settings.opened)\n\t          .on('opened.fndtn.reveal', this.open_video)\n\t          .on('close.fndtn.reveal', this.settings.close)\n\t          .on('closed.fndtn.reveal', this.settings.closed)\n\t          .on('closed.fndtn.reveal', this.close_video);\n\t      } else {\n\t        S(this.scope)\n\t          // .off('.reveal')\n\t          .on('open.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.open)\n\t          .on('opened.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.opened)\n\t          .on('opened.fndtn.reveal', '[' + self.attr_name() + ']', this.open_video)\n\t          .on('close.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.close)\n\t          .on('closed.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.closed)\n\t          .on('closed.fndtn.reveal', '[' + self.attr_name() + ']', this.close_video);\n\t      }\n\t\n\t      return true;\n\t    },\n\t\n\t    // PATCH #3: turning on key up capture only when a reveal window is open\n\t    key_up_on : function (scope) {\n\t      var self = this;\n\t\n\t      // PATCH #1: fixing multiple keyup event trigger from single key press\n\t      self.S('body').off('keyup.fndtn.reveal').on('keyup.fndtn.reveal', function ( event ) {\n\t        var open_modal = self.S('[' + self.attr_name() + '].open'),\n\t            settings = open_modal.data(self.attr_name(true) + '-init') || self.settings ;\n\t        // PATCH #2: making sure that the close event can be called only while unlocked,\n\t        //           so that multiple keyup.fndtn.reveal events don't prevent clean closing of the reveal window.\n\t        if ( settings && event.which === 27  && settings.close_on_esc && !self.locked) { // 27 is the keycode for the Escape key\n\t          self.close.call(self, open_modal);\n\t        }\n\t      });\n\t\n\t      return true;\n\t    },\n\t\n\t    // PATCH #3: turning on key up capture only when a reveal window is open\n\t    key_up_off : function (scope) {\n\t      this.S('body').off('keyup.fndtn.reveal');\n\t      return true;\n\t    },\n\t\n\t    open : function (target, ajax_settings) {\n\t      var self = this,\n\t          modal;\n\t\n\t      if (target) {\n\t        if (typeof target.selector !== 'undefined') {\n\t          // Find the named node; only use the first one found, since the rest of the code assumes there's only one node\n\t          modal = self.S('#' + target.data(self.data_attr('reveal-id'))).first();\n\t        } else {\n\t          modal = self.S(this.scope);\n\t\n\t          ajax_settings = target;\n\t        }\n\t      } else {\n\t        modal = self.S(this.scope);\n\t      }\n\t\n\t      var settings = modal.data(self.attr_name(true) + '-init');\n\t      settings = settings || this.settings;\n\t\n\t\n\t      if (modal.hasClass('open') && target !== undefined && target.attr('data-reveal-id') == modal.attr('id')) {\n\t        return self.close(modal);\n\t      }\n\t\n\t      if (!modal.hasClass('open')) {\n\t        var open_modal = self.S('[' + self.attr_name() + '].open');\n\t\n\t        if (typeof modal.data('css-top') === 'undefined') {\n\t          modal.data('css-top', parseInt(modal.css('top'), 10))\n\t            .data('offset', this.cache_offset(modal));\n\t        }\n\t\n\t        modal.attr('tabindex','0').attr('aria-hidden','false');\n\t\n\t        this.key_up_on(modal);    // PATCH #3: turning on key up capture only when a reveal window is open\n\t\n\t        // Prevent namespace event from triggering twice\n\t        modal.on('open.fndtn.reveal', function(e) {\n\t          if (e.namespace !== 'fndtn.reveal') return;\n\t        });\n\t\n\t        modal.on('open.fndtn.reveal').trigger('open.fndtn.reveal');\n\t\n\t        if (open_modal.length < 1) {\n\t          this.toggle_bg(modal, true);\n\t        }\n\t\n\t        if (typeof ajax_settings === 'string') {\n\t          ajax_settings = {\n\t            url : ajax_settings\n\t          };\n\t        }\n\t\n\t        var openModal = function() {\n\t          if(open_modal.length > 0) {\n\t            if(settings.multiple_opened) {\n\t              self.to_back(open_modal);\n\t            } else {\n\t              self.hide(open_modal, settings.css.close);\n\t            }\n\t          }\n\t\n\t          // bl: add the open_modal that isn't already in the background to the openModals array\n\t          if(settings.multiple_opened) {\n\t            openModals.push(modal);\n\t          }\n\t\n\t          self.show(modal, settings.css.open);\n\t        };\n\t\n\t        if (typeof ajax_settings === 'undefined' || !ajax_settings.url) {\n\t          openModal();\n\t        } else {\n\t          var old_success = typeof ajax_settings.success !== 'undefined' ? ajax_settings.success : null;\n\t          $.extend(ajax_settings, {\n\t            success : function (data, textStatus, jqXHR) {\n\t              if ( $.isFunction(old_success) ) {\n\t                var result = old_success(data, textStatus, jqXHR);\n\t                if (typeof result == 'string') {\n\t                  data = result;\n\t                }\n\t              }\n\t\n\t              if (typeof options !== 'undefined' && typeof options.replaceContentSel !== 'undefined') {\n\t                modal.find(options.replaceContentSel).html(data);\n\t              } else {\n\t                modal.html(data);\n\t              }\n\t\n\t              self.S(modal).foundation('section', 'reflow');\n\t              self.S(modal).children().foundation();\n\t\n\t              openModal();\n\t            }\n\t          });\n\t\n\t          // check for if user initalized with error callback\n\t          if (settings.on_ajax_error !== $.noop) {\n\t            $.extend(ajax_settings, {\n\t              error : settings.on_ajax_error\n\t            });\n\t          }\n\t\n\t          $.ajax(ajax_settings);\n\t        }\n\t      }\n\t      self.S(window).trigger('resize');\n\t    },\n\t\n\t    close : function (modal) {\n\t      var modal = modal && modal.length ? modal : this.S(this.scope),\n\t          open_modals = this.S('[' + this.attr_name() + '].open'),\n\t          settings = modal.data(this.attr_name(true) + '-init') || this.settings,\n\t          self = this;\n\t\n\t      if (open_modals.length > 0) {\n\t\n\t        modal.removeAttr('tabindex','0').attr('aria-hidden','true');\n\t\n\t        this.locked = true;\n\t        this.key_up_off(modal);   // PATCH #3: turning on key up capture only when a reveal window is open\n\t\n\t        modal.trigger('close.fndtn.reveal');\n\t\n\t        if ((settings.multiple_opened && open_modals.length === 1) || !settings.multiple_opened || modal.length > 1) {\n\t          self.toggle_bg(modal, false);\n\t          self.to_front(modal);\n\t        }\n\t\n\t        if (settings.multiple_opened) {\n\t          var isCurrent = modal.is(':not(.toback)');\n\t          self.hide(modal, settings.css.close, settings);\n\t          if(isCurrent) {\n\t            // remove the last modal since it is now closed\n\t            openModals.pop();\n\t          } else {\n\t            // if this isn't the current modal, then find it in the array and remove it\n\t            openModals = $.grep(openModals, function(elt) {\n\t              var isThis = elt[0]===modal[0];\n\t              if(isThis) {\n\t                // since it's not currently in the front, put it in the front now that it is hidden\n\t                // so that if it's re-opened, it won't be .toback\n\t                self.to_front(modal);\n\t              }\n\t              return !isThis;\n\t            });\n\t          }\n\t          // finally, show the next modal in the stack, if there is one\n\t          if(openModals.length>0) {\n\t            self.to_front(openModals[openModals.length - 1]);\n\t          }\n\t        } else {\n\t          self.hide(open_modals, settings.css.close, settings);\n\t        }\n\t      }\n\t    },\n\t\n\t    close_targets : function () {\n\t      var base = '.' + this.settings.dismiss_modal_class;\n\t\n\t      if (this.settings.close_on_background_click) {\n\t        return base + ', .' + this.settings.bg_class;\n\t      }\n\t\n\t      return base;\n\t    },\n\t\n\t    toggle_bg : function (modal, state) {\n\t      if (this.S('.' + this.settings.bg_class).length === 0) {\n\t        this.settings.bg = $('<div />', {'class': this.settings.bg_class})\n\t          .appendTo('body').hide();\n\t      }\n\t\n\t      var visible = this.settings.bg.filter(':visible').length > 0;\n\t      if ( state != visible ) {\n\t        if ( state == undefined ? visible : !state ) {\n\t          this.hide(this.settings.bg);\n\t        } else {\n\t          this.show(this.settings.bg);\n\t        }\n\t      }\n\t    },\n\t\n\t    show : function (el, css) {\n\t      // is modal\n\t      if (css) {\n\t        var settings = el.data(this.attr_name(true) + '-init') || this.settings,\n\t            root_element = settings.root_element,\n\t            context = this;\n\t\n\t        if (el.parent(root_element).length === 0) {\n\t          var placeholder = el.wrap('<div style=\"display: none;\" />').parent();\n\t\n\t          el.on('closed.fndtn.reveal.wrapped', function () {\n\t            el.detach().appendTo(placeholder);\n\t            el.unwrap().unbind('closed.fndtn.reveal.wrapped');\n\t          });\n\t\n\t          el.detach().appendTo(root_element);\n\t        }\n\t\n\t        var animData = getAnimationData(settings.animation);\n\t        if (!animData.animate) {\n\t          this.locked = false;\n\t        }\n\t        if (animData.pop) {\n\t          css.top = $(window).scrollTop() - el.data('offset') + 'px';\n\t          var end_css = {\n\t            top: $(window).scrollTop() + el.data('css-top') + 'px',\n\t            opacity: 1\n\t          };\n\t\n\t          return setTimeout(function () {\n\t            return el\n\t              .css(css)\n\t              .animate(end_css, settings.animation_speed, 'linear', function () {\n\t                context.locked = false;\n\t                el.trigger('opened.fndtn.reveal');\n\t              })\n\t              .addClass('open');\n\t          }, settings.animation_speed / 2);\n\t        }\n\t\n\t        css.top = $(window).scrollTop() + el.data('css-top') + 'px';\n\t\n\t        if (animData.fade) {\n\t          var end_css = {opacity: 1};\n\t\n\t          return setTimeout(function () {\n\t            return el\n\t              .css(css)\n\t              .animate(end_css, settings.animation_speed, 'linear', function () {\n\t                context.locked = false;\n\t                el.trigger('opened.fndtn.reveal');\n\t              })\n\t              .addClass('open');\n\t          }, settings.animation_speed / 2);\n\t        }\n\t\n\t        return el.css(css).show().css({opacity : 1}).addClass('open').trigger('opened.fndtn.reveal');\n\t      }\n\t\n\t      var settings = this.settings;\n\t\n\t      // should we animate the background?\n\t      if (getAnimationData(settings.animation).fade) {\n\t        return el.fadeIn(settings.animation_speed / 2);\n\t      }\n\t\n\t      this.locked = false;\n\t\n\t      return el.show();\n\t    },\n\t\n\t    to_back : function(el) {\n\t      el.addClass('toback');\n\t    },\n\t\n\t    to_front : function(el) {\n\t      el.removeClass('toback');\n\t    },\n\t\n\t    hide : function (el, css) {\n\t      // is modal\n\t      if (css) {\n\t        var settings = el.data(this.attr_name(true) + '-init'),\n\t            context = this;\n\t        settings = settings || this.settings;\n\t\n\t        var animData = getAnimationData(settings.animation);\n\t        if (!animData.animate) {\n\t          this.locked = false;\n\t        }\n\t        if (animData.pop) {\n\t          var end_css = {\n\t            top: - $(window).scrollTop() - el.data('offset') + 'px',\n\t            opacity: 0\n\t          };\n\t\n\t          return setTimeout(function () {\n\t            return el\n\t              .animate(end_css, settings.animation_speed, 'linear', function () {\n\t                context.locked = false;\n\t                el.css(css).trigger('closed.fndtn.reveal');\n\t              })\n\t              .removeClass('open');\n\t          }, settings.animation_speed / 2);\n\t        }\n\t\n\t        if (animData.fade) {\n\t          var end_css = {opacity : 0};\n\t\n\t          return setTimeout(function () {\n\t            return el\n\t              .animate(end_css, settings.animation_speed, 'linear', function () {\n\t                context.locked = false;\n\t                el.css(css).trigger('closed.fndtn.reveal');\n\t              })\n\t              .removeClass('open');\n\t          }, settings.animation_speed / 2);\n\t        }\n\t\n\t        return el.hide().css(css).removeClass('open').trigger('closed.fndtn.reveal');\n\t      }\n\t\n\t      var settings = this.settings;\n\t\n\t      // should we animate the background?\n\t      if (getAnimationData(settings.animation).fade) {\n\t        return el.fadeOut(settings.animation_speed / 2);\n\t      }\n\t\n\t      return el.hide();\n\t    },\n\t\n\t    close_video : function (e) {\n\t      var video = $('.flex-video', e.target),\n\t          iframe = $('iframe', video);\n\t\n\t      if (iframe.length > 0) {\n\t        iframe.attr('data-src', iframe[0].src);\n\t        iframe.attr('src', iframe.attr('src'));\n\t        video.hide();\n\t      }\n\t    },\n\t\n\t    open_video : function (e) {\n\t      var video = $('.flex-video', e.target),\n\t          iframe = video.find('iframe');\n\t\n\t      if (iframe.length > 0) {\n\t        var data_src = iframe.attr('data-src');\n\t        if (typeof data_src === 'string') {\n\t          iframe[0].src = iframe.attr('data-src');\n\t        } else {\n\t          var src = iframe[0].src;\n\t          iframe[0].src = undefined;\n\t          iframe[0].src = src;\n\t        }\n\t        video.show();\n\t      }\n\t    },\n\t\n\t    data_attr : function (str) {\n\t      if (this.namespace.length > 0) {\n\t        return this.namespace + '-' + str;\n\t      }\n\t\n\t      return str;\n\t    },\n\t\n\t    cache_offset : function (modal) {\n\t      var offset = modal.show().height() + parseInt(modal.css('top'), 10) + modal.scrollY;\n\t\n\t      modal.hide();\n\t\n\t      return offset;\n\t    },\n\t\n\t    off : function () {\n\t      $(this.scope).off('.fndtn.reveal');\n\t    },\n\t\n\t    reflow : function () {}\n\t  };\n\t\n\t  /*\n\t   * getAnimationData('popAndFade') // {animate: true,  pop: true,  fade: true}\n\t   * getAnimationData('fade')       // {animate: true,  pop: false, fade: true}\n\t   * getAnimationData('pop')        // {animate: true,  pop: true,  fade: false}\n\t   * getAnimationData('foo')        // {animate: false, pop: false, fade: false}\n\t   * getAnimationData(null)         // {animate: false, pop: false, fade: false}\n\t   */\n\t  function getAnimationData(str) {\n\t    var fade = /fade/i.test(str);\n\t    var pop = /pop/i.test(str);\n\t    return {\n\t      animate : fade || pop,\n\t      pop : pop,\n\t      fade : fade\n\t    };\n\t  }\n\t}(jQuery, window, window.document));\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t;(function ($, window, document, undefined) {\n\t  'use strict';\n\t\n\t  Foundation.libs.tab = {\n\t    name : 'tab',\n\t\n\t    version : '5.5.3',\n\t\n\t    settings : {\n\t      active_class : 'active',\n\t      callback : function () {},\n\t      deep_linking : false,\n\t      scroll_to_content : true,\n\t      is_hover : false\n\t    },\n\t\n\t    default_tab_hashes : [],\n\t\n\t    init : function (scope, method, options) {\n\t      var self = this,\n\t          S = this.S;\n\t\n\t  \t  // Store the default active tabs which will be referenced when the\n\t  \t  // location hash is absent, as in the case of navigating the tabs and\n\t  \t  // returning to the first viewing via the browser Back button.\n\t  \t  S('[' + this.attr_name() + '] > .active > a', this.scope).each(function () {\n\t  \t    self.default_tab_hashes.push(this.hash);\n\t  \t  });\n\t\n\t      this.bindings(method, options);\n\t      this.handle_location_hash_change();\n\t    },\n\t\n\t    events : function () {\n\t      var self = this,\n\t          S = this.S;\n\t\n\t      var usual_tab_behavior =  function (e, target) {\n\t        var settings = S(target).closest('[' + self.attr_name() + ']').data(self.attr_name(true) + '-init');\n\t        if (!settings.is_hover || Modernizr.touch) {\n\t          // if user did not pressed tab key, prevent default action\n\t          var keyCode = e.keyCode || e.which;\n\t          if (keyCode !== 9) { \n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t          }\n\t          self.toggle_active_tab(S(target).parent());\n\t          \n\t        }\n\t      };\n\t\n\t      S(this.scope)\n\t        .off('.tab')\n\t        // Key event: focus/tab key\n\t        .on('keydown.fndtn.tab', '[' + this.attr_name() + '] > * > a', function(e) {\n\t          var keyCode = e.keyCode || e.which;\n\t          // if user pressed tab key\n\t          if (keyCode === 13 || keyCode === 32) { // enter or space\n\t            var el = this;\n\t            usual_tab_behavior(e, el);\n\t          } \n\t        })\n\t        // Click event: tab title\n\t        .on('click.fndtn.tab', '[' + this.attr_name() + '] > * > a', function(e) {\n\t          var el = this;\n\t          usual_tab_behavior(e, el);\n\t        })\n\t        // Hover event: tab title\n\t        .on('mouseenter.fndtn.tab', '[' + this.attr_name() + '] > * > a', function (e) {\n\t          var settings = S(this).closest('[' + self.attr_name() + ']').data(self.attr_name(true) + '-init');\n\t          if (settings.is_hover) {\n\t            self.toggle_active_tab(S(this).parent());\n\t          }\n\t        });\n\t\n\t      // Location hash change event\n\t      S(window).on('hashchange.fndtn.tab', function (e) {\n\t        e.preventDefault();\n\t        self.handle_location_hash_change();\n\t      });\n\t    },\n\t\n\t    handle_location_hash_change : function () {\n\t\n\t      var self = this,\n\t          S = this.S;\n\t\n\t      S('[' + this.attr_name() + ']', this.scope).each(function () {\n\t        var settings = S(this).data(self.attr_name(true) + '-init');\n\t        if (settings.deep_linking) {\n\t          // Match the location hash to a label\n\t          var hash;\n\t          if (settings.scroll_to_content) {\n\t            hash = self.scope.location.hash;\n\t          } else {\n\t            // prefix the hash to prevent anchor scrolling\n\t            hash = self.scope.location.hash.replace('fndtn-', '');\n\t          }\n\t          if (hash != '') {\n\t            // Check whether the location hash references a tab content div or\n\t            // another element on the page (inside or outside the tab content div)\n\t            var hash_element = S(hash);\n\t            if (hash_element.hasClass('content') && hash_element.parent().hasClass('tabs-content')) {\n\t              // Tab content div\n\t              self.toggle_active_tab($('[' + self.attr_name() + '] > * > a[href=' + hash + ']').parent());\n\t            } else {\n\t              // Not the tab content div. If inside the tab content, find the\n\t              // containing tab and toggle it as active.\n\t              var hash_tab_container_id = hash_element.closest('.content').attr('id');\n\t              if (hash_tab_container_id != undefined) {\n\t                self.toggle_active_tab($('[' + self.attr_name() + '] > * > a[href=#' + hash_tab_container_id + ']').parent(), hash);\n\t              }\n\t            }\n\t          } else {\n\t            // Reference the default tab hashes which were initialized in the init function\n\t            for (var ind = 0; ind < self.default_tab_hashes.length; ind++) {\n\t              self.toggle_active_tab($('[' + self.attr_name() + '] > * > a[href=' + self.default_tab_hashes[ind] + ']').parent());\n\t            }\n\t          }\n\t        }\n\t       });\n\t     },\n\t\n\t    toggle_active_tab : function (tab, location_hash) {\n\t      var self = this,\n\t          S = self.S,\n\t          tabs = tab.closest('[' + this.attr_name() + ']'),\n\t          tab_link = tab.find('a'),\n\t          anchor = tab.children('a').first(),\n\t          target_hash = '#' + anchor.attr('href').split('#')[1],\n\t          target = S(target_hash),\n\t          siblings = tab.siblings(),\n\t          settings = tabs.data(this.attr_name(true) + '-init'),\n\t          interpret_keyup_action = function (e) {\n\t            // Light modification of Heydon Pickering's Practical ARIA Examples: http://heydonworks.com/practical_aria_examples/js/a11y.js\n\t\n\t            // define current, previous and next (possible) tabs\n\t\n\t            var $original = $(this);\n\t            var $prev = $(this).parents('li').prev().children('[role=\"tab\"]');\n\t            var $next = $(this).parents('li').next().children('[role=\"tab\"]');\n\t            var $target;\n\t\n\t            // find the direction (prev or next)\n\t\n\t            switch (e.keyCode) {\n\t              case 37:\n\t                $target = $prev;\n\t                break;\n\t              case 39:\n\t                $target = $next;\n\t                break;\n\t              default:\n\t                $target = false\n\t                  break;\n\t            }\n\t\n\t            if ($target.length) {\n\t              $original.attr({\n\t                'tabindex' : '-1',\n\t                'aria-selected' : null\n\t              });\n\t              $target.attr({\n\t                'tabindex' : '0',\n\t                'aria-selected' : true\n\t              }).focus();\n\t            }\n\t\n\t            // Hide panels\n\t\n\t            $('[role=\"tabpanel\"]')\n\t              .attr('aria-hidden', 'true');\n\t\n\t            // Show panel which corresponds to target\n\t\n\t            $('#' + $(document.activeElement).attr('href').substring(1))\n\t              .attr('aria-hidden', null);\n\t\n\t          },\n\t          go_to_hash = function(hash) {\n\t            // This function allows correct behaviour of the browser's back button when deep linking is enabled. Without it\n\t            // the user would get continually redirected to the default hash.\n\t            var default_hash = settings.scroll_to_content ? self.default_tab_hashes[0] : 'fndtn-' + self.default_tab_hashes[0].replace('#', '');\n\t\n\t            if (hash !== default_hash || window.location.hash) {\n\t              window.location.hash = hash;\n\t            }\n\t          };\n\t\n\t      // allow usage of data-tab-content attribute instead of href\n\t      if (anchor.data('tab-content')) {\n\t        target_hash = '#' + anchor.data('tab-content').split('#')[1];\n\t        target = S(target_hash);\n\t      }\n\t\n\t      if (settings.deep_linking) {\n\t\n\t        if (settings.scroll_to_content) {\n\t\n\t          // retain current hash to scroll to content\n\t          go_to_hash(location_hash || target_hash);\n\t\n\t          if (location_hash == undefined || location_hash == target_hash) {\n\t            tab.parent()[0].scrollIntoView();\n\t          } else {\n\t            S(target_hash)[0].scrollIntoView();\n\t          }\n\t        } else {\n\t          // prefix the hashes so that the browser doesn't scroll down\n\t          if (location_hash != undefined) {\n\t            go_to_hash('fndtn-' + location_hash.replace('#', ''));\n\t          } else {\n\t            go_to_hash('fndtn-' + target_hash.replace('#', ''));\n\t          }\n\t        }\n\t      }\n\t\n\t      // WARNING: The activation and deactivation of the tab content must\n\t      // occur after the deep linking in order to properly refresh the browser\n\t      // window (notably in Chrome).\n\t      // Clean up multiple attr instances to done once\n\t      tab.addClass(settings.active_class).triggerHandler('opened');\n\t      tab_link.attr({'aria-selected' : 'true',  tabindex : 0});\n\t      siblings.removeClass(settings.active_class)\n\t      siblings.find('a').attr({'aria-selected' : 'false'/*,  tabindex : -1*/});\n\t      target.siblings().removeClass(settings.active_class).attr({'aria-hidden' : 'true'/*,  tabindex : -1*/});\n\t      target.addClass(settings.active_class).attr('aria-hidden', 'false').removeAttr('tabindex');\n\t      settings.callback(tab);\n\t      target.triggerHandler('toggled', [target]);\n\t      tabs.triggerHandler('toggled', [tab]);\n\t\n\t      tab_link.off('keydown').on('keydown', interpret_keyup_action );\n\t    },\n\t\n\t    data_attr : function (str) {\n\t      if (this.namespace.length > 0) {\n\t        return this.namespace + '-' + str;\n\t      }\n\t\n\t      return str;\n\t    },\n\t\n\t    off : function () {},\n\t\n\t    reflow : function () {}\n\t  };\n\t}(jQuery, window, window.document));\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// TODO actually recognize syntax of TypeScript constructs\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(13));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n\t  var indentUnit = config.indentUnit;\n\t  var statementIndent = parserConfig.statementIndent;\n\t  var jsonldMode = parserConfig.jsonld;\n\t  var jsonMode = parserConfig.json || jsonldMode;\n\t  var isTS = parserConfig.typescript;\n\t  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\t\n\t  // Tokenizer\n\t\n\t  var keywords = function(){\n\t    function kw(type) {return {type: type, style: \"keyword\"};}\n\t    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n\t    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\t\n\t    var jsKeywords = {\n\t      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n\t      \"return\": C, \"break\": C, \"continue\": C, \"new\": kw(\"new\"), \"delete\": C, \"throw\": C, \"debugger\": C,\n\t      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n\t      \"async\": kw(\"async\"), \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n\t      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n\t      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n\t      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n\t      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n\t      \"await\": C, \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C\n\t    };\n\t\n\t    // Extend the 'normal' keywords with the TypeScript language extensions\n\t    if (isTS) {\n\t      var type = {type: \"variable\", style: \"variable-3\"};\n\t      var tsKeywords = {\n\t        // object-like things\n\t        \"interface\": kw(\"interface\"),\n\t        \"extends\": kw(\"extends\"),\n\t        \"constructor\": kw(\"constructor\"),\n\t\n\t        // scope modifiers\n\t        \"public\": kw(\"public\"),\n\t        \"private\": kw(\"private\"),\n\t        \"protected\": kw(\"protected\"),\n\t        \"static\": kw(\"static\"),\n\t\n\t        // types\n\t        \"string\": type, \"number\": type, \"boolean\": type, \"any\": type\n\t      };\n\t\n\t      for (var attr in tsKeywords) {\n\t        jsKeywords[attr] = tsKeywords[attr];\n\t      }\n\t    }\n\t\n\t    return jsKeywords;\n\t  }();\n\t\n\t  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n\t  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\t\n\t  function readRegexp(stream) {\n\t    var escaped = false, next, inSet = false;\n\t    while ((next = stream.next()) != null) {\n\t      if (!escaped) {\n\t        if (next == \"/\" && !inSet) return;\n\t        if (next == \"[\") inSet = true;\n\t        else if (inSet && next == \"]\") inSet = false;\n\t      }\n\t      escaped = !escaped && next == \"\\\\\";\n\t    }\n\t  }\n\t\n\t  // Used as scratch variables to communicate multiple values without\n\t  // consing up tons of objects.\n\t  var type, content;\n\t  function ret(tp, style, cont) {\n\t    type = tp; content = cont;\n\t    return style;\n\t  }\n\t  function tokenBase(stream, state) {\n\t    var ch = stream.next();\n\t    if (ch == '\"' || ch == \"'\") {\n\t      state.tokenize = tokenString(ch);\n\t      return state.tokenize(stream, state);\n\t    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n\t      return ret(\"number\", \"number\");\n\t    } else if (ch == \".\" && stream.match(\"..\")) {\n\t      return ret(\"spread\", \"meta\");\n\t    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n\t      return ret(ch);\n\t    } else if (ch == \"=\" && stream.eat(\">\")) {\n\t      return ret(\"=>\", \"operator\");\n\t    } else if (ch == \"0\" && stream.eat(/x/i)) {\n\t      stream.eatWhile(/[\\da-f]/i);\n\t      return ret(\"number\", \"number\");\n\t    } else if (ch == \"0\" && stream.eat(/o/i)) {\n\t      stream.eatWhile(/[0-7]/i);\n\t      return ret(\"number\", \"number\");\n\t    } else if (ch == \"0\" && stream.eat(/b/i)) {\n\t      stream.eatWhile(/[01]/i);\n\t      return ret(\"number\", \"number\");\n\t    } else if (/\\d/.test(ch)) {\n\t      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n\t      return ret(\"number\", \"number\");\n\t    } else if (ch == \"/\") {\n\t      if (stream.eat(\"*\")) {\n\t        state.tokenize = tokenComment;\n\t        return tokenComment(stream, state);\n\t      } else if (stream.eat(\"/\")) {\n\t        stream.skipToEnd();\n\t        return ret(\"comment\", \"comment\");\n\t      } else if (state.lastType == \"operator\" || state.lastType == \"keyword c\" ||\n\t                 state.lastType == \"sof\" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n\t        readRegexp(stream);\n\t        stream.match(/^\\b(([gimyu])(?![gimyu]*\\2))+\\b/);\n\t        return ret(\"regexp\", \"string-2\");\n\t      } else {\n\t        stream.eatWhile(isOperatorChar);\n\t        return ret(\"operator\", \"operator\", stream.current());\n\t      }\n\t    } else if (ch == \"`\") {\n\t      state.tokenize = tokenQuasi;\n\t      return tokenQuasi(stream, state);\n\t    } else if (ch == \"#\") {\n\t      stream.skipToEnd();\n\t      return ret(\"error\", \"error\");\n\t    } else if (isOperatorChar.test(ch)) {\n\t      stream.eatWhile(isOperatorChar);\n\t      return ret(\"operator\", \"operator\", stream.current());\n\t    } else if (wordRE.test(ch)) {\n\t      stream.eatWhile(wordRE);\n\t      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n\t      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n\t                     ret(\"variable\", \"variable\", word);\n\t    }\n\t  }\n\t\n\t  function tokenString(quote) {\n\t    return function(stream, state) {\n\t      var escaped = false, next;\n\t      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n\t        state.tokenize = tokenBase;\n\t        return ret(\"jsonld-keyword\", \"meta\");\n\t      }\n\t      while ((next = stream.next()) != null) {\n\t        if (next == quote && !escaped) break;\n\t        escaped = !escaped && next == \"\\\\\";\n\t      }\n\t      if (!escaped) state.tokenize = tokenBase;\n\t      return ret(\"string\", \"string\");\n\t    };\n\t  }\n\t\n\t  function tokenComment(stream, state) {\n\t    var maybeEnd = false, ch;\n\t    while (ch = stream.next()) {\n\t      if (ch == \"/\" && maybeEnd) {\n\t        state.tokenize = tokenBase;\n\t        break;\n\t      }\n\t      maybeEnd = (ch == \"*\");\n\t    }\n\t    return ret(\"comment\", \"comment\");\n\t  }\n\t\n\t  function tokenQuasi(stream, state) {\n\t    var escaped = false, next;\n\t    while ((next = stream.next()) != null) {\n\t      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n\t        state.tokenize = tokenBase;\n\t        break;\n\t      }\n\t      escaped = !escaped && next == \"\\\\\";\n\t    }\n\t    return ret(\"quasi\", \"string-2\", stream.current());\n\t  }\n\t\n\t  var brackets = \"([{}])\";\n\t  // This is a crude lookahead trick to try and notice that we're\n\t  // parsing the argument patterns for a fat-arrow function before we\n\t  // actually hit the arrow token. It only works if the arrow is on\n\t  // the same line as the arguments and there's no strange noise\n\t  // (comments) in between. Fallback is to only notice when we hit the\n\t  // arrow, and not declare the arguments as locals for the arrow\n\t  // body.\n\t  function findFatArrow(stream, state) {\n\t    if (state.fatArrowAt) state.fatArrowAt = null;\n\t    var arrow = stream.string.indexOf(\"=>\", stream.start);\n\t    if (arrow < 0) return;\n\t\n\t    var depth = 0, sawSomething = false;\n\t    for (var pos = arrow - 1; pos >= 0; --pos) {\n\t      var ch = stream.string.charAt(pos);\n\t      var bracket = brackets.indexOf(ch);\n\t      if (bracket >= 0 && bracket < 3) {\n\t        if (!depth) { ++pos; break; }\n\t        if (--depth == 0) break;\n\t      } else if (bracket >= 3 && bracket < 6) {\n\t        ++depth;\n\t      } else if (wordRE.test(ch)) {\n\t        sawSomething = true;\n\t      } else if (/[\"'\\/]/.test(ch)) {\n\t        return;\n\t      } else if (sawSomething && !depth) {\n\t        ++pos;\n\t        break;\n\t      }\n\t    }\n\t    if (sawSomething && !depth) state.fatArrowAt = pos;\n\t  }\n\t\n\t  // Parser\n\t\n\t  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\t\n\t  function JSLexical(indented, column, type, align, prev, info) {\n\t    this.indented = indented;\n\t    this.column = column;\n\t    this.type = type;\n\t    this.prev = prev;\n\t    this.info = info;\n\t    if (align != null) this.align = align;\n\t  }\n\t\n\t  function inScope(state, varname) {\n\t    for (var v = state.localVars; v; v = v.next)\n\t      if (v.name == varname) return true;\n\t    for (var cx = state.context; cx; cx = cx.prev) {\n\t      for (var v = cx.vars; v; v = v.next)\n\t        if (v.name == varname) return true;\n\t    }\n\t  }\n\t\n\t  function parseJS(state, style, type, content, stream) {\n\t    var cc = state.cc;\n\t    // Communicate our context to the combinators.\n\t    // (Less wasteful than consing up a hundred closures on every call.)\n\t    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\t\n\t    if (!state.lexical.hasOwnProperty(\"align\"))\n\t      state.lexical.align = true;\n\t\n\t    while(true) {\n\t      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n\t      if (combinator(type, content)) {\n\t        while(cc.length && cc[cc.length - 1].lex)\n\t          cc.pop()();\n\t        if (cx.marked) return cx.marked;\n\t        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n\t        return style;\n\t      }\n\t    }\n\t  }\n\t\n\t  // Combinator utils\n\t\n\t  var cx = {state: null, column: null, marked: null, cc: null};\n\t  function pass() {\n\t    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n\t  }\n\t  function cont() {\n\t    pass.apply(null, arguments);\n\t    return true;\n\t  }\n\t  function register(varname) {\n\t    function inList(list) {\n\t      for (var v = list; v; v = v.next)\n\t        if (v.name == varname) return true;\n\t      return false;\n\t    }\n\t    var state = cx.state;\n\t    cx.marked = \"def\";\n\t    if (state.context) {\n\t      if (inList(state.localVars)) return;\n\t      state.localVars = {name: varname, next: state.localVars};\n\t    } else {\n\t      if (inList(state.globalVars)) return;\n\t      if (parserConfig.globalVars)\n\t        state.globalVars = {name: varname, next: state.globalVars};\n\t    }\n\t  }\n\t\n\t  // Combinators\n\t\n\t  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n\t  function pushcontext() {\n\t    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n\t    cx.state.localVars = defaultVars;\n\t  }\n\t  function popcontext() {\n\t    cx.state.localVars = cx.state.context.vars;\n\t    cx.state.context = cx.state.context.prev;\n\t  }\n\t  function pushlex(type, info) {\n\t    var result = function() {\n\t      var state = cx.state, indent = state.indented;\n\t      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n\t      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n\t        indent = outer.indented;\n\t      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n\t    };\n\t    result.lex = true;\n\t    return result;\n\t  }\n\t  function poplex() {\n\t    var state = cx.state;\n\t    if (state.lexical.prev) {\n\t      if (state.lexical.type == \")\")\n\t        state.indented = state.lexical.indented;\n\t      state.lexical = state.lexical.prev;\n\t    }\n\t  }\n\t  poplex.lex = true;\n\t\n\t  function expect(wanted) {\n\t    function exp(type) {\n\t      if (type == wanted) return cont();\n\t      else if (wanted == \";\") return pass();\n\t      else return cont(exp);\n\t    };\n\t    return exp;\n\t  }\n\t\n\t  function statement(type, value) {\n\t    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n\t    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n\t    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n\t    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n\t    if (type == \";\") return cont();\n\t    if (type == \"if\") {\n\t      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n\t        cx.state.cc.pop()();\n\t      return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse);\n\t    }\n\t    if (type == \"function\") return cont(functiondef);\n\t    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n\t    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n\t    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n\t                                      block, poplex, poplex);\n\t    if (type == \"case\") return cont(expression, expect(\":\"));\n\t    if (type == \"default\") return cont(expect(\":\"));\n\t    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n\t                                     statement, poplex, popcontext);\n\t    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n\t    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n\t    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n\t    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n\t  }\n\t  function expression(type) {\n\t    return expressionInner(type, false);\n\t  }\n\t  function expressionNoComma(type) {\n\t    return expressionInner(type, true);\n\t  }\n\t  function expressionInner(type, noComma) {\n\t    if (cx.state.fatArrowAt == cx.stream.start) {\n\t      var body = noComma ? arrowBodyNoComma : arrowBody;\n\t      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\n\t      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n\t    }\n\t\n\t    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n\t    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n\t    if (type == \"async\") return cont(expression);\n\t    if (type == \"function\") return cont(functiondef, maybeop);\n\t    if (type == \"keyword c\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n\t    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, comprehension, expect(\")\"), poplex, maybeop);\n\t    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n\t    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n\t    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n\t    if (type == \"quasi\") return pass(quasi, maybeop);\n\t    if (type == \"new\") return cont(maybeTarget(noComma));\n\t    return cont();\n\t  }\n\t  function maybeexpression(type) {\n\t    if (type.match(/[;\\}\\)\\],]/)) return pass();\n\t    return pass(expression);\n\t  }\n\t  function maybeexpressionNoComma(type) {\n\t    if (type.match(/[;\\}\\)\\],]/)) return pass();\n\t    return pass(expressionNoComma);\n\t  }\n\t\n\t  function maybeoperatorComma(type, value) {\n\t    if (type == \",\") return cont(expression);\n\t    return maybeoperatorNoComma(type, value, false);\n\t  }\n\t  function maybeoperatorNoComma(type, value, noComma) {\n\t    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n\t    var expr = noComma == false ? expression : expressionNoComma;\n\t    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n\t    if (type == \"operator\") {\n\t      if (/\\+\\+|--/.test(value)) return cont(me);\n\t      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n\t      return cont(expr);\n\t    }\n\t    if (type == \"quasi\") { return pass(quasi, me); }\n\t    if (type == \";\") return;\n\t    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n\t    if (type == \".\") return cont(property, me);\n\t    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n\t  }\n\t  function quasi(type, value) {\n\t    if (type != \"quasi\") return pass();\n\t    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n\t    return cont(expression, continueQuasi);\n\t  }\n\t  function continueQuasi(type) {\n\t    if (type == \"}\") {\n\t      cx.marked = \"string-2\";\n\t      cx.state.tokenize = tokenQuasi;\n\t      return cont(quasi);\n\t    }\n\t  }\n\t  function arrowBody(type) {\n\t    findFatArrow(cx.stream, cx.state);\n\t    return pass(type == \"{\" ? statement : expression);\n\t  }\n\t  function arrowBodyNoComma(type) {\n\t    findFatArrow(cx.stream, cx.state);\n\t    return pass(type == \"{\" ? statement : expressionNoComma);\n\t  }\n\t  function maybeTarget(noComma) {\n\t    return function(type) {\n\t      if (type == \".\") return cont(noComma ? targetNoComma : target);\n\t      else return pass(noComma ? expressionNoComma : expression);\n\t    };\n\t  }\n\t  function target(_, value) {\n\t    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n\t  }\n\t  function targetNoComma(_, value) {\n\t    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n\t  }\n\t  function maybelabel(type) {\n\t    if (type == \":\") return cont(poplex, statement);\n\t    return pass(maybeoperatorComma, expect(\";\"), poplex);\n\t  }\n\t  function property(type) {\n\t    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n\t  }\n\t  function objprop(type, value) {\n\t    if (type == \"async\") {\n\t      return cont(objprop);\n\t    } else if (type == \"variable\" || cx.style == \"keyword\") {\n\t      cx.marked = \"property\";\n\t      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n\t      return cont(afterprop);\n\t    } else if (type == \"number\" || type == \"string\") {\n\t      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n\t      return cont(afterprop);\n\t    } else if (type == \"jsonld-keyword\") {\n\t      return cont(afterprop);\n\t    } else if (type == \"[\") {\n\t      return cont(expression, expect(\"]\"), afterprop);\n\t    }\n\t  }\n\t  function getterSetter(type) {\n\t    if (type != \"variable\") return pass(afterprop);\n\t    cx.marked = \"property\";\n\t    return cont(functiondef);\n\t  }\n\t  function afterprop(type) {\n\t    if (type == \":\") return cont(expressionNoComma);\n\t    if (type == \"(\") return pass(functiondef);\n\t  }\n\t  function commasep(what, end) {\n\t    function proceed(type) {\n\t      if (type == \",\") {\n\t        var lex = cx.state.lexical;\n\t        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n\t        return cont(what, proceed);\n\t      }\n\t      if (type == end) return cont();\n\t      return cont(expect(end));\n\t    }\n\t    return function(type) {\n\t      if (type == end) return cont();\n\t      return pass(what, proceed);\n\t    };\n\t  }\n\t  function contCommasep(what, end, info) {\n\t    for (var i = 3; i < arguments.length; i++)\n\t      cx.cc.push(arguments[i]);\n\t    return cont(pushlex(end, info), commasep(what, end), poplex);\n\t  }\n\t  function block(type) {\n\t    if (type == \"}\") return cont();\n\t    return pass(statement, block);\n\t  }\n\t  function maybetype(type) {\n\t    if (isTS && type == \":\") return cont(typedef);\n\t  }\n\t  function maybedefault(_, value) {\n\t    if (value == \"=\") return cont(expressionNoComma);\n\t  }\n\t  function typedef(type) {\n\t    if (type == \"variable\") {cx.marked = \"variable-3\"; return cont();}\n\t  }\n\t  function vardef() {\n\t    return pass(pattern, maybetype, maybeAssign, vardefCont);\n\t  }\n\t  function pattern(type, value) {\n\t    if (type == \"variable\") { register(value); return cont(); }\n\t    if (type == \"spread\") return cont(pattern);\n\t    if (type == \"[\") return contCommasep(pattern, \"]\");\n\t    if (type == \"{\") return contCommasep(proppattern, \"}\");\n\t  }\n\t  function proppattern(type, value) {\n\t    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n\t      register(value);\n\t      return cont(maybeAssign);\n\t    }\n\t    if (type == \"variable\") cx.marked = \"property\";\n\t    if (type == \"spread\") return cont(pattern);\n\t    return cont(expect(\":\"), pattern, maybeAssign);\n\t  }\n\t  function maybeAssign(_type, value) {\n\t    if (value == \"=\") return cont(expressionNoComma);\n\t  }\n\t  function vardefCont(type) {\n\t    if (type == \",\") return cont(vardef);\n\t  }\n\t  function maybeelse(type, value) {\n\t    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n\t  }\n\t  function forspec(type) {\n\t    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n\t  }\n\t  function forspec1(type) {\n\t    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n\t    if (type == \";\") return cont(forspec2);\n\t    if (type == \"variable\") return cont(formaybeinof);\n\t    return pass(expression, expect(\";\"), forspec2);\n\t  }\n\t  function formaybeinof(_type, value) {\n\t    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n\t    return cont(maybeoperatorComma, forspec2);\n\t  }\n\t  function forspec2(type, value) {\n\t    if (type == \";\") return cont(forspec3);\n\t    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n\t    return pass(expression, expect(\";\"), forspec3);\n\t  }\n\t  function forspec3(type) {\n\t    if (type != \")\") cont(expression);\n\t  }\n\t  function functiondef(type, value) {\n\t    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n\t    if (type == \"variable\") {register(value); return cont(functiondef);}\n\t    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, statement, popcontext);\n\t  }\n\t  function funarg(type) {\n\t    if (type == \"spread\") return cont(funarg);\n\t    return pass(pattern, maybetype, maybedefault);\n\t  }\n\t  function className(type, value) {\n\t    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n\t  }\n\t  function classNameAfter(type, value) {\n\t    if (value == \"extends\") return cont(expression, classNameAfter);\n\t    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n\t  }\n\t  function classBody(type, value) {\n\t    if (type == \"variable\" || cx.style == \"keyword\") {\n\t      if (value == \"static\") {\n\t        cx.marked = \"keyword\";\n\t        return cont(classBody);\n\t      }\n\t      cx.marked = \"property\";\n\t      if (value == \"get\" || value == \"set\") return cont(classGetterSetter, functiondef, classBody);\n\t      return cont(functiondef, classBody);\n\t    }\n\t    if (value == \"*\") {\n\t      cx.marked = \"keyword\";\n\t      return cont(classBody);\n\t    }\n\t    if (type == \";\") return cont(classBody);\n\t    if (type == \"}\") return cont();\n\t  }\n\t  function classGetterSetter(type) {\n\t    if (type != \"variable\") return pass();\n\t    cx.marked = \"property\";\n\t    return cont();\n\t  }\n\t  function afterExport(_type, value) {\n\t    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n\t    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n\t    return pass(statement);\n\t  }\n\t  function afterImport(type) {\n\t    if (type == \"string\") return cont();\n\t    return pass(importSpec, maybeFrom);\n\t  }\n\t  function importSpec(type, value) {\n\t    if (type == \"{\") return contCommasep(importSpec, \"}\");\n\t    if (type == \"variable\") register(value);\n\t    if (value == \"*\") cx.marked = \"keyword\";\n\t    return cont(maybeAs);\n\t  }\n\t  function maybeAs(_type, value) {\n\t    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n\t  }\n\t  function maybeFrom(_type, value) {\n\t    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n\t  }\n\t  function arrayLiteral(type) {\n\t    if (type == \"]\") return cont();\n\t    return pass(expressionNoComma, maybeArrayComprehension);\n\t  }\n\t  function maybeArrayComprehension(type) {\n\t    if (type == \"for\") return pass(comprehension, expect(\"]\"));\n\t    if (type == \",\") return cont(commasep(maybeexpressionNoComma, \"]\"));\n\t    return pass(commasep(expressionNoComma, \"]\"));\n\t  }\n\t  function comprehension(type) {\n\t    if (type == \"for\") return cont(forspec, comprehension);\n\t    if (type == \"if\") return cont(expression, comprehension);\n\t  }\n\t\n\t  function isContinuedStatement(state, textAfter) {\n\t    return state.lastType == \"operator\" || state.lastType == \",\" ||\n\t      isOperatorChar.test(textAfter.charAt(0)) ||\n\t      /[,.]/.test(textAfter.charAt(0));\n\t  }\n\t\n\t  // Interface\n\t\n\t  return {\n\t    startState: function(basecolumn) {\n\t      var state = {\n\t        tokenize: tokenBase,\n\t        lastType: \"sof\",\n\t        cc: [],\n\t        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n\t        localVars: parserConfig.localVars,\n\t        context: parserConfig.localVars && {vars: parserConfig.localVars},\n\t        indented: 0\n\t      };\n\t      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n\t        state.globalVars = parserConfig.globalVars;\n\t      return state;\n\t    },\n\t\n\t    token: function(stream, state) {\n\t      if (stream.sol()) {\n\t        if (!state.lexical.hasOwnProperty(\"align\"))\n\t          state.lexical.align = false;\n\t        state.indented = stream.indentation();\n\t        findFatArrow(stream, state);\n\t      }\n\t      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n\t      var style = state.tokenize(stream, state);\n\t      if (type == \"comment\") return style;\n\t      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n\t      return parseJS(state, style, type, content, stream);\n\t    },\n\t\n\t    indent: function(state, textAfter) {\n\t      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n\t      if (state.tokenize != tokenBase) return 0;\n\t      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n\t      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n\t      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n\t        var c = state.cc[i];\n\t        if (c == poplex) lexical = lexical.prev;\n\t        else if (c != maybeelse) break;\n\t      }\n\t      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n\t      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n\t        lexical = lexical.prev;\n\t      var type = lexical.type, closing = firstChar == type;\n\t\n\t      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n\t      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n\t      else if (type == \"form\") return lexical.indented + indentUnit;\n\t      else if (type == \"stat\")\n\t        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n\t      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n\t        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n\t      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n\t      else return lexical.indented + (closing ? 0 : indentUnit);\n\t    },\n\t\n\t    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n\t    blockCommentStart: jsonMode ? null : \"/*\",\n\t    blockCommentEnd: jsonMode ? null : \"*/\",\n\t    lineComment: jsonMode ? null : \"//\",\n\t    fold: \"brace\",\n\t    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\t\n\t    helperType: jsonMode ? \"json\" : \"javascript\",\n\t    jsonldMode: jsonldMode,\n\t    jsonMode: jsonMode\n\t  };\n\t});\n\t\n\tCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\t\n\tCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\n\tCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\n\tCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\n\tCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\n\tCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\t\n\t});\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"CodeMirror\"] = __webpack_require__(14);\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// This is CodeMirror (http://codemirror.net), a code editor\n\t// implemented in JavaScript on top of the browser's DOM.\n\t//\n\t// You can find some technical background for some of the code below\n\t// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    module.exports = mod();\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    return define([], mod);\n\t  else // Plain browser env\n\t    this.CodeMirror = mod();\n\t})(function() {\n\t  \"use strict\";\n\t\n\t  // BROWSER SNIFFING\n\t\n\t  // Kludges for bugs and behavior differences that can't be feature\n\t  // detected are enabled based on userAgent etc sniffing.\n\t  var userAgent = navigator.userAgent;\n\t  var platform = navigator.platform;\n\t\n\t  var gecko = /gecko\\/\\d/i.test(userAgent);\n\t  var ie_upto10 = /MSIE \\d/.test(userAgent);\n\t  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n\t  var ie = ie_upto10 || ie_11up;\n\t  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n\t  var webkit = /WebKit\\//.test(userAgent);\n\t  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n\t  var chrome = /Chrome\\//.test(userAgent);\n\t  var presto = /Opera\\//.test(userAgent);\n\t  var safari = /Apple Computer/.test(navigator.vendor);\n\t  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n\t  var phantom = /PhantomJS/.test(userAgent);\n\t\n\t  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n\t  // This is woefully incomplete. Suggestions for alternative methods welcome.\n\t  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n\t  var mac = ios || /Mac/.test(platform);\n\t  var windows = /win/i.test(platform);\n\t\n\t  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n\t  if (presto_version) presto_version = Number(presto_version[1]);\n\t  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n\t  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n\t  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n\t  var captureRightClick = gecko || (ie && ie_version >= 9);\n\t\n\t  // Optimize some code when these features are not used.\n\t  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\t\n\t  // EDITOR CONSTRUCTOR\n\t\n\t  // A CodeMirror instance represents an editor. This is the object\n\t  // that user code is usually dealing with.\n\t\n\t  function CodeMirror(place, options) {\n\t    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\t\n\t    this.options = options = options ? copyObj(options) : {};\n\t    // Determine effective options based on given values and defaults.\n\t    copyObj(defaults, options, false);\n\t    setGuttersForLineNumbers(options);\n\t\n\t    var doc = options.value;\n\t    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n\t    this.doc = doc;\n\t\n\t    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n\t    var display = this.display = new Display(place, doc, input);\n\t    display.wrapper.CodeMirror = this;\n\t    updateGutters(this);\n\t    themeChanged(this);\n\t    if (options.lineWrapping)\n\t      this.display.wrapper.className += \" CodeMirror-wrap\";\n\t    if (options.autofocus && !mobile) display.input.focus();\n\t    initScrollbars(this);\n\t\n\t    this.state = {\n\t      keyMaps: [],  // stores maps added by addKeyMap\n\t      overlays: [], // highlighting overlays, as added by addOverlay\n\t      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n\t      overwrite: false,\n\t      delayingBlurEvent: false,\n\t      focused: false,\n\t      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n\t      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n\t      selectingText: false,\n\t      draggingText: false,\n\t      highlight: new Delayed(), // stores highlight worker timeout\n\t      keySeq: null,  // Unfinished key sequence\n\t      specialChars: null\n\t    };\n\t\n\t    var cm = this;\n\t\n\t    // Override magic textarea content restore that IE sometimes does\n\t    // on our hidden textarea on reload\n\t    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\t\n\t    registerEventHandlers(this);\n\t    ensureGlobalHandlers();\n\t\n\t    startOperation(this);\n\t    this.curOp.forceUpdate = true;\n\t    attachDoc(this, doc);\n\t\n\t    if ((options.autofocus && !mobile) || cm.hasFocus())\n\t      setTimeout(bind(onFocus, this), 20);\n\t    else\n\t      onBlur(this);\n\t\n\t    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n\t      optionHandlers[opt](this, options[opt], Init);\n\t    maybeUpdateLineNumberWidth(this);\n\t    if (options.finishInit) options.finishInit(this);\n\t    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n\t    endOperation(this);\n\t    // Suppress optimizelegibility in Webkit, since it breaks text\n\t    // measuring on line wrapping boundaries.\n\t    if (webkit && options.lineWrapping &&\n\t        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n\t      display.lineDiv.style.textRendering = \"auto\";\n\t  }\n\t\n\t  // DISPLAY CONSTRUCTOR\n\t\n\t  // The display handles the DOM integration, both for input reading\n\t  // and content drawing. It holds references to DOM nodes and\n\t  // display-related state.\n\t\n\t  function Display(place, doc, input) {\n\t    var d = this;\n\t    this.input = input;\n\t\n\t    // Covers bottom-right square when both scrollbars are present.\n\t    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n\t    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n\t    // and h scrollbar is present.\n\t    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n\t    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Will contain the actual code, positioned to cover the viewport.\n\t    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n\t    // Elements are added to these to represent selection and cursors.\n\t    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n\t    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n\t    // A visibility: hidden element used to find the size of things.\n\t    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // When lines outside of the viewport are measured, they are drawn in this.\n\t    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n\t    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n\t                      null, \"position: relative; outline: none\");\n\t    // Moved around its parent to cover visible view.\n\t    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n\t    // Set to the height of the document, allowing scrolling.\n\t    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n\t    d.sizerWidth = null;\n\t    // Behavior of elts with overflow: auto and padding is\n\t    // inconsistent across browsers. This is used to ensure the\n\t    // scrollable area is big enough.\n\t    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n\t    // Will contain the gutters, if any.\n\t    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n\t    d.lineGutter = null;\n\t    // Actual scrollable element.\n\t    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n\t    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n\t    // The element in which the editor lives.\n\t    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\t\n\t    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n\t    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n\t    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\t\n\t    if (place) {\n\t      if (place.appendChild) place.appendChild(d.wrapper);\n\t      else place(d.wrapper);\n\t    }\n\t\n\t    // Current rendered range (may be bigger than the view window).\n\t    d.viewFrom = d.viewTo = doc.first;\n\t    d.reportedViewFrom = d.reportedViewTo = doc.first;\n\t    // Information about the rendered lines.\n\t    d.view = [];\n\t    d.renderedView = null;\n\t    // Holds info about a single rendered line when it was rendered\n\t    // for measurement, while not in view.\n\t    d.externalMeasured = null;\n\t    // Empty space (in pixels) above the view\n\t    d.viewOffset = 0;\n\t    d.lastWrapHeight = d.lastWrapWidth = 0;\n\t    d.updateLineNumbers = null;\n\t\n\t    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n\t    d.scrollbarsClipped = false;\n\t\n\t    // Used to only resize the line number gutter when necessary (when\n\t    // the amount of lines crosses a boundary that makes its width change)\n\t    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n\t    // Set to true when a non-horizontal-scrolling line widget is\n\t    // added. As an optimization, line widget aligning is skipped when\n\t    // this is false.\n\t    d.alignWidgets = false;\n\t\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t\n\t    // Tracks the maximum line length so that the horizontal scrollbar\n\t    // can be kept static when scrolling.\n\t    d.maxLine = null;\n\t    d.maxLineLength = 0;\n\t    d.maxLineChanged = false;\n\t\n\t    // Used for measuring wheel scrolling granularity\n\t    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\t\n\t    // True when shift is held down.\n\t    d.shift = false;\n\t\n\t    // Used to track whether anything happened since the context menu\n\t    // was opened.\n\t    d.selForContextMenu = null;\n\t\n\t    d.activeTouch = null;\n\t\n\t    input.init(d);\n\t  }\n\t\n\t  // STATE UPDATES\n\t\n\t  // Used to get the editor into a consistent state again when options change.\n\t\n\t  function loadMode(cm) {\n\t    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n\t    resetModeState(cm);\n\t  }\n\t\n\t  function resetModeState(cm) {\n\t    cm.doc.iter(function(line) {\n\t      if (line.stateAfter) line.stateAfter = null;\n\t      if (line.styles) line.styles = null;\n\t    });\n\t    cm.doc.frontier = cm.doc.first;\n\t    startWorker(cm, 100);\n\t    cm.state.modeGen++;\n\t    if (cm.curOp) regChange(cm);\n\t  }\n\t\n\t  function wrappingChanged(cm) {\n\t    if (cm.options.lineWrapping) {\n\t      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      cm.display.sizer.style.minWidth = \"\";\n\t      cm.display.sizerWidth = null;\n\t    } else {\n\t      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      findMaxLine(cm);\n\t    }\n\t    estimateLineHeights(cm);\n\t    regChange(cm);\n\t    clearCaches(cm);\n\t    setTimeout(function(){updateScrollbars(cm);}, 100);\n\t  }\n\t\n\t  // Returns a function that estimates the height of a line, to use as\n\t  // first approximation until the line becomes visible (and is thus\n\t  // properly measurable).\n\t  function estimateHeight(cm) {\n\t    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n\t    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n\t    return function(line) {\n\t      if (lineIsHidden(cm.doc, line)) return 0;\n\t\n\t      var widgetsHeight = 0;\n\t      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n\t        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n\t      }\n\t\n\t      if (wrapping)\n\t        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n\t      else\n\t        return widgetsHeight + th;\n\t    };\n\t  }\n\t\n\t  function estimateLineHeights(cm) {\n\t    var doc = cm.doc, est = estimateHeight(cm);\n\t    doc.iter(function(line) {\n\t      var estHeight = est(line);\n\t      if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t    });\n\t  }\n\t\n\t  function themeChanged(cm) {\n\t    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n\t      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n\t    clearCaches(cm);\n\t  }\n\t\n\t  function guttersChanged(cm) {\n\t    updateGutters(cm);\n\t    regChange(cm);\n\t    setTimeout(function(){alignHorizontally(cm);}, 20);\n\t  }\n\t\n\t  // Rebuild the gutter elements, ensure the margin to the left of the\n\t  // code matches their width.\n\t  function updateGutters(cm) {\n\t    var gutters = cm.display.gutters, specs = cm.options.gutters;\n\t    removeChildren(gutters);\n\t    for (var i = 0; i < specs.length; ++i) {\n\t      var gutterClass = specs[i];\n\t      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n\t      if (gutterClass == \"CodeMirror-linenumbers\") {\n\t        cm.display.lineGutter = gElt;\n\t        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n\t      }\n\t    }\n\t    gutters.style.display = i ? \"\" : \"none\";\n\t    updateGutterSpace(cm);\n\t  }\n\t\n\t  function updateGutterSpace(cm) {\n\t    var width = cm.display.gutters.offsetWidth;\n\t    cm.display.sizer.style.marginLeft = width + \"px\";\n\t  }\n\t\n\t  // Compute the character length of a line, taking into account\n\t  // collapsed ranges (see markText) that might hide parts, and join\n\t  // other lines onto it.\n\t  function lineLength(line) {\n\t    if (line.height == 0) return 0;\n\t    var len = line.text.length, merged, cur = line;\n\t    while (merged = collapsedSpanAtStart(cur)) {\n\t      var found = merged.find(0, true);\n\t      cur = found.from.line;\n\t      len += found.from.ch - found.to.ch;\n\t    }\n\t    cur = line;\n\t    while (merged = collapsedSpanAtEnd(cur)) {\n\t      var found = merged.find(0, true);\n\t      len -= cur.text.length - found.from.ch;\n\t      cur = found.to.line;\n\t      len += cur.text.length - found.to.ch;\n\t    }\n\t    return len;\n\t  }\n\t\n\t  // Find the longest line in the document.\n\t  function findMaxLine(cm) {\n\t    var d = cm.display, doc = cm.doc;\n\t    d.maxLine = getLine(doc, doc.first);\n\t    d.maxLineLength = lineLength(d.maxLine);\n\t    d.maxLineChanged = true;\n\t    doc.iter(function(line) {\n\t      var len = lineLength(line);\n\t      if (len > d.maxLineLength) {\n\t        d.maxLineLength = len;\n\t        d.maxLine = line;\n\t      }\n\t    });\n\t  }\n\t\n\t  // Make sure the gutters options contains the element\n\t  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n\t  function setGuttersForLineNumbers(options) {\n\t    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n\t    if (found == -1 && options.lineNumbers) {\n\t      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n\t    } else if (found > -1 && !options.lineNumbers) {\n\t      options.gutters = options.gutters.slice(0);\n\t      options.gutters.splice(found, 1);\n\t    }\n\t  }\n\t\n\t  // SCROLLBARS\n\t\n\t  // Prepare DOM reads needed to update the scrollbars. Done in one\n\t  // shot to minimize update/measure roundtrips.\n\t  function measureForScrollbars(cm) {\n\t    var d = cm.display, gutterW = d.gutters.offsetWidth;\n\t    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n\t    return {\n\t      clientHeight: d.scroller.clientHeight,\n\t      viewHeight: d.wrapper.clientHeight,\n\t      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n\t      viewWidth: d.wrapper.clientWidth,\n\t      barLeft: cm.options.fixedGutter ? gutterW : 0,\n\t      docHeight: docH,\n\t      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n\t      nativeBarWidth: d.nativeBarWidth,\n\t      gutterWidth: gutterW\n\t    };\n\t  }\n\t\n\t  function NativeScrollbars(place, scroll, cm) {\n\t    this.cm = cm;\n\t    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n\t    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n\t    place(vert); place(horiz);\n\t\n\t    on(vert, \"scroll\", function() {\n\t      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n\t    });\n\t    on(horiz, \"scroll\", function() {\n\t      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n\t    });\n\t\n\t    this.checkedOverlay = false;\n\t    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n\t    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n\t  }\n\t\n\t  NativeScrollbars.prototype = copyObj({\n\t    update: function(measure) {\n\t      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n\t      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n\t      var sWidth = measure.nativeBarWidth;\n\t\n\t      if (needsV) {\n\t        this.vert.style.display = \"block\";\n\t        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n\t        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n\t        // A bug in IE8 can cause this value to be negative, so guard it.\n\t        this.vert.firstChild.style.height =\n\t          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n\t      } else {\n\t        this.vert.style.display = \"\";\n\t        this.vert.firstChild.style.height = \"0\";\n\t      }\n\t\n\t      if (needsH) {\n\t        this.horiz.style.display = \"block\";\n\t        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n\t        this.horiz.style.left = measure.barLeft + \"px\";\n\t        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n\t        this.horiz.firstChild.style.width =\n\t          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n\t      } else {\n\t        this.horiz.style.display = \"\";\n\t        this.horiz.firstChild.style.width = \"0\";\n\t      }\n\t\n\t      if (!this.checkedOverlay && measure.clientHeight > 0) {\n\t        if (sWidth == 0) this.overlayHack();\n\t        this.checkedOverlay = true;\n\t      }\n\t\n\t      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n\t    },\n\t    setScrollLeft: function(pos) {\n\t      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n\t    },\n\t    setScrollTop: function(pos) {\n\t      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n\t    },\n\t    overlayHack: function() {\n\t      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n\t      this.horiz.style.minHeight = this.vert.style.minWidth = w;\n\t      var self = this;\n\t      var barMouseDown = function(e) {\n\t        if (e_target(e) != self.vert && e_target(e) != self.horiz)\n\t          operation(self.cm, onMouseDown)(e);\n\t      };\n\t      on(this.vert, \"mousedown\", barMouseDown);\n\t      on(this.horiz, \"mousedown\", barMouseDown);\n\t    },\n\t    clear: function() {\n\t      var parent = this.horiz.parentNode;\n\t      parent.removeChild(this.horiz);\n\t      parent.removeChild(this.vert);\n\t    }\n\t  }, NativeScrollbars.prototype);\n\t\n\t  function NullScrollbars() {}\n\t\n\t  NullScrollbars.prototype = copyObj({\n\t    update: function() { return {bottom: 0, right: 0}; },\n\t    setScrollLeft: function() {},\n\t    setScrollTop: function() {},\n\t    clear: function() {}\n\t  }, NullScrollbars.prototype);\n\t\n\t  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\t\n\t  function initScrollbars(cm) {\n\t    if (cm.display.scrollbars) {\n\t      cm.display.scrollbars.clear();\n\t      if (cm.display.scrollbars.addClass)\n\t        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t    }\n\t\n\t    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n\t      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n\t      // Prevent clicks in the scrollbars from killing focus\n\t      on(node, \"mousedown\", function() {\n\t        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n\t      });\n\t      node.setAttribute(\"cm-not-content\", \"true\");\n\t    }, function(pos, axis) {\n\t      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n\t      else setScrollTop(cm, pos);\n\t    }, cm);\n\t    if (cm.display.scrollbars.addClass)\n\t      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t  }\n\t\n\t  function updateScrollbars(cm, measure) {\n\t    if (!measure) measure = measureForScrollbars(cm);\n\t    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n\t    updateScrollbarsInner(cm, measure);\n\t    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n\t      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n\t        updateHeightsInViewport(cm);\n\t      updateScrollbarsInner(cm, measureForScrollbars(cm));\n\t      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n\t    }\n\t  }\n\t\n\t  // Re-synchronize the fake scrollbars with the actual size of the\n\t  // content.\n\t  function updateScrollbarsInner(cm, measure) {\n\t    var d = cm.display;\n\t    var sizes = d.scrollbars.update(measure);\n\t\n\t    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n\t    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n\t\n\t    if (sizes.right && sizes.bottom) {\n\t      d.scrollbarFiller.style.display = \"block\";\n\t      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n\t      d.scrollbarFiller.style.width = sizes.right + \"px\";\n\t    } else d.scrollbarFiller.style.display = \"\";\n\t    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n\t      d.gutterFiller.style.display = \"block\";\n\t      d.gutterFiller.style.height = sizes.bottom + \"px\";\n\t      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n\t    } else d.gutterFiller.style.display = \"\";\n\t  }\n\t\n\t  // Compute the lines that are visible in a given viewport (defaults\n\t  // the the current scroll position). viewport may contain top,\n\t  // height, and ensure (see op.scrollToPos) properties.\n\t  function visibleLines(display, doc, viewport) {\n\t    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n\t    top = Math.floor(top - paddingTop(display));\n\t    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\t\n\t    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n\t    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n\t    // forces those lines into the viewport (if possible).\n\t    if (viewport && viewport.ensure) {\n\t      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n\t      if (ensureFrom < from) {\n\t        from = ensureFrom;\n\t        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n\t      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n\t        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n\t        to = ensureTo;\n\t      }\n\t    }\n\t    return {from: from, to: Math.max(to, from + 1)};\n\t  }\n\t\n\t  // LINE NUMBERS\n\t\n\t  // Re-align line numbers and gutter marks to compensate for\n\t  // horizontal scrolling.\n\t  function alignHorizontally(cm) {\n\t    var display = cm.display, view = display.view;\n\t    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n\t    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n\t    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n\t    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n\t      if (cm.options.fixedGutter && view[i].gutter)\n\t        view[i].gutter.style.left = left;\n\t      var align = view[i].alignable;\n\t      if (align) for (var j = 0; j < align.length; j++)\n\t        align[j].style.left = left;\n\t    }\n\t    if (cm.options.fixedGutter)\n\t      display.gutters.style.left = (comp + gutterW) + \"px\";\n\t  }\n\t\n\t  // Used to ensure that the line number gutter is still the right\n\t  // size for the current document size. Returns true when an update\n\t  // is needed.\n\t  function maybeUpdateLineNumberWidth(cm) {\n\t    if (!cm.options.lineNumbers) return false;\n\t    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n\t    if (last.length != display.lineNumChars) {\n\t      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n\t                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n\t      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n\t      display.lineGutter.style.width = \"\";\n\t      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n\t      display.lineNumWidth = display.lineNumInnerWidth + padding;\n\t      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n\t      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n\t      updateGutterSpace(cm);\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function lineNumberFor(options, i) {\n\t    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n\t  }\n\t\n\t  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n\t  // but using getBoundingClientRect to get a sub-pixel-accurate\n\t  // result.\n\t  function compensateForHScroll(display) {\n\t    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n\t  }\n\t\n\t  // DISPLAY DRAWING\n\t\n\t  function DisplayUpdate(cm, viewport, force) {\n\t    var display = cm.display;\n\t\n\t    this.viewport = viewport;\n\t    // Store some values that we'll need later (but don't want to force a relayout for)\n\t    this.visible = visibleLines(display, cm.doc, viewport);\n\t    this.editorIsHidden = !display.wrapper.offsetWidth;\n\t    this.wrapperHeight = display.wrapper.clientHeight;\n\t    this.wrapperWidth = display.wrapper.clientWidth;\n\t    this.oldDisplayWidth = displayWidth(cm);\n\t    this.force = force;\n\t    this.dims = getDimensions(cm);\n\t    this.events = [];\n\t  }\n\t\n\t  DisplayUpdate.prototype.signal = function(emitter, type) {\n\t    if (hasHandler(emitter, type))\n\t      this.events.push(arguments);\n\t  };\n\t  DisplayUpdate.prototype.finish = function() {\n\t    for (var i = 0; i < this.events.length; i++)\n\t      signal.apply(null, this.events[i]);\n\t  };\n\t\n\t  function maybeClipScrollbars(cm) {\n\t    var display = cm.display;\n\t    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n\t      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n\t      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n\t      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n\t      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n\t      display.scrollbarsClipped = true;\n\t    }\n\t  }\n\t\n\t  // Does the actual updating of the line display. Bails out\n\t  // (returning false) when there is nothing to be done and forced is\n\t  // false.\n\t  function updateDisplayIfNeeded(cm, update) {\n\t    var display = cm.display, doc = cm.doc;\n\t\n\t    if (update.editorIsHidden) {\n\t      resetView(cm);\n\t      return false;\n\t    }\n\t\n\t    // Bail out if the visible area is already rendered and nothing changed.\n\t    if (!update.force &&\n\t        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n\t        display.renderedView == display.view && countDirtyView(cm) == 0)\n\t      return false;\n\t\n\t    if (maybeUpdateLineNumberWidth(cm)) {\n\t      resetView(cm);\n\t      update.dims = getDimensions(cm);\n\t    }\n\t\n\t    // Compute a suitable new viewport (from & to)\n\t    var end = doc.first + doc.size;\n\t    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n\t    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n\t    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n\t    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n\t    if (sawCollapsedSpans) {\n\t      from = visualLineNo(cm.doc, from);\n\t      to = visualLineEndNo(cm.doc, to);\n\t    }\n\t\n\t    var different = from != display.viewFrom || to != display.viewTo ||\n\t      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n\t    adjustView(cm, from, to);\n\t\n\t    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n\t    // Position the mover div to align with the current scroll position\n\t    cm.display.mover.style.top = display.viewOffset + \"px\";\n\t\n\t    var toUpdate = countDirtyView(cm);\n\t    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n\t      return false;\n\t\n\t    // For big changes, we hide the enclosing element during the\n\t    // update, since that speeds up the operations on most browsers.\n\t    var focused = activeElt();\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n\t    patchDisplay(cm, display.updateLineNumbers, update.dims);\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n\t    display.renderedView = display.view;\n\t    // There might have been a widget with a focused element that got\n\t    // hidden or updated, if so re-focus it.\n\t    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\t\n\t    // Prevent selection and cursors from interfering with the scroll\n\t    // width and height.\n\t    removeChildren(display.cursorDiv);\n\t    removeChildren(display.selectionDiv);\n\t    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\t\n\t    if (different) {\n\t      display.lastWrapHeight = update.wrapperHeight;\n\t      display.lastWrapWidth = update.wrapperWidth;\n\t      startWorker(cm, 400);\n\t    }\n\t\n\t    display.updateLineNumbers = null;\n\t\n\t    return true;\n\t  }\n\t\n\t  function postUpdateDisplay(cm, update) {\n\t    var viewport = update.viewport;\n\t    for (var first = true;; first = false) {\n\t      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n\t        // Clip forced viewport to actual scrollable area.\n\t        if (viewport && viewport.top != null)\n\t          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n\t        // Updated line heights might result in the drawn area not\n\t        // actually covering the viewport. Keep looping until it does.\n\t        update.visible = visibleLines(cm.display, cm.doc, viewport);\n\t        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n\t          break;\n\t      }\n\t      if (!updateDisplayIfNeeded(cm, update)) break;\n\t      updateHeightsInViewport(cm);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      setDocumentHeight(cm, barMeasure);\n\t      updateScrollbars(cm, barMeasure);\n\t    }\n\t\n\t    update.signal(cm, \"update\", cm);\n\t    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n\t      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n\t      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n\t    }\n\t  }\n\t\n\t  function updateDisplaySimple(cm, viewport) {\n\t    var update = new DisplayUpdate(cm, viewport);\n\t    if (updateDisplayIfNeeded(cm, update)) {\n\t      updateHeightsInViewport(cm);\n\t      postUpdateDisplay(cm, update);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      setDocumentHeight(cm, barMeasure);\n\t      updateScrollbars(cm, barMeasure);\n\t      update.finish();\n\t    }\n\t  }\n\t\n\t  function setDocumentHeight(cm, measure) {\n\t    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n\t    var total = measure.docHeight + cm.display.barHeight;\n\t    cm.display.heightForcer.style.top = total + \"px\";\n\t    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + \"px\";\n\t  }\n\t\n\t  // Read the actual heights of the rendered lines, and update their\n\t  // stored heights to match.\n\t  function updateHeightsInViewport(cm) {\n\t    var display = cm.display;\n\t    var prevBottom = display.lineDiv.offsetTop;\n\t    for (var i = 0; i < display.view.length; i++) {\n\t      var cur = display.view[i], height;\n\t      if (cur.hidden) continue;\n\t      if (ie && ie_version < 8) {\n\t        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n\t        height = bot - prevBottom;\n\t        prevBottom = bot;\n\t      } else {\n\t        var box = cur.node.getBoundingClientRect();\n\t        height = box.bottom - box.top;\n\t      }\n\t      var diff = cur.line.height - height;\n\t      if (height < 2) height = textHeight(display);\n\t      if (diff > .001 || diff < -.001) {\n\t        updateLineHeight(cur.line, height);\n\t        updateWidgetHeight(cur.line);\n\t        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n\t          updateWidgetHeight(cur.rest[j]);\n\t      }\n\t    }\n\t  }\n\t\n\t  // Read and store the height of line widgets associated with the\n\t  // given line.\n\t  function updateWidgetHeight(line) {\n\t    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n\t      line.widgets[i].height = line.widgets[i].node.offsetHeight;\n\t  }\n\t\n\t  // Do a bulk-read of the DOM positions and sizes needed to draw the\n\t  // view, so that we don't interleave reading and writing to the DOM.\n\t  function getDimensions(cm) {\n\t    var d = cm.display, left = {}, width = {};\n\t    var gutterLeft = d.gutters.clientLeft;\n\t    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n\t      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n\t      width[cm.options.gutters[i]] = n.clientWidth;\n\t    }\n\t    return {fixedPos: compensateForHScroll(d),\n\t            gutterTotalWidth: d.gutters.offsetWidth,\n\t            gutterLeft: left,\n\t            gutterWidth: width,\n\t            wrapperWidth: d.wrapper.clientWidth};\n\t  }\n\t\n\t  // Sync the actual display DOM structure with display.view, removing\n\t  // nodes for lines that are no longer in view, and creating the ones\n\t  // that are not there yet, and updating the ones that are out of\n\t  // date.\n\t  function patchDisplay(cm, updateNumbersFrom, dims) {\n\t    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n\t    var container = display.lineDiv, cur = container.firstChild;\n\t\n\t    function rm(node) {\n\t      var next = node.nextSibling;\n\t      // Works around a throw-scroll bug in OS X Webkit\n\t      if (webkit && mac && cm.display.currentWheelTarget == node)\n\t        node.style.display = \"none\";\n\t      else\n\t        node.parentNode.removeChild(node);\n\t      return next;\n\t    }\n\t\n\t    var view = display.view, lineN = display.viewFrom;\n\t    // Loop over the elements in the view, syncing cur (the DOM nodes\n\t    // in display.lineDiv) with the view as we go.\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (lineView.hidden) {\n\t      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n\t        var node = buildLineElement(cm, lineView, lineN, dims);\n\t        container.insertBefore(node, cur);\n\t      } else { // Already drawn\n\t        while (cur != lineView.node) cur = rm(cur);\n\t        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n\t          updateNumbersFrom <= lineN && lineView.lineNumber;\n\t        if (lineView.changes) {\n\t          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n\t          updateLineForChanges(cm, lineView, lineN, dims);\n\t        }\n\t        if (updateNumber) {\n\t          removeChildren(lineView.lineNumber);\n\t          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n\t        }\n\t        cur = lineView.node.nextSibling;\n\t      }\n\t      lineN += lineView.size;\n\t    }\n\t    while (cur) cur = rm(cur);\n\t  }\n\t\n\t  // When an aspect of a line changes, a string is added to\n\t  // lineView.changes. This updates the relevant part of the line's\n\t  // DOM structure.\n\t  function updateLineForChanges(cm, lineView, lineN, dims) {\n\t    for (var j = 0; j < lineView.changes.length; j++) {\n\t      var type = lineView.changes[j];\n\t      if (type == \"text\") updateLineText(cm, lineView);\n\t      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n\t      else if (type == \"class\") updateLineClasses(lineView);\n\t      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n\t    }\n\t    lineView.changes = null;\n\t  }\n\t\n\t  // Lines with gutter elements, widgets or a background class need to\n\t  // be wrapped, and have the extra elements added to the wrapper div\n\t  function ensureLineWrapped(lineView) {\n\t    if (lineView.node == lineView.text) {\n\t      lineView.node = elt(\"div\", null, null, \"position: relative\");\n\t      if (lineView.text.parentNode)\n\t        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n\t      lineView.node.appendChild(lineView.text);\n\t      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n\t    }\n\t    return lineView.node;\n\t  }\n\t\n\t  function updateLineBackground(lineView) {\n\t    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n\t    if (cls) cls += \" CodeMirror-linebackground\";\n\t    if (lineView.background) {\n\t      if (cls) lineView.background.className = cls;\n\t      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n\t    } else if (cls) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n\t    }\n\t  }\n\t\n\t  // Wrapper around buildLineContent which will reuse the structure\n\t  // in display.externalMeasured when possible.\n\t  function getLineContent(cm, lineView) {\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && ext.line == lineView.line) {\n\t      cm.display.externalMeasured = null;\n\t      lineView.measure = ext.measure;\n\t      return ext.built;\n\t    }\n\t    return buildLineContent(cm, lineView);\n\t  }\n\t\n\t  // Redraw the line's text. Interacts with the background and text\n\t  // classes because the mode may output tokens that influence these\n\t  // classes.\n\t  function updateLineText(cm, lineView) {\n\t    var cls = lineView.text.className;\n\t    var built = getLineContent(cm, lineView);\n\t    if (lineView.text == lineView.node) lineView.node = built.pre;\n\t    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n\t    lineView.text = built.pre;\n\t    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n\t      lineView.bgClass = built.bgClass;\n\t      lineView.textClass = built.textClass;\n\t      updateLineClasses(lineView);\n\t    } else if (cls) {\n\t      lineView.text.className = cls;\n\t    }\n\t  }\n\t\n\t  function updateLineClasses(lineView) {\n\t    updateLineBackground(lineView);\n\t    if (lineView.line.wrapClass)\n\t      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n\t    else if (lineView.node != lineView.text)\n\t      lineView.node.className = \"\";\n\t    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n\t    lineView.text.className = textClass || \"\";\n\t  }\n\t\n\t  function updateLineGutter(cm, lineView, lineN, dims) {\n\t    if (lineView.gutter) {\n\t      lineView.node.removeChild(lineView.gutter);\n\t      lineView.gutter = null;\n\t    }\n\t    if (lineView.gutterBackground) {\n\t      lineView.node.removeChild(lineView.gutterBackground);\n\t      lineView.gutterBackground = null;\n\t    }\n\t    if (lineView.line.gutterClass) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n\t                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n\t                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n\t      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n\t    }\n\t    var markers = lineView.line.gutterMarkers;\n\t    if (cm.options.lineNumbers || markers) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n\t                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n\t      cm.display.input.setUneditable(gutterWrap);\n\t      wrap.insertBefore(gutterWrap, lineView.text);\n\t      if (lineView.line.gutterClass)\n\t        gutterWrap.className += \" \" + lineView.line.gutterClass;\n\t      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n\t        lineView.lineNumber = gutterWrap.appendChild(\n\t          elt(\"div\", lineNumberFor(cm.options, lineN),\n\t              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n\t              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n\t              + cm.display.lineNumInnerWidth + \"px\"));\n\t      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n\t        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n\t        if (found)\n\t          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n\t                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n\t      }\n\t    }\n\t  }\n\t\n\t  function updateLineWidgets(cm, lineView, dims) {\n\t    if (lineView.alignable) lineView.alignable = null;\n\t    for (var node = lineView.node.firstChild, next; node; node = next) {\n\t      var next = node.nextSibling;\n\t      if (node.className == \"CodeMirror-linewidget\")\n\t        lineView.node.removeChild(node);\n\t    }\n\t    insertLineWidgets(cm, lineView, dims);\n\t  }\n\t\n\t  // Build a line's DOM representation from scratch\n\t  function buildLineElement(cm, lineView, lineN, dims) {\n\t    var built = getLineContent(cm, lineView);\n\t    lineView.text = lineView.node = built.pre;\n\t    if (built.bgClass) lineView.bgClass = built.bgClass;\n\t    if (built.textClass) lineView.textClass = built.textClass;\n\t\n\t    updateLineClasses(lineView);\n\t    updateLineGutter(cm, lineView, lineN, dims);\n\t    insertLineWidgets(cm, lineView, dims);\n\t    return lineView.node;\n\t  }\n\t\n\t  // A lineView may contain multiple logical lines (when merged by\n\t  // collapsed spans). The widgets for all of them need to be drawn.\n\t  function insertLineWidgets(cm, lineView, dims) {\n\t    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n\t    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n\t  }\n\t\n\t  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n\t    if (!line.widgets) return;\n\t    var wrap = ensureLineWrapped(lineView);\n\t    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n\t      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n\t      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      positionLineWidget(widget, node, lineView, dims);\n\t      cm.display.input.setUneditable(node);\n\t      if (allowAbove && widget.above)\n\t        wrap.insertBefore(node, lineView.gutter || lineView.text);\n\t      else\n\t        wrap.appendChild(node);\n\t      signalLater(widget, \"redraw\");\n\t    }\n\t  }\n\t\n\t  function positionLineWidget(widget, node, lineView, dims) {\n\t    if (widget.noHScroll) {\n\t      (lineView.alignable || (lineView.alignable = [])).push(node);\n\t      var width = dims.wrapperWidth;\n\t      node.style.left = dims.fixedPos + \"px\";\n\t      if (!widget.coverGutter) {\n\t        width -= dims.gutterTotalWidth;\n\t        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n\t      }\n\t      node.style.width = width + \"px\";\n\t    }\n\t    if (widget.coverGutter) {\n\t      node.style.zIndex = 5;\n\t      node.style.position = \"relative\";\n\t      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n\t    }\n\t  }\n\t\n\t  // POSITION OBJECT\n\t\n\t  // A Pos instance represents a position within the text.\n\t  var Pos = CodeMirror.Pos = function(line, ch) {\n\t    if (!(this instanceof Pos)) return new Pos(line, ch);\n\t    this.line = line; this.ch = ch;\n\t  };\n\t\n\t  // Compare two positions, return 0 if they are the same, a negative\n\t  // number when a is less, and a positive number otherwise.\n\t  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\t\n\t  function copyPos(x) {return Pos(x.line, x.ch);}\n\t  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n\t  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\t\n\t  // INPUT HANDLING\n\t\n\t  function ensureFocus(cm) {\n\t    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n\t  }\n\t\n\t  function isReadOnly(cm) {\n\t    return cm.options.readOnly || cm.doc.cantEdit;\n\t  }\n\t\n\t  // This will be set to an array of strings when copying, so that,\n\t  // when pasting, we know what kind of selections the copied text\n\t  // was made out of.\n\t  var lastCopied = null;\n\t\n\t  function applyTextInput(cm, inserted, deleted, sel, origin) {\n\t    var doc = cm.doc;\n\t    cm.display.shift = false;\n\t    if (!sel) sel = doc.sel;\n\t\n\t    var paste = cm.state.pasteIncoming || origin == \"paste\";\n\t    var textLines = doc.splitLines(inserted), multiPaste = null;\n\t    // When pasing N lines into N selections, insert one line per selection\n\t    if (paste && sel.ranges.length > 1) {\n\t      if (lastCopied && lastCopied.join(\"\\n\") == inserted) {\n\t        if (sel.ranges.length % lastCopied.length == 0) {\n\t          multiPaste = [];\n\t          for (var i = 0; i < lastCopied.length; i++)\n\t            multiPaste.push(doc.splitLines(lastCopied[i]));\n\t        }\n\t      } else if (textLines.length == sel.ranges.length) {\n\t        multiPaste = map(textLines, function(l) { return [l]; });\n\t      }\n\t    }\n\t\n\t    // Normal behavior is to insert the new text into every selection\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      var from = range.from(), to = range.to();\n\t      if (range.empty()) {\n\t        if (deleted && deleted > 0) // Handle deletion\n\t          from = Pos(from.line, from.ch - deleted);\n\t        else if (cm.state.overwrite && !paste) // Handle overwrite\n\t          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n\t      }\n\t      var updateInput = cm.curOp.updateInput;\n\t      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n\t                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n\t      makeChange(cm.doc, changeEvent);\n\t      signalLater(cm, \"inputRead\", cm, changeEvent);\n\t    }\n\t    if (inserted && !paste)\n\t      triggerElectric(cm, inserted);\n\t\n\t    ensureCursorVisible(cm);\n\t    cm.curOp.updateInput = updateInput;\n\t    cm.curOp.typing = true;\n\t    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n\t  }\n\t\n\t  function handlePaste(e, cm) {\n\t    var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\n\t    if (pasted) {\n\t      e.preventDefault();\n\t      if (!isReadOnly(cm) && !cm.options.disableInput)\n\t        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n\t      return true;\n\t    }\n\t  }\n\t\n\t  function triggerElectric(cm, inserted) {\n\t    // When an 'electric' character is inserted, immediately trigger a reindent\n\t    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n\t    var sel = cm.doc.sel;\n\t\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n\t      var mode = cm.getModeAt(range.head);\n\t      var indented = false;\n\t      if (mode.electricChars) {\n\t        for (var j = 0; j < mode.electricChars.length; j++)\n\t          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n\t            indented = indentLine(cm, range.head.line, \"smart\");\n\t            break;\n\t          }\n\t      } else if (mode.electricInput) {\n\t        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n\t          indented = indentLine(cm, range.head.line, \"smart\");\n\t      }\n\t      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n\t    }\n\t  }\n\t\n\t  function copyableRanges(cm) {\n\t    var text = [], ranges = [];\n\t    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n\t      var line = cm.doc.sel.ranges[i].head.line;\n\t      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n\t      ranges.push(lineRange);\n\t      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n\t    }\n\t    return {text: text, ranges: ranges};\n\t  }\n\t\n\t  function disableBrowserMagic(field) {\n\t    field.setAttribute(\"autocorrect\", \"off\");\n\t    field.setAttribute(\"autocapitalize\", \"off\");\n\t    field.setAttribute(\"spellcheck\", \"false\");\n\t  }\n\t\n\t  // TEXTAREA INPUT STYLE\n\t\n\t  function TextareaInput(cm) {\n\t    this.cm = cm;\n\t    // See input.poll and input.reset\n\t    this.prevInput = \"\";\n\t\n\t    // Flag that indicates whether we expect input to appear real soon\n\t    // now (after some event like 'keypress' or 'input') and are\n\t    // polling intensively.\n\t    this.pollingFast = false;\n\t    // Self-resetting timeout for the poller\n\t    this.polling = new Delayed();\n\t    // Tracks when input.reset has punted to just putting a short\n\t    // string into the textarea instead of the full selection.\n\t    this.inaccurateSelection = false;\n\t    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n\t    this.hasSelection = false;\n\t    this.composing = null;\n\t  };\n\t\n\t  function hiddenTextarea() {\n\t    var te = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n\t    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n\t    // The textarea is kept positioned near the cursor to prevent the\n\t    // fact that it'll be scrolled into view on input from scrolling\n\t    // our fake cursor out of view. On webkit, when wrap=off, paste is\n\t    // very slow. So make the area wide instead.\n\t    if (webkit) te.style.width = \"1000px\";\n\t    else te.setAttribute(\"wrap\", \"off\");\n\t    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n\t    if (ios) te.style.border = \"1px solid black\";\n\t    disableBrowserMagic(te);\n\t    return div;\n\t  }\n\t\n\t  TextareaInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = this.cm;\n\t\n\t      // Wraps and hides input textarea\n\t      var div = this.wrapper = hiddenTextarea();\n\t      // The semihidden textarea that is focused when the editor is\n\t      // focused, and receives input.\n\t      var te = this.textarea = div.firstChild;\n\t      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\t\n\t      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n\t      if (ios) te.style.width = \"0px\";\n\t\n\t      on(te, \"input\", function() {\n\t        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n\t        input.poll();\n\t      });\n\t\n\t      on(te, \"paste\", function(e) {\n\t        if (handlePaste(e, cm)) return true;\n\t\n\t        cm.state.pasteIncoming = true;\n\t        input.fastPoll();\n\t      });\n\t\n\t      function prepareCopyCut(e) {\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = cm.getSelections();\n\t          if (input.inaccurateSelection) {\n\t            input.prevInput = \"\";\n\t            input.inaccurateSelection = false;\n\t            te.value = lastCopied.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = ranges.text;\n\t          if (e.type == \"cut\") {\n\t            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n\t          } else {\n\t            input.prevInput = \"\";\n\t            te.value = ranges.text.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        }\n\t        if (e.type == \"cut\") cm.state.cutIncoming = true;\n\t      }\n\t      on(te, \"cut\", prepareCopyCut);\n\t      on(te, \"copy\", prepareCopyCut);\n\t\n\t      on(display.scroller, \"paste\", function(e) {\n\t        if (eventInWidget(display, e)) return;\n\t        cm.state.pasteIncoming = true;\n\t        input.focus();\n\t      });\n\t\n\t      // Prevent normal selection in the editor (we handle our own)\n\t      on(display.lineSpace, \"selectstart\", function(e) {\n\t        if (!eventInWidget(display, e)) e_preventDefault(e);\n\t      });\n\t\n\t      on(te, \"compositionstart\", function() {\n\t        var start = cm.getCursor(\"from\");\n\t        if (input.composing) input.composing.range.clear()\n\t        input.composing = {\n\t          start: start,\n\t          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n\t        };\n\t      });\n\t      on(te, \"compositionend\", function() {\n\t        if (input.composing) {\n\t          input.poll();\n\t          input.composing.range.clear();\n\t          input.composing = null;\n\t        }\n\t      });\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      // Redraw the selection and/or cursor\n\t      var cm = this.cm, display = cm.display, doc = cm.doc;\n\t      var result = prepareSelection(cm);\n\t\n\t      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n\t      if (cm.options.moveInputWithCursor) {\n\t        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n\t        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n\t        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n\t                                            headPos.top + lineOff.top - wrapOff.top));\n\t        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n\t                                             headPos.left + lineOff.left - wrapOff.left));\n\t      }\n\t\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(drawn) {\n\t      var cm = this.cm, display = cm.display;\n\t      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n\t      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n\t      if (drawn.teTop != null) {\n\t        this.wrapper.style.top = drawn.teTop + \"px\";\n\t        this.wrapper.style.left = drawn.teLeft + \"px\";\n\t      }\n\t    },\n\t\n\t    // Reset the input to correspond to the selection (or to be empty,\n\t    // when not typing and nothing is selected)\n\t    reset: function(typing) {\n\t      if (this.contextMenuPending) return;\n\t      var minimal, selected, cm = this.cm, doc = cm.doc;\n\t      if (cm.somethingSelected()) {\n\t        this.prevInput = \"\";\n\t        var range = doc.sel.primary();\n\t        minimal = hasCopyEvent &&\n\t          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n\t        var content = minimal ? \"-\" : selected || cm.getSelection();\n\t        this.textarea.value = content;\n\t        if (cm.state.focused) selectInput(this.textarea);\n\t        if (ie && ie_version >= 9) this.hasSelection = content;\n\t      } else if (!typing) {\n\t        this.prevInput = this.textarea.value = \"\";\n\t        if (ie && ie_version >= 9) this.hasSelection = null;\n\t      }\n\t      this.inaccurateSelection = minimal;\n\t    },\n\t\n\t    getField: function() { return this.textarea; },\n\t\n\t    supportsTouch: function() { return false; },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n\t        try { this.textarea.focus(); }\n\t        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n\t      }\n\t    },\n\t\n\t    blur: function() { this.textarea.blur(); },\n\t\n\t    resetPosition: function() {\n\t      this.wrapper.style.top = this.wrapper.style.left = 0;\n\t    },\n\t\n\t    receivedFocus: function() { this.slowPoll(); },\n\t\n\t    // Poll for input changes, using the normal rate of polling. This\n\t    // runs as long as the editor is focused.\n\t    slowPoll: function() {\n\t      var input = this;\n\t      if (input.pollingFast) return;\n\t      input.polling.set(this.cm.options.pollInterval, function() {\n\t        input.poll();\n\t        if (input.cm.state.focused) input.slowPoll();\n\t      });\n\t    },\n\t\n\t    // When an event has just come in that is likely to add or change\n\t    // something in the input textarea, we poll faster, to ensure that\n\t    // the change appears on the screen quickly.\n\t    fastPoll: function() {\n\t      var missed = false, input = this;\n\t      input.pollingFast = true;\n\t      function p() {\n\t        var changed = input.poll();\n\t        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n\t        else {input.pollingFast = false; input.slowPoll();}\n\t      }\n\t      input.polling.set(20, p);\n\t    },\n\t\n\t    // Read input from the textarea, and update the document to match.\n\t    // When something is selected, it is present in the textarea, and\n\t    // selected (unless it is huge, in which case a placeholder is\n\t    // used). When nothing is selected, the cursor sits after previously\n\t    // seen text (can be empty), which is stored in prevInput (we must\n\t    // not reset the textarea when typing, because that breaks IME).\n\t    poll: function() {\n\t      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n\t      // Since this is called a *lot*, try to bail out as cheaply as\n\t      // possible when it is clear that nothing happened. hasSelection\n\t      // will be the case when there is a lot of text in the textarea,\n\t      // in which case reading its value would be expensive.\n\t      if (this.contextMenuPending || !cm.state.focused ||\n\t          (hasSelection(input) && !prevInput && !this.composing) ||\n\t          isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)\n\t        return false;\n\t\n\t      var text = input.value;\n\t      // If nothing changed, bail.\n\t      if (text == prevInput && !cm.somethingSelected()) return false;\n\t      // Work around nonsensical selection resetting in IE9/10, and\n\t      // inexplicable appearance of private area unicode characters on\n\t      // some key combos in Mac (#2689).\n\t      if (ie && ie_version >= 9 && this.hasSelection === text ||\n\t          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n\t        cm.display.input.reset();\n\t        return false;\n\t      }\n\t\n\t      if (cm.doc.sel == cm.display.selForContextMenu) {\n\t        var first = text.charCodeAt(0);\n\t        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n\t        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n\t      }\n\t      // Find the part of the input that is actually new\n\t      var same = 0, l = Math.min(prevInput.length, text.length);\n\t      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\t\n\t      var self = this;\n\t      runInOp(cm, function() {\n\t        applyTextInput(cm, text.slice(same), prevInput.length - same,\n\t                       null, self.composing ? \"*compose\" : null);\n\t\n\t        // Don't leave long text in the textarea, since it makes further polling slow\n\t        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n\t        else self.prevInput = text;\n\t\n\t        if (self.composing) {\n\t          self.composing.range.clear();\n\t          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n\t                                             {className: \"CodeMirror-composing\"});\n\t        }\n\t      });\n\t      return true;\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      if (this.pollingFast && this.poll()) this.pollingFast = false;\n\t    },\n\t\n\t    onKeyPress: function() {\n\t      if (ie && ie_version >= 9) this.hasSelection = null;\n\t      this.fastPoll();\n\t    },\n\t\n\t    onContextMenu: function(e) {\n\t      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n\t      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n\t      if (!pos || presto) return; // Opera is difficult.\n\t\n\t      // Reset the current text selection only if the click is done outside of the selection\n\t      // and 'resetSelectionOnContextMenu' option is true.\n\t      var reset = cm.options.resetSelectionOnContextMenu;\n\t      if (reset && cm.doc.sel.contains(pos) == -1)\n\t        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\t\n\t      var oldCSS = te.style.cssText;\n\t      input.wrapper.style.position = \"absolute\";\n\t      te.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n\t        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: \" +\n\t        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n\t        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n\t      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n\t      display.input.focus();\n\t      if (webkit) window.scrollTo(null, oldScrollY);\n\t      display.input.reset();\n\t      // Adds \"Select all\" to context menu in FF\n\t      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n\t      input.contextMenuPending = true;\n\t      display.selForContextMenu = cm.doc.sel;\n\t      clearTimeout(display.detectingSelectAll);\n\t\n\t      // Select-all will be greyed out if there's nothing to select, so\n\t      // this adds a zero-width space so that we can later check whether\n\t      // it got selected.\n\t      function prepareSelectAllHack() {\n\t        if (te.selectionStart != null) {\n\t          var selected = cm.somethingSelected();\n\t          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n\t          te.value = \"\\u21da\"; // Used to catch context-menu undo\n\t          te.value = extval;\n\t          input.prevInput = selected ? \"\" : \"\\u200b\";\n\t          te.selectionStart = 1; te.selectionEnd = extval.length;\n\t          // Re-set this, in case some other handler touched the\n\t          // selection in the meantime.\n\t          display.selForContextMenu = cm.doc.sel;\n\t        }\n\t      }\n\t      function rehide() {\n\t        input.contextMenuPending = false;\n\t        input.wrapper.style.position = \"relative\";\n\t        te.style.cssText = oldCSS;\n\t        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\t\n\t        // Try to detect the user choosing select-all\n\t        if (te.selectionStart != null) {\n\t          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n\t          var i = 0, poll = function() {\n\t            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n\t                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n\t              operation(cm, commands.selectAll)(cm);\n\t            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n\t            else display.input.reset();\n\t          };\n\t          display.detectingSelectAll = setTimeout(poll, 200);\n\t        }\n\t      }\n\t\n\t      if (ie && ie_version >= 9) prepareSelectAllHack();\n\t      if (captureRightClick) {\n\t        e_stop(e);\n\t        var mouseup = function() {\n\t          off(window, \"mouseup\", mouseup);\n\t          setTimeout(rehide, 20);\n\t        };\n\t        on(window, \"mouseup\", mouseup);\n\t      } else {\n\t        setTimeout(rehide, 50);\n\t      }\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      if (!val) this.reset();\n\t    },\n\t\n\t    setUneditable: nothing,\n\t\n\t    needsContentAttribute: false\n\t  }, TextareaInput.prototype);\n\t\n\t  // CONTENTEDITABLE INPUT STYLE\n\t\n\t  function ContentEditableInput(cm) {\n\t    this.cm = cm;\n\t    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n\t    this.polling = new Delayed();\n\t    this.gracePeriod = false;\n\t  }\n\t\n\t  ContentEditableInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = input.cm;\n\t      var div = input.div = display.lineDiv;\n\t      disableBrowserMagic(div);\n\t\n\t      on(div, \"paste\", function(e) { handlePaste(e, cm); })\n\t\n\t      on(div, \"compositionstart\", function(e) {\n\t        var data = e.data;\n\t        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n\t        if (!data) return;\n\t        var prim = cm.doc.sel.primary();\n\t        var line = cm.getLine(prim.head.line);\n\t        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n\t        if (found > -1 && found <= prim.head.ch)\n\t          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n\t                                                Pos(prim.head.line, found + data.length));\n\t      });\n\t      on(div, \"compositionupdate\", function(e) {\n\t        input.composing.data = e.data;\n\t      });\n\t      on(div, \"compositionend\", function(e) {\n\t        var ours = input.composing;\n\t        if (!ours) return;\n\t        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n\t          ours.data = e.data;\n\t        // Need a small delay to prevent other code (input event,\n\t        // selection polling) from doing damage when fired right after\n\t        // compositionend.\n\t        setTimeout(function() {\n\t          if (!ours.handled)\n\t            input.applyComposition(ours);\n\t          if (input.composing == ours)\n\t            input.composing = null;\n\t        }, 50);\n\t      });\n\t\n\t      on(div, \"touchstart\", function() {\n\t        input.forceCompositionEnd();\n\t      });\n\t\n\t      on(div, \"input\", function() {\n\t        if (input.composing) return;\n\t        if (isReadOnly(cm) || !input.pollContent())\n\t          runInOp(input.cm, function() {regChange(cm);});\n\t      });\n\t\n\t      function onCopyCut(e) {\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = cm.getSelections();\n\t          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = ranges.text;\n\t          if (e.type == \"cut\") {\n\t            cm.operation(function() {\n\t              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n\t              cm.replaceSelection(\"\", null, \"cut\");\n\t            });\n\t          }\n\t        }\n\t        // iOS exposes the clipboard API, but seems to discard content inserted into it\n\t        if (e.clipboardData && !ios) {\n\t          e.preventDefault();\n\t          e.clipboardData.clearData();\n\t          e.clipboardData.setData(\"text/plain\", lastCopied.join(\"\\n\"));\n\t        } else {\n\t          // Old-fashioned briefly-focus-a-textarea hack\n\t          var kludge = hiddenTextarea(), te = kludge.firstChild;\n\t          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n\t          te.value = lastCopied.join(\"\\n\");\n\t          var hadFocus = document.activeElement;\n\t          selectInput(te);\n\t          setTimeout(function() {\n\t            cm.display.lineSpace.removeChild(kludge);\n\t            hadFocus.focus();\n\t          }, 50);\n\t        }\n\t      }\n\t      on(div, \"copy\", onCopyCut);\n\t      on(div, \"cut\", onCopyCut);\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      var result = prepareSelection(this.cm, false);\n\t      result.focus = this.cm.state.focused;\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(info) {\n\t      if (!info || !this.cm.display.view.length) return;\n\t      if (info.focus) this.showPrimarySelection();\n\t      this.showMultipleSelections(info);\n\t    },\n\t\n\t    showPrimarySelection: function() {\n\t      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n\t      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n\t      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n\t      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n\t          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n\t          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n\t        return;\n\t\n\t      var start = posToDOM(this.cm, prim.from());\n\t      var end = posToDOM(this.cm, prim.to());\n\t      if (!start && !end) return;\n\t\n\t      var view = this.cm.display.view;\n\t      var old = sel.rangeCount && sel.getRangeAt(0);\n\t      if (!start) {\n\t        start = {node: view[0].measure.map[2], offset: 0};\n\t      } else if (!end) { // FIXME dangerously hacky\n\t        var measure = view[view.length - 1].measure;\n\t        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n\t        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n\t      }\n\t\n\t      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n\t      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n\t      if (rng) {\n\t        sel.removeAllRanges();\n\t        sel.addRange(rng);\n\t        if (old && sel.anchorNode == null) sel.addRange(old);\n\t        else if (gecko) this.startGracePeriod();\n\t      }\n\t      this.rememberSelection();\n\t    },\n\t\n\t    startGracePeriod: function() {\n\t      var input = this;\n\t      clearTimeout(this.gracePeriod);\n\t      this.gracePeriod = setTimeout(function() {\n\t        input.gracePeriod = false;\n\t        if (input.selectionChanged())\n\t          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n\t      }, 20);\n\t    },\n\t\n\t    showMultipleSelections: function(info) {\n\t      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n\t      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n\t    },\n\t\n\t    rememberSelection: function() {\n\t      var sel = window.getSelection();\n\t      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n\t      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n\t    },\n\t\n\t    selectionInEditor: function() {\n\t      var sel = window.getSelection();\n\t      if (!sel.rangeCount) return false;\n\t      var node = sel.getRangeAt(0).commonAncestorContainer;\n\t      return contains(this.div, node);\n\t    },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n\t    },\n\t    blur: function() { this.div.blur(); },\n\t    getField: function() { return this.div; },\n\t\n\t    supportsTouch: function() { return true; },\n\t\n\t    receivedFocus: function() {\n\t      var input = this;\n\t      if (this.selectionInEditor())\n\t        this.pollSelection();\n\t      else\n\t        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\t\n\t      function poll() {\n\t        if (input.cm.state.focused) {\n\t          input.pollSelection();\n\t          input.polling.set(input.cm.options.pollInterval, poll);\n\t        }\n\t      }\n\t      this.polling.set(this.cm.options.pollInterval, poll);\n\t    },\n\t\n\t    selectionChanged: function() {\n\t      var sel = window.getSelection();\n\t      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n\t        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n\t    },\n\t\n\t    pollSelection: function() {\n\t      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n\t        var sel = window.getSelection(), cm = this.cm;\n\t        this.rememberSelection();\n\t        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n\t        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n\t        if (anchor && head) runInOp(cm, function() {\n\t          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n\t          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n\t        });\n\t      }\n\t    },\n\t\n\t    pollContent: function() {\n\t      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n\t      var from = sel.from(), to = sel.to();\n\t      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\t\n\t      var fromIndex;\n\t      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n\t        var fromLine = lineNo(display.view[0].line);\n\t        var fromNode = display.view[0].node;\n\t      } else {\n\t        var fromLine = lineNo(display.view[fromIndex].line);\n\t        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n\t      }\n\t      var toIndex = findViewIndex(cm, to.line);\n\t      if (toIndex == display.view.length - 1) {\n\t        var toLine = display.viewTo - 1;\n\t        var toNode = display.lineDiv.lastChild;\n\t      } else {\n\t        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n\t        var toNode = display.view[toIndex + 1].node.previousSibling;\n\t      }\n\t\n\t      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n\t      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n\t      while (newText.length > 1 && oldText.length > 1) {\n\t        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n\t        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n\t        else break;\n\t      }\n\t\n\t      var cutFront = 0, cutEnd = 0;\n\t      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n\t      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n\t        ++cutFront;\n\t      var newBot = lst(newText), oldBot = lst(oldText);\n\t      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n\t                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n\t      while (cutEnd < maxCutEnd &&\n\t             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n\t        ++cutEnd;\n\t\n\t      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n\t      newText[0] = newText[0].slice(cutFront);\n\t\n\t      var chFrom = Pos(fromLine, cutFront);\n\t      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n\t      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n\t        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n\t        return true;\n\t      }\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    reset: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    forceCompositionEnd: function() {\n\t      if (!this.composing || this.composing.handled) return;\n\t      this.applyComposition(this.composing);\n\t      this.composing.handled = true;\n\t      this.div.blur();\n\t      this.div.focus();\n\t    },\n\t    applyComposition: function(composing) {\n\t      if (isReadOnly(this.cm))\n\t        operation(this.cm, regChange)(this.cm)\n\t      else if (composing.data && composing.data != composing.startData)\n\t        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n\t    },\n\t\n\t    setUneditable: function(node) {\n\t      node.contentEditable = \"false\"\n\t    },\n\t\n\t    onKeyPress: function(e) {\n\t      e.preventDefault();\n\t      if (!isReadOnly(this.cm))\n\t        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      this.div.contentEditable = String(val != \"nocursor\")\n\t    },\n\t\n\t    onContextMenu: nothing,\n\t    resetPosition: nothing,\n\t\n\t    needsContentAttribute: true\n\t  }, ContentEditableInput.prototype);\n\t\n\t  function posToDOM(cm, pos) {\n\t    var view = findViewForLine(cm, pos.line);\n\t    if (!view || view.hidden) return null;\n\t    var line = getLine(cm.doc, pos.line);\n\t    var info = mapFromLineView(view, line, pos.line);\n\t\n\t    var order = getOrder(line), side = \"left\";\n\t    if (order) {\n\t      var partPos = getBidiPartAt(order, pos.ch);\n\t      side = partPos % 2 ? \"right\" : \"left\";\n\t    }\n\t    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n\t    result.offset = result.collapse == \"right\" ? result.end : result.start;\n\t    return result;\n\t  }\n\t\n\t  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\t\n\t  function domToPos(cm, node, offset) {\n\t    var lineNode;\n\t    if (node == cm.display.lineDiv) {\n\t      lineNode = cm.display.lineDiv.childNodes[offset];\n\t      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n\t      node = null; offset = 0;\n\t    } else {\n\t      for (lineNode = node;; lineNode = lineNode.parentNode) {\n\t        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n\t        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n\t      }\n\t    }\n\t    for (var i = 0; i < cm.display.view.length; i++) {\n\t      var lineView = cm.display.view[i];\n\t      if (lineView.node == lineNode)\n\t        return locateNodeInLineView(lineView, node, offset);\n\t    }\n\t  }\n\t\n\t  function locateNodeInLineView(lineView, node, offset) {\n\t    var wrapper = lineView.text.firstChild, bad = false;\n\t    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n\t    if (node == wrapper) {\n\t      bad = true;\n\t      node = wrapper.childNodes[offset];\n\t      offset = 0;\n\t      if (!node) {\n\t        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n\t        return badPos(Pos(lineNo(line), line.text.length), bad);\n\t      }\n\t    }\n\t\n\t    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n\t    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n\t      textNode = node.firstChild;\n\t      if (offset) offset = textNode.nodeValue.length;\n\t    }\n\t    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n\t    var measure = lineView.measure, maps = measure.maps;\n\t\n\t    function find(textNode, topNode, offset) {\n\t      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n\t        var map = i < 0 ? measure.map : maps[i];\n\t        for (var j = 0; j < map.length; j += 3) {\n\t          var curNode = map[j + 2];\n\t          if (curNode == textNode || curNode == topNode) {\n\t            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n\t            var ch = map[j] + offset;\n\t            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n\t            return Pos(line, ch);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    var found = find(textNode, topNode, offset);\n\t    if (found) return badPos(found, bad);\n\t\n\t    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n\t    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n\t      found = find(after, after.firstChild, 0);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch - dist), bad);\n\t      else\n\t        dist += after.textContent.length;\n\t    }\n\t    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n\t      found = find(before, before.firstChild, -1);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch + dist), bad);\n\t      else\n\t        dist += after.textContent.length;\n\t    }\n\t  }\n\t\n\t  function domTextBetween(cm, from, to, fromLine, toLine) {\n\t    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n\t    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n\t    function walk(node) {\n\t      if (node.nodeType == 1) {\n\t        var cmText = node.getAttribute(\"cm-text\");\n\t        if (cmText != null) {\n\t          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n\t          text += cmText;\n\t          return;\n\t        }\n\t        var markerID = node.getAttribute(\"cm-marker\"), range;\n\t        if (markerID) {\n\t          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n\t          if (found.length && (range = found[0].find()))\n\t            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n\t          return;\n\t        }\n\t        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n\t        for (var i = 0; i < node.childNodes.length; i++)\n\t          walk(node.childNodes[i]);\n\t        if (/^(pre|div|p)$/i.test(node.nodeName))\n\t          closing = true;\n\t      } else if (node.nodeType == 3) {\n\t        var val = node.nodeValue;\n\t        if (!val) return;\n\t        if (closing) {\n\t          text += lineSep;\n\t          closing = false;\n\t        }\n\t        text += val;\n\t      }\n\t    }\n\t    for (;;) {\n\t      walk(from);\n\t      if (from == to) break;\n\t      from = from.nextSibling;\n\t    }\n\t    return text;\n\t  }\n\t\n\t  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\t\n\t  // SELECTION / CURSOR\n\t\n\t  // Selection objects are immutable. A new one is created every time\n\t  // the selection changes. A selection is one or more non-overlapping\n\t  // (and non-touching) ranges, sorted, and an integer that indicates\n\t  // which one is the primary selection (the one that's scrolled into\n\t  // view, that getCursor returns, etc).\n\t  function Selection(ranges, primIndex) {\n\t    this.ranges = ranges;\n\t    this.primIndex = primIndex;\n\t  }\n\t\n\t  Selection.prototype = {\n\t    primary: function() { return this.ranges[this.primIndex]; },\n\t    equals: function(other) {\n\t      if (other == this) return true;\n\t      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var here = this.ranges[i], there = other.ranges[i];\n\t        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n\t      }\n\t      return true;\n\t    },\n\t    deepCopy: function() {\n\t      for (var out = [], i = 0; i < this.ranges.length; i++)\n\t        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n\t      return new Selection(out, this.primIndex);\n\t    },\n\t    somethingSelected: function() {\n\t      for (var i = 0; i < this.ranges.length; i++)\n\t        if (!this.ranges[i].empty()) return true;\n\t      return false;\n\t    },\n\t    contains: function(pos, end) {\n\t      if (!end) end = pos;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var range = this.ranges[i];\n\t        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n\t          return i;\n\t      }\n\t      return -1;\n\t    }\n\t  };\n\t\n\t  function Range(anchor, head) {\n\t    this.anchor = anchor; this.head = head;\n\t  }\n\t\n\t  Range.prototype = {\n\t    from: function() { return minPos(this.anchor, this.head); },\n\t    to: function() { return maxPos(this.anchor, this.head); },\n\t    empty: function() {\n\t      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n\t    }\n\t  };\n\t\n\t  // Take an unsorted, potentially overlapping set of ranges, and\n\t  // build a selection out of it. 'Consumes' ranges array (modifying\n\t  // it).\n\t  function normalizeSelection(ranges, primIndex) {\n\t    var prim = ranges[primIndex];\n\t    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n\t    primIndex = indexOf(ranges, prim);\n\t    for (var i = 1; i < ranges.length; i++) {\n\t      var cur = ranges[i], prev = ranges[i - 1];\n\t      if (cmp(prev.to(), cur.from()) >= 0) {\n\t        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n\t        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n\t        if (i <= primIndex) --primIndex;\n\t        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n\t      }\n\t    }\n\t    return new Selection(ranges, primIndex);\n\t  }\n\t\n\t  function simpleSelection(anchor, head) {\n\t    return new Selection([new Range(anchor, head || anchor)], 0);\n\t  }\n\t\n\t  // Most of the external API clips given positions to make sure they\n\t  // actually exist within the document.\n\t  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n\t  function clipPos(doc, pos) {\n\t    if (pos.line < doc.first) return Pos(doc.first, 0);\n\t    var last = doc.first + doc.size - 1;\n\t    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n\t    return clipToLen(pos, getLine(doc, pos.line).text.length);\n\t  }\n\t  function clipToLen(pos, linelen) {\n\t    var ch = pos.ch;\n\t    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n\t    else if (ch < 0) return Pos(pos.line, 0);\n\t    else return pos;\n\t  }\n\t  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\t  function clipPosArray(doc, array) {\n\t    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n\t    return out;\n\t  }\n\t\n\t  // SELECTION UPDATES\n\t\n\t  // The 'scroll' parameter given to many of these indicated whether\n\t  // the new cursor position should be scrolled into view after\n\t  // modifying the selection.\n\t\n\t  // If shift is held or the extend flag is set, extends a range to\n\t  // include a given position (and optionally a second position).\n\t  // Otherwise, simply returns the range between the given positions.\n\t  // Used for cursor motion and such.\n\t  function extendRange(doc, range, head, other) {\n\t    if (doc.cm && doc.cm.display.shift || doc.extend) {\n\t      var anchor = range.anchor;\n\t      if (other) {\n\t        var posBefore = cmp(head, anchor) < 0;\n\t        if (posBefore != (cmp(other, anchor) < 0)) {\n\t          anchor = head;\n\t          head = other;\n\t        } else if (posBefore != (cmp(head, other) < 0)) {\n\t          head = other;\n\t        }\n\t      }\n\t      return new Range(anchor, head);\n\t    } else {\n\t      return new Range(other || head, head);\n\t    }\n\t  }\n\t\n\t  // Extend the primary selection range, discard the rest.\n\t  function extendSelection(doc, head, other, options) {\n\t    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n\t  }\n\t\n\t  // Extend all selections (pos is an array of selections with length\n\t  // equal the number of selections)\n\t  function extendSelections(doc, heads, options) {\n\t    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n\t      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n\t    var newSel = normalizeSelection(out, doc.sel.primIndex);\n\t    setSelection(doc, newSel, options);\n\t  }\n\t\n\t  // Updates a single range in the selection.\n\t  function replaceOneSelection(doc, i, range, options) {\n\t    var ranges = doc.sel.ranges.slice(0);\n\t    ranges[i] = range;\n\t    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n\t  }\n\t\n\t  // Reset the selection to a single range.\n\t  function setSimpleSelection(doc, anchor, head, options) {\n\t    setSelection(doc, simpleSelection(anchor, head), options);\n\t  }\n\t\n\t  // Give beforeSelectionChange handlers a change to influence a\n\t  // selection update.\n\t  function filterSelectionChange(doc, sel) {\n\t    var obj = {\n\t      ranges: sel.ranges,\n\t      update: function(ranges) {\n\t        this.ranges = [];\n\t        for (var i = 0; i < ranges.length; i++)\n\t          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n\t                                     clipPos(doc, ranges[i].head));\n\t      }\n\t    };\n\t    signal(doc, \"beforeSelectionChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n\t    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n\t    else return sel;\n\t  }\n\t\n\t  function setSelectionReplaceHistory(doc, sel, options) {\n\t    var done = doc.history.done, last = lst(done);\n\t    if (last && last.ranges) {\n\t      done[done.length - 1] = sel;\n\t      setSelectionNoUndo(doc, sel, options);\n\t    } else {\n\t      setSelection(doc, sel, options);\n\t    }\n\t  }\n\t\n\t  // Set a new selection.\n\t  function setSelection(doc, sel, options) {\n\t    setSelectionNoUndo(doc, sel, options);\n\t    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n\t  }\n\t\n\t  function setSelectionNoUndo(doc, sel, options) {\n\t    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n\t      sel = filterSelectionChange(doc, sel);\n\t\n\t    var bias = options && options.bias ||\n\t      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\t\n\t    if (!(options && options.scroll === false) && doc.cm)\n\t      ensureCursorVisible(doc.cm);\n\t  }\n\t\n\t  function setSelectionInner(doc, sel) {\n\t    if (sel.equals(doc.sel)) return;\n\t\n\t    doc.sel = sel;\n\t\n\t    if (doc.cm) {\n\t      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n\t      signalCursorActivity(doc.cm);\n\t    }\n\t    signalLater(doc, \"cursorActivity\", doc);\n\t  }\n\t\n\t  // Verify that the selection does not partially select any atomic\n\t  // marked ranges.\n\t  function reCheckSelection(doc) {\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n\t  }\n\t\n\t  // Return a selection that does not partially select any atomic\n\t  // ranges.\n\t  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n\t    var out;\n\t    for (var i = 0; i < sel.ranges.length; i++) {\n\t      var range = sel.ranges[i];\n\t      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);\n\t      var newHead = skipAtomic(doc, range.head, bias, mayClear);\n\t      if (out || newAnchor != range.anchor || newHead != range.head) {\n\t        if (!out) out = sel.ranges.slice(0, i);\n\t        out[i] = new Range(newAnchor, newHead);\n\t      }\n\t    }\n\t    return out ? normalizeSelection(out, sel.primIndex) : sel;\n\t  }\n\t\n\t  // Ensure a given position is not inside an atomic range.\n\t  function skipAtomic(doc, pos, bias, mayClear) {\n\t    var flipped = false, curPos = pos;\n\t    var dir = bias || 1;\n\t    doc.cantEdit = false;\n\t    search: for (;;) {\n\t      var line = getLine(doc, curPos.line);\n\t      if (line.markedSpans) {\n\t        for (var i = 0; i < line.markedSpans.length; ++i) {\n\t          var sp = line.markedSpans[i], m = sp.marker;\n\t          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n\t              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n\t            if (mayClear) {\n\t              signal(m, \"beforeCursorEnter\");\n\t              if (m.explicitlyCleared) {\n\t                if (!line.markedSpans) break;\n\t                else {--i; continue;}\n\t              }\n\t            }\n\t            if (!m.atomic) continue;\n\t            var newPos = m.find(dir < 0 ? -1 : 1);\n\t            if (cmp(newPos, curPos) == 0) {\n\t              newPos.ch += dir;\n\t              if (newPos.ch < 0) {\n\t                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n\t                else newPos = null;\n\t              } else if (newPos.ch > line.text.length) {\n\t                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n\t                else newPos = null;\n\t              }\n\t              if (!newPos) {\n\t                if (flipped) {\n\t                  // Driven in a corner -- no valid cursor position found at all\n\t                  // -- try again *with* clearing, if we didn't already\n\t                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n\t                  // Otherwise, turn off editing until further notice, and return the start of the doc\n\t                  doc.cantEdit = true;\n\t                  return Pos(doc.first, 0);\n\t                }\n\t                flipped = true; newPos = pos; dir = -dir;\n\t              }\n\t            }\n\t            curPos = newPos;\n\t            continue search;\n\t          }\n\t        }\n\t      }\n\t      return curPos;\n\t    }\n\t  }\n\t\n\t  // SELECTION DRAWING\n\t\n\t  function updateSelection(cm) {\n\t    cm.display.input.showSelection(cm.display.input.prepareSelection());\n\t  }\n\t\n\t  function prepareSelection(cm, primary) {\n\t    var doc = cm.doc, result = {};\n\t    var curFragment = result.cursors = document.createDocumentFragment();\n\t    var selFragment = result.selection = document.createDocumentFragment();\n\t\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      if (primary === false && i == doc.sel.primIndex) continue;\n\t      var range = doc.sel.ranges[i];\n\t      var collapsed = range.empty();\n\t      if (collapsed || cm.options.showCursorWhenSelecting)\n\t        drawSelectionCursor(cm, range.head, curFragment);\n\t      if (!collapsed)\n\t        drawSelectionRange(cm, range, selFragment);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  // Draws a cursor for the given range\n\t  function drawSelectionCursor(cm, head, output) {\n\t    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\t\n\t    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n\t    cursor.style.left = pos.left + \"px\";\n\t    cursor.style.top = pos.top + \"px\";\n\t    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\t\n\t    if (pos.other) {\n\t      // Secondary cursor, shown when on a 'jump' in bi-directional text\n\t      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n\t      otherCursor.style.display = \"\";\n\t      otherCursor.style.left = pos.other.left + \"px\";\n\t      otherCursor.style.top = pos.other.top + \"px\";\n\t      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n\t    }\n\t  }\n\t\n\t  // Draws the given range as a highlighted selection\n\t  function drawSelectionRange(cm, range, output) {\n\t    var display = cm.display, doc = cm.doc;\n\t    var fragment = document.createDocumentFragment();\n\t    var padding = paddingH(cm.display), leftSide = padding.left;\n\t    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\t\n\t    function add(left, top, width, bottom) {\n\t      if (top < 0) top = 0;\n\t      top = Math.round(top);\n\t      bottom = Math.round(bottom);\n\t      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n\t                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n\t                               \"px; height: \" + (bottom - top) + \"px\"));\n\t    }\n\t\n\t    function drawForLine(line, fromArg, toArg) {\n\t      var lineObj = getLine(doc, line);\n\t      var lineLen = lineObj.text.length;\n\t      var start, end;\n\t      function coords(ch, bias) {\n\t        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n\t      }\n\t\n\t      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n\t        var leftPos = coords(from, \"left\"), rightPos, left, right;\n\t        if (from == to) {\n\t          rightPos = leftPos;\n\t          left = right = leftPos.left;\n\t        } else {\n\t          rightPos = coords(to - 1, \"right\");\n\t          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n\t          left = leftPos.left;\n\t          right = rightPos.right;\n\t        }\n\t        if (fromArg == null && from == 0) left = leftSide;\n\t        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n\t          add(left, leftPos.top, null, leftPos.bottom);\n\t          left = leftSide;\n\t          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n\t        }\n\t        if (toArg == null && to == lineLen) right = rightSide;\n\t        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n\t          start = leftPos;\n\t        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n\t          end = rightPos;\n\t        if (left < leftSide + 1) left = leftSide;\n\t        add(left, rightPos.top, right - left, rightPos.bottom);\n\t      });\n\t      return {start: start, end: end};\n\t    }\n\t\n\t    var sFrom = range.from(), sTo = range.to();\n\t    if (sFrom.line == sTo.line) {\n\t      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n\t    } else {\n\t      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n\t      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n\t      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n\t      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n\t      if (singleVLine) {\n\t        if (leftEnd.top < rightStart.top - 2) {\n\t          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n\t          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n\t        } else {\n\t          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n\t        }\n\t      }\n\t      if (leftEnd.bottom < rightStart.top)\n\t        add(leftSide, leftEnd.bottom, null, rightStart.top);\n\t    }\n\t\n\t    output.appendChild(fragment);\n\t  }\n\t\n\t  // Cursor-blinking\n\t  function restartBlink(cm) {\n\t    if (!cm.state.focused) return;\n\t    var display = cm.display;\n\t    clearInterval(display.blinker);\n\t    var on = true;\n\t    display.cursorDiv.style.visibility = \"\";\n\t    if (cm.options.cursorBlinkRate > 0)\n\t      display.blinker = setInterval(function() {\n\t        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n\t      }, cm.options.cursorBlinkRate);\n\t    else if (cm.options.cursorBlinkRate < 0)\n\t      display.cursorDiv.style.visibility = \"hidden\";\n\t  }\n\t\n\t  // HIGHLIGHT WORKER\n\t\n\t  function startWorker(cm, time) {\n\t    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n\t      cm.state.highlight.set(time, bind(highlightWorker, cm));\n\t  }\n\t\n\t  function highlightWorker(cm) {\n\t    var doc = cm.doc;\n\t    if (doc.frontier < doc.first) doc.frontier = doc.first;\n\t    if (doc.frontier >= cm.display.viewTo) return;\n\t    var end = +new Date + cm.options.workTime;\n\t    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n\t    var changedLines = [];\n\t\n\t    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n\t      if (doc.frontier >= cm.display.viewFrom) { // Visible\n\t        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n\t        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n\t        line.styles = highlighted.styles;\n\t        var oldCls = line.styleClasses, newCls = highlighted.classes;\n\t        if (newCls) line.styleClasses = newCls;\n\t        else if (oldCls) line.styleClasses = null;\n\t        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n\t          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n\t        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n\t        if (ischange) changedLines.push(doc.frontier);\n\t        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n\t      } else {\n\t        if (line.text.length <= cm.options.maxHighlightLength)\n\t          processLine(cm, line.text, state);\n\t        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n\t      }\n\t      ++doc.frontier;\n\t      if (+new Date > end) {\n\t        startWorker(cm, cm.options.workDelay);\n\t        return true;\n\t      }\n\t    });\n\t    if (changedLines.length) runInOp(cm, function() {\n\t      for (var i = 0; i < changedLines.length; i++)\n\t        regLineChange(cm, changedLines[i], \"text\");\n\t    });\n\t  }\n\t\n\t  // Finds the line to start with when starting a parse. Tries to\n\t  // find a line with a stateAfter, so that it can start with a\n\t  // valid state. If that fails, it returns the line with the\n\t  // smallest indentation, which tends to need the least context to\n\t  // parse correctly.\n\t  function findStartLine(cm, n, precise) {\n\t    var minindent, minline, doc = cm.doc;\n\t    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n\t    for (var search = n; search > lim; --search) {\n\t      if (search <= doc.first) return doc.first;\n\t      var line = getLine(doc, search - 1);\n\t      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n\t      var indented = countColumn(line.text, null, cm.options.tabSize);\n\t      if (minline == null || minindent > indented) {\n\t        minline = search - 1;\n\t        minindent = indented;\n\t      }\n\t    }\n\t    return minline;\n\t  }\n\t\n\t  function getStateBefore(cm, n, precise) {\n\t    var doc = cm.doc, display = cm.display;\n\t    if (!doc.mode.startState) return true;\n\t    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n\t    if (!state) state = startState(doc.mode);\n\t    else state = copyState(doc.mode, state);\n\t    doc.iter(pos, n, function(line) {\n\t      processLine(cm, line.text, state);\n\t      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n\t      line.stateAfter = save ? copyState(doc.mode, state) : null;\n\t      ++pos;\n\t    });\n\t    if (precise) doc.frontier = pos;\n\t    return state;\n\t  }\n\t\n\t  // POSITION MEASUREMENT\n\t\n\t  function paddingTop(display) {return display.lineSpace.offsetTop;}\n\t  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n\t  function paddingH(display) {\n\t    if (display.cachedPaddingH) return display.cachedPaddingH;\n\t    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n\t    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n\t    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n\t    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n\t    return data;\n\t  }\n\t\n\t  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n\t  function displayWidth(cm) {\n\t    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n\t  }\n\t  function displayHeight(cm) {\n\t    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n\t  }\n\t\n\t  // Ensure the lineView.wrapping.heights array is populated. This is\n\t  // an array of bottom offsets for the lines that make up a drawn\n\t  // line. When lineWrapping is on, there might be more than one\n\t  // height.\n\t  function ensureLineHeights(cm, lineView, rect) {\n\t    var wrapping = cm.options.lineWrapping;\n\t    var curWidth = wrapping && displayWidth(cm);\n\t    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n\t      var heights = lineView.measure.heights = [];\n\t      if (wrapping) {\n\t        lineView.measure.width = curWidth;\n\t        var rects = lineView.text.firstChild.getClientRects();\n\t        for (var i = 0; i < rects.length - 1; i++) {\n\t          var cur = rects[i], next = rects[i + 1];\n\t          if (Math.abs(cur.bottom - next.bottom) > 2)\n\t            heights.push((cur.bottom + next.top) / 2 - rect.top);\n\t        }\n\t      }\n\t      heights.push(rect.bottom - rect.top);\n\t    }\n\t  }\n\t\n\t  // Find a line map (mapping character offsets to text nodes) and a\n\t  // measurement cache for the given line number. (A line view might\n\t  // contain multiple lines when collapsed ranges are present.)\n\t  function mapFromLineView(lineView, line, lineN) {\n\t    if (lineView.line == line)\n\t      return {map: lineView.measure.map, cache: lineView.measure.cache};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineView.rest[i] == line)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineNo(lineView.rest[i]) > lineN)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n\t  }\n\t\n\t  // Render a line into the hidden node display.externalMeasured. Used\n\t  // when measurement is needed for a line that's not in the viewport.\n\t  function updateExternalMeasurement(cm, line) {\n\t    line = visualLine(line);\n\t    var lineN = lineNo(line);\n\t    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n\t    view.lineN = lineN;\n\t    var built = view.built = buildLineContent(cm, view);\n\t    view.text = built.pre;\n\t    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n\t    return view;\n\t  }\n\t\n\t  // Get a {top, bottom, left, right} box (in line-local coordinates)\n\t  // for a given character.\n\t  function measureChar(cm, line, ch, bias) {\n\t    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n\t  }\n\t\n\t  // Find a line view that corresponds to the given line number.\n\t  function findViewForLine(cm, lineN) {\n\t    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n\t      return cm.display.view[findViewIndex(cm, lineN)];\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n\t      return ext;\n\t  }\n\t\n\t  // Measurement can be split in two steps, the set-up work that\n\t  // applies to the whole line, and the measurement of the actual\n\t  // character. Functions like coordsChar, that need to do a lot of\n\t  // measurements in a row, can thus ensure that the set-up work is\n\t  // only done once.\n\t  function prepareMeasureForLine(cm, line) {\n\t    var lineN = lineNo(line);\n\t    var view = findViewForLine(cm, lineN);\n\t    if (view && !view.text) {\n\t      view = null;\n\t    } else if (view && view.changes) {\n\t      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n\t      cm.curOp.forceUpdate = true;\n\t    }\n\t    if (!view)\n\t      view = updateExternalMeasurement(cm, line);\n\t\n\t    var info = mapFromLineView(view, line, lineN);\n\t    return {\n\t      line: line, view: view, rect: null,\n\t      map: info.map, cache: info.cache, before: info.before,\n\t      hasHeights: false\n\t    };\n\t  }\n\t\n\t  // Given a prepared measurement object, measures the position of an\n\t  // actual character (or fetches it from the cache).\n\t  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n\t    if (prepared.before) ch = -1;\n\t    var key = ch + (bias || \"\"), found;\n\t    if (prepared.cache.hasOwnProperty(key)) {\n\t      found = prepared.cache[key];\n\t    } else {\n\t      if (!prepared.rect)\n\t        prepared.rect = prepared.view.text.getBoundingClientRect();\n\t      if (!prepared.hasHeights) {\n\t        ensureLineHeights(cm, prepared.view, prepared.rect);\n\t        prepared.hasHeights = true;\n\t      }\n\t      found = measureCharInner(cm, prepared, ch, bias);\n\t      if (!found.bogus) prepared.cache[key] = found;\n\t    }\n\t    return {left: found.left, right: found.right,\n\t            top: varHeight ? found.rtop : found.top,\n\t            bottom: varHeight ? found.rbottom : found.bottom};\n\t  }\n\t\n\t  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\t\n\t  function nodeAndOffsetInLineMap(map, ch, bias) {\n\t    var node, start, end, collapse;\n\t    // First, search the line map for the text node corresponding to,\n\t    // or closest to, the target character.\n\t    for (var i = 0; i < map.length; i += 3) {\n\t      var mStart = map[i], mEnd = map[i + 1];\n\t      if (ch < mStart) {\n\t        start = 0; end = 1;\n\t        collapse = \"left\";\n\t      } else if (ch < mEnd) {\n\t        start = ch - mStart;\n\t        end = start + 1;\n\t      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n\t        end = mEnd - mStart;\n\t        start = end - 1;\n\t        if (ch >= mEnd) collapse = \"right\";\n\t      }\n\t      if (start != null) {\n\t        node = map[i + 2];\n\t        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n\t          collapse = bias;\n\t        if (bias == \"left\" && start == 0)\n\t          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n\t            node = map[(i -= 3) + 2];\n\t            collapse = \"left\";\n\t          }\n\t        if (bias == \"right\" && start == mEnd - mStart)\n\t          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n\t            node = map[(i += 3) + 2];\n\t            collapse = \"right\";\n\t          }\n\t        break;\n\t      }\n\t    }\n\t    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n\t  }\n\t\n\t  function measureCharInner(cm, prepared, ch, bias) {\n\t    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n\t    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\t\n\t    var rect;\n\t    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n\t      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n\t        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n\t        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n\t        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n\t          rect = node.parentNode.getBoundingClientRect();\n\t        } else if (ie && cm.options.lineWrapping) {\n\t          var rects = range(node, start, end).getClientRects();\n\t          if (rects.length)\n\t            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n\t          else\n\t            rect = nullRect;\n\t        } else {\n\t          rect = range(node, start, end).getBoundingClientRect() || nullRect;\n\t        }\n\t        if (rect.left || rect.right || start == 0) break;\n\t        end = start;\n\t        start = start - 1;\n\t        collapse = \"right\";\n\t      }\n\t      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n\t    } else { // If it is a widget, simply get the box for the whole widget.\n\t      if (start > 0) collapse = bias = \"right\";\n\t      var rects;\n\t      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n\t        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n\t      else\n\t        rect = node.getBoundingClientRect();\n\t    }\n\t    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n\t      var rSpan = node.parentNode.getClientRects()[0];\n\t      if (rSpan)\n\t        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n\t      else\n\t        rect = nullRect;\n\t    }\n\t\n\t    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n\t    var mid = (rtop + rbot) / 2;\n\t    var heights = prepared.view.measure.heights;\n\t    for (var i = 0; i < heights.length - 1; i++)\n\t      if (mid < heights[i]) break;\n\t    var top = i ? heights[i - 1] : 0, bot = heights[i];\n\t    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n\t                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n\t                  top: top, bottom: bot};\n\t    if (!rect.left && !rect.right) result.bogus = true;\n\t    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\t\n\t    return result;\n\t  }\n\t\n\t  // Work around problem with bounding client rects on ranges being\n\t  // returned incorrectly when zoomed on IE10 and below.\n\t  function maybeUpdateRectForZooming(measure, rect) {\n\t    if (!window.screen || screen.logicalXDPI == null ||\n\t        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n\t      return rect;\n\t    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n\t    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n\t    return {left: rect.left * scaleX, right: rect.right * scaleX,\n\t            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n\t  }\n\t\n\t  function clearLineMeasurementCacheFor(lineView) {\n\t    if (lineView.measure) {\n\t      lineView.measure.cache = {};\n\t      lineView.measure.heights = null;\n\t      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t        lineView.measure.caches[i] = {};\n\t    }\n\t  }\n\t\n\t  function clearLineMeasurementCache(cm) {\n\t    cm.display.externalMeasure = null;\n\t    removeChildren(cm.display.lineMeasure);\n\t    for (var i = 0; i < cm.display.view.length; i++)\n\t      clearLineMeasurementCacheFor(cm.display.view[i]);\n\t  }\n\t\n\t  function clearCaches(cm) {\n\t    clearLineMeasurementCache(cm);\n\t    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n\t    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n\t    cm.display.lineNumChars = null;\n\t  }\n\t\n\t  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n\t  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\t\n\t  // Converts a {top, bottom, left, right} box from line-local\n\t  // coordinates into another coordinate system. Context may be one of\n\t  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n\t  // or \"page\".\n\t  function intoCoordSystem(cm, lineObj, rect, context) {\n\t    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n\t      var size = widgetHeight(lineObj.widgets[i]);\n\t      rect.top += size; rect.bottom += size;\n\t    }\n\t    if (context == \"line\") return rect;\n\t    if (!context) context = \"local\";\n\t    var yOff = heightAtLine(lineObj);\n\t    if (context == \"local\") yOff += paddingTop(cm.display);\n\t    else yOff -= cm.display.viewOffset;\n\t    if (context == \"page\" || context == \"window\") {\n\t      var lOff = cm.display.lineSpace.getBoundingClientRect();\n\t      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n\t      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n\t      rect.left += xOff; rect.right += xOff;\n\t    }\n\t    rect.top += yOff; rect.bottom += yOff;\n\t    return rect;\n\t  }\n\t\n\t  // Coverts a box from \"div\" coords to another coordinate system.\n\t  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n\t  function fromCoordSystem(cm, coords, context) {\n\t    if (context == \"div\") return coords;\n\t    var left = coords.left, top = coords.top;\n\t    // First move into \"page\" coordinate system\n\t    if (context == \"page\") {\n\t      left -= pageScrollX();\n\t      top -= pageScrollY();\n\t    } else if (context == \"local\" || !context) {\n\t      var localBox = cm.display.sizer.getBoundingClientRect();\n\t      left += localBox.left;\n\t      top += localBox.top;\n\t    }\n\t\n\t    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n\t    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n\t  }\n\t\n\t  function charCoords(cm, pos, context, lineObj, bias) {\n\t    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n\t    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n\t  }\n\t\n\t  // Returns a box for a given cursor position, which may have an\n\t  // 'other' property containing the position of the secondary cursor\n\t  // on a bidi boundary.\n\t  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n\t    lineObj = lineObj || getLine(cm.doc, pos.line);\n\t    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t    function get(ch, right) {\n\t      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n\t      if (right) m.left = m.right; else m.right = m.left;\n\t      return intoCoordSystem(cm, lineObj, m, context);\n\t    }\n\t    function getBidi(ch, partPos) {\n\t      var part = order[partPos], right = part.level % 2;\n\t      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n\t        part = order[--partPos];\n\t        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n\t        right = true;\n\t      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n\t        part = order[++partPos];\n\t        ch = bidiLeft(part) - part.level % 2;\n\t        right = false;\n\t      }\n\t      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n\t      return get(ch, right);\n\t    }\n\t    var order = getOrder(lineObj), ch = pos.ch;\n\t    if (!order) return get(ch);\n\t    var partPos = getBidiPartAt(order, ch);\n\t    var val = getBidi(ch, partPos);\n\t    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n\t    return val;\n\t  }\n\t\n\t  // Used to cheaply estimate the coordinates for a position. Used for\n\t  // intermediate scroll updates.\n\t  function estimateCoords(cm, pos) {\n\t    var left = 0, pos = clipPos(cm.doc, pos);\n\t    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n\t    var lineObj = getLine(cm.doc, pos.line);\n\t    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n\t    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n\t  }\n\t\n\t  // Positions returned by coordsChar contain some extra information.\n\t  // xRel is the relative x position of the input coordinates compared\n\t  // to the found position (so xRel > 0 means the coordinates are to\n\t  // the right of the character position, for example). When outside\n\t  // is true, that means the coordinates lie outside the line's\n\t  // vertical range.\n\t  function PosWithInfo(line, ch, outside, xRel) {\n\t    var pos = Pos(line, ch);\n\t    pos.xRel = xRel;\n\t    if (outside) pos.outside = true;\n\t    return pos;\n\t  }\n\t\n\t  // Compute the character position closest to the given coordinates.\n\t  // Input must be lineSpace-local (\"div\" coordinate system).\n\t  function coordsChar(cm, x, y) {\n\t    var doc = cm.doc;\n\t    y += cm.display.viewOffset;\n\t    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n\t    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n\t    if (lineN > last)\n\t      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n\t    if (x < 0) x = 0;\n\t\n\t    var lineObj = getLine(doc, lineN);\n\t    for (;;) {\n\t      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n\t      var merged = collapsedSpanAtEnd(lineObj);\n\t      var mergedPos = merged && merged.find(0, true);\n\t      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n\t        lineN = lineNo(lineObj = mergedPos.to.line);\n\t      else\n\t        return found;\n\t    }\n\t  }\n\t\n\t  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n\t    var innerOff = y - heightAtLine(lineObj);\n\t    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n\t    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t\n\t    function getX(ch) {\n\t      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n\t      wrongLine = true;\n\t      if (innerOff > sp.bottom) return sp.left - adjust;\n\t      else if (innerOff < sp.top) return sp.left + adjust;\n\t      else wrongLine = false;\n\t      return sp.left;\n\t    }\n\t\n\t    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n\t    var from = lineLeft(lineObj), to = lineRight(lineObj);\n\t    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\t\n\t    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n\t    // Do a binary search between these bounds.\n\t    for (;;) {\n\t      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n\t        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n\t        var xDiff = x - (ch == from ? fromX : toX);\n\t        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n\t        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n\t                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n\t        return pos;\n\t      }\n\t      var step = Math.ceil(dist / 2), middle = from + step;\n\t      if (bidi) {\n\t        middle = from;\n\t        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n\t      }\n\t      var middleX = getX(middle);\n\t      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n\t      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n\t    }\n\t  }\n\t\n\t  var measureText;\n\t  // Compute the default text height.\n\t  function textHeight(display) {\n\t    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n\t    if (measureText == null) {\n\t      measureText = elt(\"pre\");\n\t      // Measure a bunch of lines, for browsers that compute\n\t      // fractional heights.\n\t      for (var i = 0; i < 49; ++i) {\n\t        measureText.appendChild(document.createTextNode(\"x\"));\n\t        measureText.appendChild(elt(\"br\"));\n\t      }\n\t      measureText.appendChild(document.createTextNode(\"x\"));\n\t    }\n\t    removeChildrenAndAdd(display.measure, measureText);\n\t    var height = measureText.offsetHeight / 50;\n\t    if (height > 3) display.cachedTextHeight = height;\n\t    removeChildren(display.measure);\n\t    return height || 1;\n\t  }\n\t\n\t  // Compute the default character width.\n\t  function charWidth(display) {\n\t    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n\t    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n\t    var pre = elt(\"pre\", [anchor]);\n\t    removeChildrenAndAdd(display.measure, pre);\n\t    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n\t    if (width > 2) display.cachedCharWidth = width;\n\t    return width || 10;\n\t  }\n\t\n\t  // OPERATIONS\n\t\n\t  // Operations are used to wrap a series of changes to the editor\n\t  // state in such a way that each change won't have to update the\n\t  // cursor and display (which would be awkward, slow, and\n\t  // error-prone). Instead, display updates are batched and then all\n\t  // combined and executed at once.\n\t\n\t  var operationGroup = null;\n\t\n\t  var nextOpId = 0;\n\t  // Start a new operation.\n\t  function startOperation(cm) {\n\t    cm.curOp = {\n\t      cm: cm,\n\t      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n\t      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n\t      forceUpdate: false,      // Used to force a redraw\n\t      updateInput: null,       // Whether to reset the input textarea\n\t      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n\t      changeObjs: null,        // Accumulated changes, for firing change events\n\t      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n\t      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n\t      selectionChanged: false, // Whether the selection needs to be redrawn\n\t      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n\t      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n\t      scrollToPos: null,       // Used to scroll to a specific position\n\t      focus: false,\n\t      id: ++nextOpId           // Unique ID\n\t    };\n\t    if (operationGroup) {\n\t      operationGroup.ops.push(cm.curOp);\n\t    } else {\n\t      cm.curOp.ownsGroup = operationGroup = {\n\t        ops: [cm.curOp],\n\t        delayedCallbacks: []\n\t      };\n\t    }\n\t  }\n\t\n\t  function fireCallbacksForOps(group) {\n\t    // Calls delayed callbacks and cursorActivity handlers until no\n\t    // new ones appear\n\t    var callbacks = group.delayedCallbacks, i = 0;\n\t    do {\n\t      for (; i < callbacks.length; i++)\n\t        callbacks[i].call(null);\n\t      for (var j = 0; j < group.ops.length; j++) {\n\t        var op = group.ops[j];\n\t        if (op.cursorActivityHandlers)\n\t          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n\t            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n\t      }\n\t    } while (i < callbacks.length);\n\t  }\n\t\n\t  // Finish an operation, updating the display and signalling delayed events\n\t  function endOperation(cm) {\n\t    var op = cm.curOp, group = op.ownsGroup;\n\t    if (!group) return;\n\t\n\t    try { fireCallbacksForOps(group); }\n\t    finally {\n\t      operationGroup = null;\n\t      for (var i = 0; i < group.ops.length; i++)\n\t        group.ops[i].cm.curOp = null;\n\t      endOperations(group);\n\t    }\n\t  }\n\t\n\t  // The DOM updates done when an operation finishes are batched so\n\t  // that the minimum number of relayouts are required.\n\t  function endOperations(group) {\n\t    var ops = group.ops;\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_finish(ops[i]);\n\t  }\n\t\n\t  function endOperation_R1(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    maybeClipScrollbars(cm);\n\t    if (op.updateMaxLine) findMaxLine(cm);\n\t\n\t    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n\t      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n\t                         op.scrollToPos.to.line >= display.viewTo) ||\n\t      display.maxLineChanged && cm.options.lineWrapping;\n\t    op.update = op.mustUpdate &&\n\t      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n\t  }\n\t\n\t  function endOperation_W1(op) {\n\t    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n\t  }\n\t\n\t  function endOperation_R2(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\t\n\t    op.barMeasure = measureForScrollbars(cm);\n\t\n\t    // If the max line changed since it was last measured, measure it,\n\t    // and ensure the document's width matches it.\n\t    // updateDisplay_W2 will use these properties to do the actual resizing\n\t    if (display.maxLineChanged && !cm.options.lineWrapping) {\n\t      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n\t      cm.display.sizerWidth = op.adjustWidthTo;\n\t      op.barMeasure.scrollWidth =\n\t        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n\t      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n\t    }\n\t\n\t    if (op.updatedDisplay || op.selectionChanged)\n\t      op.preparedSelection = display.input.prepareSelection();\n\t  }\n\t\n\t  function endOperation_W2(op) {\n\t    var cm = op.cm;\n\t\n\t    if (op.adjustWidthTo != null) {\n\t      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n\t      if (op.maxScrollLeft < cm.doc.scrollLeft)\n\t        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n\t      cm.display.maxLineChanged = false;\n\t    }\n\t\n\t    if (op.preparedSelection)\n\t      cm.display.input.showSelection(op.preparedSelection);\n\t    if (op.updatedDisplay)\n\t      setDocumentHeight(cm, op.barMeasure);\n\t    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n\t      updateScrollbars(cm, op.barMeasure);\n\t\n\t    if (op.selectionChanged) restartBlink(cm);\n\t\n\t    if (cm.state.focused && op.updateInput)\n\t      cm.display.input.reset(op.typing);\n\t    if (op.focus && op.focus == activeElt()) ensureFocus(op.cm);\n\t  }\n\t\n\t  function endOperation_finish(op) {\n\t    var cm = op.cm, display = cm.display, doc = cm.doc;\n\t\n\t    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\t\n\t    // Abort mouse wheel delta measurement, when scrolling explicitly\n\t    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n\t      display.wheelStartX = display.wheelStartY = null;\n\t\n\t    // Propagate the scroll position to the actual DOM scroller\n\t    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n\t      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n\t      display.scrollbars.setScrollTop(doc.scrollTop);\n\t      display.scroller.scrollTop = doc.scrollTop;\n\t    }\n\t    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n\t      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));\n\t      display.scrollbars.setScrollLeft(doc.scrollLeft);\n\t      display.scroller.scrollLeft = doc.scrollLeft;\n\t      alignHorizontally(cm);\n\t    }\n\t    // If we need to scroll a specific position into view, do so.\n\t    if (op.scrollToPos) {\n\t      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n\t                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n\t      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n\t    }\n\t\n\t    // Fire events for markers that are hidden/unidden by editing or\n\t    // undoing\n\t    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n\t    if (hidden) for (var i = 0; i < hidden.length; ++i)\n\t      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n\t    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n\t      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\t\n\t    if (display.wrapper.offsetHeight)\n\t      doc.scrollTop = cm.display.scroller.scrollTop;\n\t\n\t    // Fire change events, and delayed event handlers\n\t    if (op.changeObjs)\n\t      signal(cm, \"changes\", cm, op.changeObjs);\n\t    if (op.update)\n\t      op.update.finish();\n\t  }\n\t\n\t  // Run the given function in an operation\n\t  function runInOp(cm, f) {\n\t    if (cm.curOp) return f();\n\t    startOperation(cm);\n\t    try { return f(); }\n\t    finally { endOperation(cm); }\n\t  }\n\t  // Wraps a function in an operation. Returns the wrapped function.\n\t  function operation(cm, f) {\n\t    return function() {\n\t      if (cm.curOp) return f.apply(cm, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(cm, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t  // Used to add methods to editor and doc instances, wrapping them in\n\t  // operations.\n\t  function methodOp(f) {\n\t    return function() {\n\t      if (this.curOp) return f.apply(this, arguments);\n\t      startOperation(this);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(this); }\n\t    };\n\t  }\n\t  function docMethodOp(f) {\n\t    return function() {\n\t      var cm = this.cm;\n\t      if (!cm || cm.curOp) return f.apply(this, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t\n\t  // VIEW TRACKING\n\t\n\t  // These objects are used to represent the visible (currently drawn)\n\t  // part of the document. A LineView may correspond to multiple\n\t  // logical lines, if those are connected by collapsed ranges.\n\t  function LineView(doc, line, lineN) {\n\t    // The starting line\n\t    this.line = line;\n\t    // Continuing lines, if any\n\t    this.rest = visualLineContinued(line);\n\t    // Number of logical lines in this visual line\n\t    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n\t    this.node = this.text = null;\n\t    this.hidden = lineIsHidden(doc, line);\n\t  }\n\t\n\t  // Create a range of LineView objects for the given lines.\n\t  function buildViewArray(cm, from, to) {\n\t    var array = [], nextPos;\n\t    for (var pos = from; pos < to; pos = nextPos) {\n\t      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n\t      nextPos = pos + view.size;\n\t      array.push(view);\n\t    }\n\t    return array;\n\t  }\n\t\n\t  // Updates the display.view data structure for a given change to the\n\t  // document. From and to are in pre-change coordinates. Lendiff is\n\t  // the amount of lines added or subtracted by the change. This is\n\t  // used for changes that span multiple lines, or change the way\n\t  // lines are divided into visual lines. regLineChange (below)\n\t  // registers single-line changes.\n\t  function regChange(cm, from, to, lendiff) {\n\t    if (from == null) from = cm.doc.first;\n\t    if (to == null) to = cm.doc.first + cm.doc.size;\n\t    if (!lendiff) lendiff = 0;\n\t\n\t    var display = cm.display;\n\t    if (lendiff && to < display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n\t      display.updateLineNumbers = from;\n\t\n\t    cm.curOp.viewChanged = true;\n\t\n\t    if (from >= display.viewTo) { // Change after\n\t      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n\t        resetView(cm);\n\t    } else if (to <= display.viewFrom) { // Change before\n\t      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n\t        resetView(cm);\n\t      } else {\n\t        display.viewFrom += lendiff;\n\t        display.viewTo += lendiff;\n\t      }\n\t    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n\t      resetView(cm);\n\t    } else if (from <= display.viewFrom) { // Top overlap\n\t      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cut) {\n\t        display.view = display.view.slice(cut.index);\n\t        display.viewFrom = cut.lineN;\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else if (to >= display.viewTo) { // Bottom overlap\n\t      var cut = viewCuttingPoint(cm, from, from, -1);\n\t      if (cut) {\n\t        display.view = display.view.slice(0, cut.index);\n\t        display.viewTo = cut.lineN;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else { // Gap in the middle\n\t      var cutTop = viewCuttingPoint(cm, from, from, -1);\n\t      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cutTop && cutBot) {\n\t        display.view = display.view.slice(0, cutTop.index)\n\t          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n\t          .concat(display.view.slice(cutBot.index));\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    }\n\t\n\t    var ext = display.externalMeasured;\n\t    if (ext) {\n\t      if (to < ext.lineN)\n\t        ext.lineN += lendiff;\n\t      else if (from < ext.lineN + ext.size)\n\t        display.externalMeasured = null;\n\t    }\n\t  }\n\t\n\t  // Register a change to a single line. Type must be one of \"text\",\n\t  // \"gutter\", \"class\", \"widget\"\n\t  function regLineChange(cm, line, type) {\n\t    cm.curOp.viewChanged = true;\n\t    var display = cm.display, ext = cm.display.externalMeasured;\n\t    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n\t      display.externalMeasured = null;\n\t\n\t    if (line < display.viewFrom || line >= display.viewTo) return;\n\t    var lineView = display.view[findViewIndex(cm, line)];\n\t    if (lineView.node == null) return;\n\t    var arr = lineView.changes || (lineView.changes = []);\n\t    if (indexOf(arr, type) == -1) arr.push(type);\n\t  }\n\t\n\t  // Clear the view.\n\t  function resetView(cm) {\n\t    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n\t    cm.display.view = [];\n\t    cm.display.viewOffset = 0;\n\t  }\n\t\n\t  // Find the view element corresponding to a given line. Return null\n\t  // when the line isn't visible.\n\t  function findViewIndex(cm, n) {\n\t    if (n >= cm.display.viewTo) return null;\n\t    n -= cm.display.viewFrom;\n\t    if (n < 0) return null;\n\t    var view = cm.display.view;\n\t    for (var i = 0; i < view.length; i++) {\n\t      n -= view[i].size;\n\t      if (n < 0) return i;\n\t    }\n\t  }\n\t\n\t  function viewCuttingPoint(cm, oldN, newN, dir) {\n\t    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n\t    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n\t      return {index: index, lineN: newN};\n\t    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n\t      n += view[i].size;\n\t    if (n != oldN) {\n\t      if (dir > 0) {\n\t        if (index == view.length - 1) return null;\n\t        diff = (n + view[index].size) - oldN;\n\t        index++;\n\t      } else {\n\t        diff = n - oldN;\n\t      }\n\t      oldN += diff; newN += diff;\n\t    }\n\t    while (visualLineNo(cm.doc, newN) != newN) {\n\t      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n\t      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n\t      index += dir;\n\t    }\n\t    return {index: index, lineN: newN};\n\t  }\n\t\n\t  // Force the view to cover a given range, adding empty view element\n\t  // or clipping off existing ones as needed.\n\t  function adjustView(cm, from, to) {\n\t    var display = cm.display, view = display.view;\n\t    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n\t      display.view = buildViewArray(cm, from, to);\n\t      display.viewFrom = from;\n\t    } else {\n\t      if (display.viewFrom > from)\n\t        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n\t      else if (display.viewFrom < from)\n\t        display.view = display.view.slice(findViewIndex(cm, from));\n\t      display.viewFrom = from;\n\t      if (display.viewTo < to)\n\t        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n\t      else if (display.viewTo > to)\n\t        display.view = display.view.slice(0, findViewIndex(cm, to));\n\t    }\n\t    display.viewTo = to;\n\t  }\n\t\n\t  // Count the number of lines in the view whose DOM representation is\n\t  // out of date (or nonexistent).\n\t  function countDirtyView(cm) {\n\t    var view = cm.display.view, dirty = 0;\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n\t    }\n\t    return dirty;\n\t  }\n\t\n\t  // EVENT HANDLERS\n\t\n\t  // Attach the necessary event handlers when initializing the editor\n\t  function registerEventHandlers(cm) {\n\t    var d = cm.display;\n\t    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n\t    // Older IE's will not fire a second mousedown for a double click\n\t    if (ie && ie_version < 11)\n\t      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n\t        if (signalDOMEvent(cm, e)) return;\n\t        var pos = posFromMouse(cm, e);\n\t        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n\t        e_preventDefault(e);\n\t        var word = cm.findWordAt(pos);\n\t        extendSelection(cm.doc, word.anchor, word.head);\n\t      }));\n\t    else\n\t      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n\t    // Some browsers fire contextmenu *after* opening the menu, at\n\t    // which point we can't mess with it anymore. Context menu is\n\t    // handled in onMouseDown for these browsers.\n\t    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\t\n\t    // Used to suppress mouse event handling when a touch happens\n\t    var touchFinished, prevTouch = {end: 0};\n\t    function finishTouch() {\n\t      if (d.activeTouch) {\n\t        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n\t        prevTouch = d.activeTouch;\n\t        prevTouch.end = +new Date;\n\t      }\n\t    };\n\t    function isMouseLikeTouchEvent(e) {\n\t      if (e.touches.length != 1) return false;\n\t      var touch = e.touches[0];\n\t      return touch.radiusX <= 1 && touch.radiusY <= 1;\n\t    }\n\t    function farAway(touch, other) {\n\t      if (other.left == null) return true;\n\t      var dx = other.left - touch.left, dy = other.top - touch.top;\n\t      return dx * dx + dy * dy > 20 * 20;\n\t    }\n\t    on(d.scroller, \"touchstart\", function(e) {\n\t      if (!isMouseLikeTouchEvent(e)) {\n\t        clearTimeout(touchFinished);\n\t        var now = +new Date;\n\t        d.activeTouch = {start: now, moved: false,\n\t                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n\t        if (e.touches.length == 1) {\n\t          d.activeTouch.left = e.touches[0].pageX;\n\t          d.activeTouch.top = e.touches[0].pageY;\n\t        }\n\t      }\n\t    });\n\t    on(d.scroller, \"touchmove\", function() {\n\t      if (d.activeTouch) d.activeTouch.moved = true;\n\t    });\n\t    on(d.scroller, \"touchend\", function(e) {\n\t      var touch = d.activeTouch;\n\t      if (touch && !eventInWidget(d, e) && touch.left != null &&\n\t          !touch.moved && new Date - touch.start < 300) {\n\t        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n\t        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n\t          range = new Range(pos, pos);\n\t        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n\t          range = cm.findWordAt(pos);\n\t        else // Triple tap\n\t          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n\t        cm.setSelection(range.anchor, range.head);\n\t        cm.focus();\n\t        e_preventDefault(e);\n\t      }\n\t      finishTouch();\n\t    });\n\t    on(d.scroller, \"touchcancel\", finishTouch);\n\t\n\t    // Sync scrolling between fake scrollbars and real scrollable\n\t    // area, ensure viewport is updated when scrolling.\n\t    on(d.scroller, \"scroll\", function() {\n\t      if (d.scroller.clientHeight) {\n\t        setScrollTop(cm, d.scroller.scrollTop);\n\t        setScrollLeft(cm, d.scroller.scrollLeft, true);\n\t        signal(cm, \"scroll\", cm);\n\t      }\n\t    });\n\t\n\t    // Listen to wheel events in order to try and update the viewport on time.\n\t    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n\t    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\t\n\t    // Prevent wrapper from ever scrolling\n\t    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\t\n\t    d.dragFunctions = {\n\t      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n\t      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n\t      start: function(e){onDragStart(cm, e);},\n\t      drop: operation(cm, onDrop),\n\t      leave: function() {clearDragCursor(cm);}\n\t    };\n\t\n\t    var inp = d.input.getField();\n\t    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n\t    on(inp, \"keydown\", operation(cm, onKeyDown));\n\t    on(inp, \"keypress\", operation(cm, onKeyPress));\n\t    on(inp, \"focus\", bind(onFocus, cm));\n\t    on(inp, \"blur\", bind(onBlur, cm));\n\t  }\n\t\n\t  function dragDropChanged(cm, value, old) {\n\t    var wasOn = old && old != CodeMirror.Init;\n\t    if (!value != !wasOn) {\n\t      var funcs = cm.display.dragFunctions;\n\t      var toggle = value ? on : off;\n\t      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n\t      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n\t      toggle(cm.display.scroller, \"dragover\", funcs.over);\n\t      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n\t      toggle(cm.display.scroller, \"drop\", funcs.drop);\n\t    }\n\t  }\n\t\n\t  // Called when the window resizes\n\t  function onResize(cm) {\n\t    var d = cm.display;\n\t    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n\t      return;\n\t    // Might be a text scaling operation, clear size caches.\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t    d.scrollbarsClipped = false;\n\t    cm.setSize();\n\t  }\n\t\n\t  // MOUSE EVENTS\n\t\n\t  // Return true when the given mouse event happened in a widget\n\t  function eventInWidget(display, e) {\n\t    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n\t      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n\t          (n.parentNode == display.sizer && n != display.mover))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // Given a mouse event, find the corresponding position. If liberal\n\t  // is false, it checks whether a gutter or scrollbar was clicked,\n\t  // and returns null if it was. forRect is used by rectangular\n\t  // selections, and tries to estimate a character position even for\n\t  // coordinates beyond the right of the text.\n\t  function posFromMouse(cm, e, liberal, forRect) {\n\t    var display = cm.display;\n\t    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\t\n\t    var x, y, space = display.lineSpace.getBoundingClientRect();\n\t    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n\t    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n\t    catch (e) { return null; }\n\t    var coords = coordsChar(cm, x, y), line;\n\t    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n\t      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n\t      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // A mouse down can be a single click, double click, triple click,\n\t  // start of selection drag, start of text drag, new cursor\n\t  // (ctrl-click), rectangle drag (alt-drag), or xwin\n\t  // middle-click-paste. Or it might be a click on something we should\n\t  // not interfere with, such as a scrollbar or widget.\n\t  function onMouseDown(e) {\n\t    var cm = this, display = cm.display;\n\t    if (display.activeTouch && display.input.supportsTouch() || signalDOMEvent(cm, e)) return;\n\t    display.shift = e.shiftKey;\n\t\n\t    if (eventInWidget(display, e)) {\n\t      if (!webkit) {\n\t        // Briefly turn off draggability, to allow widgets to do\n\t        // normal dragging things.\n\t        display.scroller.draggable = false;\n\t        setTimeout(function(){display.scroller.draggable = true;}, 100);\n\t      }\n\t      return;\n\t    }\n\t    if (clickInGutter(cm, e)) return;\n\t    var start = posFromMouse(cm, e);\n\t    window.focus();\n\t\n\t    switch (e_button(e)) {\n\t    case 1:\n\t      // #3261: make sure, that we're not starting a second selection\n\t      if (cm.state.selectingText)\n\t        cm.state.selectingText(e);\n\t      else if (start)\n\t        leftButtonDown(cm, e, start);\n\t      else if (e_target(e) == display.scroller)\n\t        e_preventDefault(e);\n\t      break;\n\t    case 2:\n\t      if (webkit) cm.state.lastMiddleDown = +new Date;\n\t      if (start) extendSelection(cm.doc, start);\n\t      setTimeout(function() {display.input.focus();}, 20);\n\t      e_preventDefault(e);\n\t      break;\n\t    case 3:\n\t      if (captureRightClick) onContextMenu(cm, e);\n\t      else delayBlurEvent(cm);\n\t      break;\n\t    }\n\t  }\n\t\n\t  var lastClick, lastDoubleClick;\n\t  function leftButtonDown(cm, e, start) {\n\t    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n\t    else cm.curOp.focus = activeElt();\n\t\n\t    var now = +new Date, type;\n\t    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n\t      type = \"triple\";\n\t    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n\t      type = \"double\";\n\t      lastDoubleClick = {time: now, pos: start};\n\t    } else {\n\t      type = \"single\";\n\t      lastClick = {time: now, pos: start};\n\t    }\n\t\n\t    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n\t    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&\n\t        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n\t        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n\t        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n\t      leftButtonStartDrag(cm, e, start, modifier);\n\t    else\n\t      leftButtonSelect(cm, e, start, type, modifier);\n\t  }\n\t\n\t  // Start a text drag. When it ends, see if any dragging actually\n\t  // happen, and treat as a click if it didn't.\n\t  function leftButtonStartDrag(cm, e, start, modifier) {\n\t    var display = cm.display, startTime = +new Date;\n\t    var dragEnd = operation(cm, function(e2) {\n\t      if (webkit) display.scroller.draggable = false;\n\t      cm.state.draggingText = false;\n\t      off(document, \"mouseup\", dragEnd);\n\t      off(display.scroller, \"drop\", dragEnd);\n\t      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n\t        e_preventDefault(e2);\n\t        if (!modifier && +new Date - 200 < startTime)\n\t          extendSelection(cm.doc, start);\n\t        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n\t        if (webkit || ie && ie_version == 9)\n\t          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n\t        else\n\t          display.input.focus();\n\t      }\n\t    });\n\t    // Let the drag handler handle this.\n\t    if (webkit) display.scroller.draggable = true;\n\t    cm.state.draggingText = dragEnd;\n\t    // IE's approach to draggable\n\t    if (display.scroller.dragDrop) display.scroller.dragDrop();\n\t    on(document, \"mouseup\", dragEnd);\n\t    on(display.scroller, \"drop\", dragEnd);\n\t  }\n\t\n\t  // Normal selection, as opposed to text dragging.\n\t  function leftButtonSelect(cm, e, start, type, addNew) {\n\t    var display = cm.display, doc = cm.doc;\n\t    e_preventDefault(e);\n\t\n\t    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n\t    if (addNew && !e.shiftKey) {\n\t      ourIndex = doc.sel.contains(start);\n\t      if (ourIndex > -1)\n\t        ourRange = ranges[ourIndex];\n\t      else\n\t        ourRange = new Range(start, start);\n\t    } else {\n\t      ourRange = doc.sel.primary();\n\t      ourIndex = doc.sel.primIndex;\n\t    }\n\t\n\t    if (e.altKey) {\n\t      type = \"rect\";\n\t      if (!addNew) ourRange = new Range(start, start);\n\t      start = posFromMouse(cm, e, true, true);\n\t      ourIndex = -1;\n\t    } else if (type == \"double\") {\n\t      var word = cm.findWordAt(start);\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n\t      else\n\t        ourRange = word;\n\t    } else if (type == \"triple\") {\n\t      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n\t      else\n\t        ourRange = line;\n\t    } else {\n\t      ourRange = extendRange(doc, ourRange, start);\n\t    }\n\t\n\t    if (!addNew) {\n\t      ourIndex = 0;\n\t      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n\t      startSel = doc.sel;\n\t    } else if (ourIndex == -1) {\n\t      ourIndex = ranges.length;\n\t      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n\t      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t      startSel = doc.sel;\n\t    } else {\n\t      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n\t    }\n\t\n\t    var lastPos = start;\n\t    function extendTo(pos) {\n\t      if (cmp(lastPos, pos) == 0) return;\n\t      lastPos = pos;\n\t\n\t      if (type == \"rect\") {\n\t        var ranges = [], tabSize = cm.options.tabSize;\n\t        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n\t        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n\t        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n\t        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n\t             line <= end; line++) {\n\t          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n\t          if (left == right)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n\t          else if (text.length > leftPos)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n\t        }\n\t        if (!ranges.length) ranges.push(new Range(start, start));\n\t        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n\t                     {origin: \"*mouse\", scroll: false});\n\t        cm.scrollIntoView(pos);\n\t      } else {\n\t        var oldRange = ourRange;\n\t        var anchor = oldRange.anchor, head = pos;\n\t        if (type != \"single\") {\n\t          if (type == \"double\")\n\t            var range = cm.findWordAt(pos);\n\t          else\n\t            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n\t          if (cmp(range.anchor, anchor) > 0) {\n\t            head = range.head;\n\t            anchor = minPos(oldRange.from(), range.anchor);\n\t          } else {\n\t            head = range.anchor;\n\t            anchor = maxPos(oldRange.to(), range.head);\n\t          }\n\t        }\n\t        var ranges = startSel.ranges.slice(0);\n\t        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n\t        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n\t      }\n\t    }\n\t\n\t    var editorSize = display.wrapper.getBoundingClientRect();\n\t    // Used to ensure timeout re-tries don't fire when another extend\n\t    // happened in the meantime (clearTimeout isn't reliable -- at\n\t    // least on Chrome, the timeouts still happen even when cleared,\n\t    // if the clear happens after their scheduled firing time).\n\t    var counter = 0;\n\t\n\t    function extend(e) {\n\t      var curCount = ++counter;\n\t      var cur = posFromMouse(cm, e, true, type == \"rect\");\n\t      if (!cur) return;\n\t      if (cmp(cur, lastPos) != 0) {\n\t        cm.curOp.focus = activeElt();\n\t        extendTo(cur);\n\t        var visible = visibleLines(display, doc);\n\t        if (cur.line >= visible.to || cur.line < visible.from)\n\t          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n\t      } else {\n\t        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n\t        if (outside) setTimeout(operation(cm, function() {\n\t          if (counter != curCount) return;\n\t          display.scroller.scrollTop += outside;\n\t          extend(e);\n\t        }), 50);\n\t      }\n\t    }\n\t\n\t    function done(e) {\n\t      cm.state.selectingText = false;\n\t      counter = Infinity;\n\t      e_preventDefault(e);\n\t      display.input.focus();\n\t      off(document, \"mousemove\", move);\n\t      off(document, \"mouseup\", up);\n\t      doc.history.lastSelOrigin = null;\n\t    }\n\t\n\t    var move = operation(cm, function(e) {\n\t      if (!e_button(e)) done(e);\n\t      else extend(e);\n\t    });\n\t    var up = operation(cm, done);\n\t    cm.state.selectingText = up;\n\t    on(document, \"mousemove\", move);\n\t    on(document, \"mouseup\", up);\n\t  }\n\t\n\t  // Determines whether an event happened in the gutter, and fires the\n\t  // handlers for the corresponding event.\n\t  function gutterEvent(cm, e, type, prevent, signalfn) {\n\t    try { var mX = e.clientX, mY = e.clientY; }\n\t    catch(e) { return false; }\n\t    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n\t    if (prevent) e_preventDefault(e);\n\t\n\t    var display = cm.display;\n\t    var lineBox = display.lineDiv.getBoundingClientRect();\n\t\n\t    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n\t    mY -= lineBox.top - display.viewOffset;\n\t\n\t    for (var i = 0; i < cm.options.gutters.length; ++i) {\n\t      var g = display.gutters.childNodes[i];\n\t      if (g && g.getBoundingClientRect().right >= mX) {\n\t        var line = lineAtHeight(cm.doc, mY);\n\t        var gutter = cm.options.gutters[i];\n\t        signalfn(cm, type, cm, line, gutter, e);\n\t        return e_defaultPrevented(e);\n\t      }\n\t    }\n\t  }\n\t\n\t  function clickInGutter(cm, e) {\n\t    return gutterEvent(cm, e, \"gutterClick\", true, signalLater);\n\t  }\n\t\n\t  // Kludge to work around strange IE behavior where it'll sometimes\n\t  // re-fire a series of drag-related events right after the drop (#1551)\n\t  var lastDrop = 0;\n\t\n\t  function onDrop(e) {\n\t    var cm = this;\n\t    clearDragCursor(cm);\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n\t      return;\n\t    e_preventDefault(e);\n\t    if (ie) lastDrop = +new Date;\n\t    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n\t    if (!pos || isReadOnly(cm)) return;\n\t    // Might be a file drop, in which case we simply extract the text\n\t    // and insert it.\n\t    if (files && files.length && window.FileReader && window.File) {\n\t      var n = files.length, text = Array(n), read = 0;\n\t      var loadFile = function(file, i) {\n\t        if (cm.options.allowDropFileTypes &&\n\t            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n\t          return;\n\t\n\t        var reader = new FileReader;\n\t        reader.onload = operation(cm, function() {\n\t          var content = reader.result;\n\t          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n\t          text[i] = content;\n\t          if (++read == n) {\n\t            pos = clipPos(cm.doc, pos);\n\t            var change = {from: pos, to: pos,\n\t                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n\t                          origin: \"paste\"};\n\t            makeChange(cm.doc, change);\n\t            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n\t          }\n\t        });\n\t        reader.readAsText(file);\n\t      };\n\t      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n\t    } else { // Normal drop\n\t      // Don't do a replace if the drop happened inside of the selected text.\n\t      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n\t        cm.state.draggingText(e);\n\t        // Ensure the editor is re-focused\n\t        setTimeout(function() {cm.display.input.focus();}, 20);\n\t        return;\n\t      }\n\t      try {\n\t        var text = e.dataTransfer.getData(\"Text\");\n\t        if (text) {\n\t          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))\n\t            var selected = cm.listSelections();\n\t          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n\t          if (selected) for (var i = 0; i < selected.length; ++i)\n\t            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n\t          cm.replaceSelection(text, \"around\", \"paste\");\n\t          cm.display.input.focus();\n\t        }\n\t      }\n\t      catch(e){}\n\t    }\n\t  }\n\t\n\t  function onDragStart(cm, e) {\n\t    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\t\n\t    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\t\n\t    // Use dummy image instead of default browsers image.\n\t    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n\t    if (e.dataTransfer.setDragImage && !safari) {\n\t      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n\t      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\t      if (presto) {\n\t        img.width = img.height = 1;\n\t        cm.display.wrapper.appendChild(img);\n\t        // Force a relayout, or Opera won't use our image for some obscure reason\n\t        img._top = img.offsetTop;\n\t      }\n\t      e.dataTransfer.setDragImage(img, 0, 0);\n\t      if (presto) img.parentNode.removeChild(img);\n\t    }\n\t  }\n\t\n\t  function onDragOver(cm, e) {\n\t    var pos = posFromMouse(cm, e);\n\t    if (!pos) return;\n\t    var frag = document.createDocumentFragment();\n\t    drawSelectionCursor(cm, pos, frag);\n\t    if (!cm.display.dragCursor) {\n\t      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n\t      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n\t    }\n\t    removeChildrenAndAdd(cm.display.dragCursor, frag);\n\t  }\n\t\n\t  function clearDragCursor(cm) {\n\t    if (cm.display.dragCursor) {\n\t      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n\t      cm.display.dragCursor = null;\n\t    }\n\t  }\n\t\n\t  // SCROLL EVENTS\n\t\n\t  // Sync the scrollable area and scrollbars, ensure the viewport\n\t  // covers the visible area.\n\t  function setScrollTop(cm, val) {\n\t    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n\t    cm.doc.scrollTop = val;\n\t    if (!gecko) updateDisplaySimple(cm, {top: val});\n\t    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n\t    cm.display.scrollbars.setScrollTop(val);\n\t    if (gecko) updateDisplaySimple(cm);\n\t    startWorker(cm, 100);\n\t  }\n\t  // Sync scroller and scrollbar, ensure the gutter elements are\n\t  // aligned.\n\t  function setScrollLeft(cm, val, isScroller) {\n\t    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n\t    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n\t    cm.doc.scrollLeft = val;\n\t    alignHorizontally(cm);\n\t    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n\t    cm.display.scrollbars.setScrollLeft(val);\n\t  }\n\t\n\t  // Since the delta values reported on mouse wheel events are\n\t  // unstandardized between browsers and even browser versions, and\n\t  // generally horribly unpredictable, this code starts by measuring\n\t  // the scroll effect that the first few mouse wheel events have,\n\t  // and, from that, detects the way it can convert deltas to pixel\n\t  // offsets afterwards.\n\t  //\n\t  // The reason we want to know the amount a wheel event will scroll\n\t  // is that it gives us a chance to update the display before the\n\t  // actual scrolling happens, reducing flickering.\n\t\n\t  var wheelSamples = 0, wheelPixelsPerUnit = null;\n\t  // Fill in a browser-detected starting value on browsers where we\n\t  // know one. These don't have to be accurate -- the result of them\n\t  // being wrong would just be a slight flicker on the first wheel\n\t  // scroll (if it is large enough).\n\t  if (ie) wheelPixelsPerUnit = -.53;\n\t  else if (gecko) wheelPixelsPerUnit = 15;\n\t  else if (chrome) wheelPixelsPerUnit = -.7;\n\t  else if (safari) wheelPixelsPerUnit = -1/3;\n\t\n\t  var wheelEventDelta = function(e) {\n\t    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n\t    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n\t    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n\t    else if (dy == null) dy = e.wheelDelta;\n\t    return {x: dx, y: dy};\n\t  };\n\t  CodeMirror.wheelEventPixels = function(e) {\n\t    var delta = wheelEventDelta(e);\n\t    delta.x *= wheelPixelsPerUnit;\n\t    delta.y *= wheelPixelsPerUnit;\n\t    return delta;\n\t  };\n\t\n\t  function onScrollWheel(cm, e) {\n\t    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\t\n\t    var display = cm.display, scroll = display.scroller;\n\t    // Quit if there's nothing to scroll here\n\t    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n\t    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n\t    if (!(dx && canScrollX || dy && canScrollY)) return;\n\t\n\t    // Webkit browsers on OS X abort momentum scrolls when the target\n\t    // of the scroll event is removed from the scrollable element.\n\t    // This hack (see related code in patchDisplay) makes sure the\n\t    // element is kept around.\n\t    if (dy && mac && webkit) {\n\t      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n\t        for (var i = 0; i < view.length; i++) {\n\t          if (view[i].node == cur) {\n\t            cm.display.currentWheelTarget = cur;\n\t            break outer;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // On some browsers, horizontal scrolling will cause redraws to\n\t    // happen before the gutter has been realigned, causing it to\n\t    // wriggle around in a most unseemly way. When we have an\n\t    // estimated pixels/delta value, we just handle horizontal\n\t    // scrolling entirely here. It'll be slightly off from native, but\n\t    // better than glitching out.\n\t    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n\t      if (dy && canScrollY)\n\t        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n\t      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n\t      // Only prevent default scrolling if vertical scrolling is\n\t      // actually possible. Otherwise, it causes vertical scroll\n\t      // jitter on OSX trackpads when deltaX is small and deltaY\n\t      // is large (issue #3579)\n\t      if (!dy || (dy && canScrollY))\n\t        e_preventDefault(e);\n\t      display.wheelStartX = null; // Abort measurement, if in progress\n\t      return;\n\t    }\n\t\n\t    // 'Project' the visible viewport to cover the area that is being\n\t    // scrolled into view (if we know enough to estimate it).\n\t    if (dy && wheelPixelsPerUnit != null) {\n\t      var pixels = dy * wheelPixelsPerUnit;\n\t      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n\t      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n\t      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n\t      updateDisplaySimple(cm, {top: top, bottom: bot});\n\t    }\n\t\n\t    if (wheelSamples < 20) {\n\t      if (display.wheelStartX == null) {\n\t        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n\t        display.wheelDX = dx; display.wheelDY = dy;\n\t        setTimeout(function() {\n\t          if (display.wheelStartX == null) return;\n\t          var movedX = scroll.scrollLeft - display.wheelStartX;\n\t          var movedY = scroll.scrollTop - display.wheelStartY;\n\t          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n\t            (movedX && display.wheelDX && movedX / display.wheelDX);\n\t          display.wheelStartX = display.wheelStartY = null;\n\t          if (!sample) return;\n\t          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n\t          ++wheelSamples;\n\t        }, 200);\n\t      } else {\n\t        display.wheelDX += dx; display.wheelDY += dy;\n\t      }\n\t    }\n\t  }\n\t\n\t  // KEY EVENTS\n\t\n\t  // Run a handler that was bound to a key.\n\t  function doHandleBinding(cm, bound, dropShift) {\n\t    if (typeof bound == \"string\") {\n\t      bound = commands[bound];\n\t      if (!bound) return false;\n\t    }\n\t    // Ensure previous input has been read, so that the handler sees a\n\t    // consistent view of the document\n\t    cm.display.input.ensurePolled();\n\t    var prevShift = cm.display.shift, done = false;\n\t    try {\n\t      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n\t      if (dropShift) cm.display.shift = false;\n\t      done = bound(cm) != Pass;\n\t    } finally {\n\t      cm.display.shift = prevShift;\n\t      cm.state.suppressEdits = false;\n\t    }\n\t    return done;\n\t  }\n\t\n\t  function lookupKeyForEditor(cm, name, handle) {\n\t    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n\t      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n\t      if (result) return result;\n\t    }\n\t    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n\t      || lookupKey(name, cm.options.keyMap, handle, cm);\n\t  }\n\t\n\t  var stopSeq = new Delayed;\n\t  function dispatchKey(cm, name, e, handle) {\n\t    var seq = cm.state.keySeq;\n\t    if (seq) {\n\t      if (isModifierKey(name)) return \"handled\";\n\t      stopSeq.set(50, function() {\n\t        if (cm.state.keySeq == seq) {\n\t          cm.state.keySeq = null;\n\t          cm.display.input.reset();\n\t        }\n\t      });\n\t      name = seq + \" \" + name;\n\t    }\n\t    var result = lookupKeyForEditor(cm, name, handle);\n\t\n\t    if (result == \"multi\")\n\t      cm.state.keySeq = name;\n\t    if (result == \"handled\")\n\t      signalLater(cm, \"keyHandled\", cm, name, e);\n\t\n\t    if (result == \"handled\" || result == \"multi\") {\n\t      e_preventDefault(e);\n\t      restartBlink(cm);\n\t    }\n\t\n\t    if (seq && !result && /\\'$/.test(name)) {\n\t      e_preventDefault(e);\n\t      return true;\n\t    }\n\t    return !!result;\n\t  }\n\t\n\t  // Handle a key from the keydown event.\n\t  function handleKeyBinding(cm, e) {\n\t    var name = keyName(e, true);\n\t    if (!name) return false;\n\t\n\t    if (e.shiftKey && !cm.state.keySeq) {\n\t      // First try to resolve full name (including 'Shift-'). Failing\n\t      // that, see if there is a cursor-motion command (starting with\n\t      // 'go') bound to the keyname without 'Shift-'.\n\t      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n\t          || dispatchKey(cm, name, e, function(b) {\n\t               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n\t                 return doHandleBinding(cm, b);\n\t             });\n\t    } else {\n\t      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n\t    }\n\t  }\n\t\n\t  // Handle a key from the keypress event\n\t  function handleCharBinding(cm, e, ch) {\n\t    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n\t                       function(b) { return doHandleBinding(cm, b, true); });\n\t  }\n\t\n\t  var lastStoppedKey = null;\n\t  function onKeyDown(e) {\n\t    var cm = this;\n\t    cm.curOp.focus = activeElt();\n\t    if (signalDOMEvent(cm, e)) return;\n\t    // IE does strange things with escape.\n\t    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n\t    var code = e.keyCode;\n\t    cm.display.shift = code == 16 || e.shiftKey;\n\t    var handled = handleKeyBinding(cm, e);\n\t    if (presto) {\n\t      lastStoppedKey = handled ? code : null;\n\t      // Opera has no cut event... we try to at least catch the key combo\n\t      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n\t        cm.replaceSelection(\"\", null, \"cut\");\n\t    }\n\t\n\t    // Turn mouse into crosshair when Alt is held on Mac.\n\t    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n\t      showCrossHair(cm);\n\t  }\n\t\n\t  function showCrossHair(cm) {\n\t    var lineDiv = cm.display.lineDiv;\n\t    addClass(lineDiv, \"CodeMirror-crosshair\");\n\t\n\t    function up(e) {\n\t      if (e.keyCode == 18 || !e.altKey) {\n\t        rmClass(lineDiv, \"CodeMirror-crosshair\");\n\t        off(document, \"keyup\", up);\n\t        off(document, \"mouseover\", up);\n\t      }\n\t    }\n\t    on(document, \"keyup\", up);\n\t    on(document, \"mouseover\", up);\n\t  }\n\t\n\t  function onKeyUp(e) {\n\t    if (e.keyCode == 16) this.doc.sel.shift = false;\n\t    signalDOMEvent(this, e);\n\t  }\n\t\n\t  function onKeyPress(e) {\n\t    var cm = this;\n\t    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n\t    var keyCode = e.keyCode, charCode = e.charCode;\n\t    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n\t    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n\t    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n\t    if (handleCharBinding(cm, e, ch)) return;\n\t    cm.display.input.onKeyPress(e);\n\t  }\n\t\n\t  // FOCUS/BLUR EVENTS\n\t\n\t  function delayBlurEvent(cm) {\n\t    cm.state.delayingBlurEvent = true;\n\t    setTimeout(function() {\n\t      if (cm.state.delayingBlurEvent) {\n\t        cm.state.delayingBlurEvent = false;\n\t        onBlur(cm);\n\t      }\n\t    }, 100);\n\t  }\n\t\n\t  function onFocus(cm) {\n\t    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\t\n\t    if (cm.options.readOnly == \"nocursor\") return;\n\t    if (!cm.state.focused) {\n\t      signal(cm, \"focus\", cm);\n\t      cm.state.focused = true;\n\t      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t      // This test prevents this from firing when a context\n\t      // menu is closed (since the input reset would kill the\n\t      // select-all detection hack)\n\t      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n\t        cm.display.input.reset();\n\t        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n\t      }\n\t      cm.display.input.receivedFocus();\n\t    }\n\t    restartBlink(cm);\n\t  }\n\t  function onBlur(cm) {\n\t    if (cm.state.delayingBlurEvent) return;\n\t\n\t    if (cm.state.focused) {\n\t      signal(cm, \"blur\", cm);\n\t      cm.state.focused = false;\n\t      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t    }\n\t    clearInterval(cm.display.blinker);\n\t    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n\t  }\n\t\n\t  // CONTEXT MENU HANDLING\n\t\n\t  // To make the context menu work, we need to briefly unhide the\n\t  // textarea (making it as unobtrusive as possible) to let the\n\t  // right-click take effect on it.\n\t  function onContextMenu(cm, e) {\n\t    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n\t    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n\t    cm.display.input.onContextMenu(e);\n\t  }\n\t\n\t  function contextMenuInGutter(cm, e) {\n\t    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n\t    return gutterEvent(cm, e, \"gutterContextMenu\", false, signal);\n\t  }\n\t\n\t  // UPDATING\n\t\n\t  // Compute the position of the end of a change (its 'to' property\n\t  // refers to the pre-change end).\n\t  var changeEnd = CodeMirror.changeEnd = function(change) {\n\t    if (!change.text) return change.to;\n\t    return Pos(change.from.line + change.text.length - 1,\n\t               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n\t  };\n\t\n\t  // Adjust a position to refer to the post-change position of the\n\t  // same text, or the end of the change if the change covers it.\n\t  function adjustForChange(pos, change) {\n\t    if (cmp(pos, change.from) < 0) return pos;\n\t    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\t\n\t    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n\t    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n\t    return Pos(line, ch);\n\t  }\n\t\n\t  function computeSelAfterChange(doc, change) {\n\t    var out = [];\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      var range = doc.sel.ranges[i];\n\t      out.push(new Range(adjustForChange(range.anchor, change),\n\t                         adjustForChange(range.head, change)));\n\t    }\n\t    return normalizeSelection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  function offsetPos(pos, old, nw) {\n\t    if (pos.line == old.line)\n\t      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n\t    else\n\t      return Pos(nw.line + (pos.line - old.line), pos.ch);\n\t  }\n\t\n\t  // Used by replaceSelections to allow moving the selection to the\n\t  // start or around the replaced test. Hint may be \"start\" or \"around\".\n\t  function computeReplacedSel(doc, changes, hint) {\n\t    var out = [];\n\t    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n\t    for (var i = 0; i < changes.length; i++) {\n\t      var change = changes[i];\n\t      var from = offsetPos(change.from, oldPrev, newPrev);\n\t      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n\t      oldPrev = change.to;\n\t      newPrev = to;\n\t      if (hint == \"around\") {\n\t        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n\t        out[i] = new Range(inv ? to : from, inv ? from : to);\n\t      } else {\n\t        out[i] = new Range(from, from);\n\t      }\n\t    }\n\t    return new Selection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  // Allow \"beforeChange\" event handlers to influence a change\n\t  function filterChange(doc, change, update) {\n\t    var obj = {\n\t      canceled: false,\n\t      from: change.from,\n\t      to: change.to,\n\t      text: change.text,\n\t      origin: change.origin,\n\t      cancel: function() { this.canceled = true; }\n\t    };\n\t    if (update) obj.update = function(from, to, text, origin) {\n\t      if (from) this.from = clipPos(doc, from);\n\t      if (to) this.to = clipPos(doc, to);\n\t      if (text) this.text = text;\n\t      if (origin !== undefined) this.origin = origin;\n\t    };\n\t    signal(doc, \"beforeChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\t\n\t    if (obj.canceled) return null;\n\t    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n\t  }\n\t\n\t  // Apply a change to a document, and add it to the document's\n\t  // history, and propagating it to all linked documents.\n\t  function makeChange(doc, change, ignoreReadOnly) {\n\t    if (doc.cm) {\n\t      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n\t      if (doc.cm.state.suppressEdits) return;\n\t    }\n\t\n\t    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n\t      change = filterChange(doc, change, true);\n\t      if (!change) return;\n\t    }\n\t\n\t    // Possibly split or suppress the update based on the presence\n\t    // of read-only spans in its range.\n\t    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n\t    if (split) {\n\t      for (var i = split.length - 1; i >= 0; --i)\n\t        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n\t    } else {\n\t      makeChangeInner(doc, change);\n\t    }\n\t  }\n\t\n\t  function makeChangeInner(doc, change) {\n\t    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n\t    var selAfter = computeSelAfterChange(doc, change);\n\t    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\t\n\t    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n\t    var rebased = [];\n\t\n\t    linkedDocs(doc, function(doc, sharedHist) {\n\t      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t        rebaseHist(doc.history, change);\n\t        rebased.push(doc.history);\n\t      }\n\t      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n\t    });\n\t  }\n\t\n\t  // Revert a change stored in a document's history.\n\t  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n\t    if (doc.cm && doc.cm.state.suppressEdits) return;\n\t\n\t    var hist = doc.history, event, selAfter = doc.sel;\n\t    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\t\n\t    // Verify that there is a useable event (so that ctrl-z won't\n\t    // needlessly clear selection events)\n\t    for (var i = 0; i < source.length; i++) {\n\t      event = source[i];\n\t      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n\t        break;\n\t    }\n\t    if (i == source.length) return;\n\t    hist.lastOrigin = hist.lastSelOrigin = null;\n\t\n\t    for (;;) {\n\t      event = source.pop();\n\t      if (event.ranges) {\n\t        pushSelectionToHistory(event, dest);\n\t        if (allowSelectionOnly && !event.equals(doc.sel)) {\n\t          setSelection(doc, event, {clearRedo: false});\n\t          return;\n\t        }\n\t        selAfter = event;\n\t      }\n\t      else break;\n\t    }\n\t\n\t    // Build up a reverse change object to add to the opposite history\n\t    // stack (redo when undoing, and vice versa).\n\t    var antiChanges = [];\n\t    pushSelectionToHistory(selAfter, dest);\n\t    dest.push({changes: antiChanges, generation: hist.generation});\n\t    hist.generation = event.generation || ++hist.maxGeneration;\n\t\n\t    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\t\n\t    for (var i = event.changes.length - 1; i >= 0; --i) {\n\t      var change = event.changes[i];\n\t      change.origin = type;\n\t      if (filter && !filterChange(doc, change, false)) {\n\t        source.length = 0;\n\t        return;\n\t      }\n\t\n\t      antiChanges.push(historyChangeFromChange(doc, change));\n\t\n\t      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n\t      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n\t      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n\t      var rebased = [];\n\t\n\t      // Propagate to the linked documents\n\t      linkedDocs(doc, function(doc, sharedHist) {\n\t        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t          rebaseHist(doc.history, change);\n\t          rebased.push(doc.history);\n\t        }\n\t        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n\t      });\n\t    }\n\t  }\n\t\n\t  // Sub-views need their line numbers shifted when text is added\n\t  // above or below them in the parent document.\n\t  function shiftDoc(doc, distance) {\n\t    if (distance == 0) return;\n\t    doc.first += distance;\n\t    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n\t      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n\t                       Pos(range.head.line + distance, range.head.ch));\n\t    }), doc.sel.primIndex);\n\t    if (doc.cm) {\n\t      regChange(doc.cm, doc.first, doc.first - distance, distance);\n\t      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n\t        regLineChange(doc.cm, l, \"gutter\");\n\t    }\n\t  }\n\t\n\t  // More lower-level change function, handling only a single document\n\t  // (not linked ones).\n\t  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n\t    if (doc.cm && !doc.cm.curOp)\n\t      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\t\n\t    if (change.to.line < doc.first) {\n\t      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n\t      return;\n\t    }\n\t    if (change.from.line > doc.lastLine()) return;\n\t\n\t    // Clip the change to the size of this doc\n\t    if (change.from.line < doc.first) {\n\t      var shift = change.text.length - 1 - (doc.first - change.from.line);\n\t      shiftDoc(doc, shift);\n\t      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n\t                text: [lst(change.text)], origin: change.origin};\n\t    }\n\t    var last = doc.lastLine();\n\t    if (change.to.line > last) {\n\t      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n\t                text: [change.text[0]], origin: change.origin};\n\t    }\n\t\n\t    change.removed = getBetween(doc, change.from, change.to);\n\t\n\t    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n\t    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n\t    else updateDoc(doc, change, spans);\n\t    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\t  }\n\t\n\t  // Handle the interaction of a change to a document with the editor\n\t  // that this document is part of.\n\t  function makeChangeSingleDocInEditor(cm, change, spans) {\n\t    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\t\n\t    var recomputeMaxLength = false, checkWidthStart = from.line;\n\t    if (!cm.options.lineWrapping) {\n\t      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n\t      doc.iter(checkWidthStart, to.line + 1, function(line) {\n\t        if (line == display.maxLine) {\n\t          recomputeMaxLength = true;\n\t          return true;\n\t        }\n\t      });\n\t    }\n\t\n\t    if (doc.sel.contains(change.from, change.to) > -1)\n\t      signalCursorActivity(cm);\n\t\n\t    updateDoc(doc, change, spans, estimateHeight(cm));\n\t\n\t    if (!cm.options.lineWrapping) {\n\t      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n\t        var len = lineLength(line);\n\t        if (len > display.maxLineLength) {\n\t          display.maxLine = line;\n\t          display.maxLineLength = len;\n\t          display.maxLineChanged = true;\n\t          recomputeMaxLength = false;\n\t        }\n\t      });\n\t      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n\t    }\n\t\n\t    // Adjust frontier, schedule worker\n\t    doc.frontier = Math.min(doc.frontier, from.line);\n\t    startWorker(cm, 400);\n\t\n\t    var lendiff = change.text.length - (to.line - from.line) - 1;\n\t    // Remember that these lines changed, for updating the display\n\t    if (change.full)\n\t      regChange(cm);\n\t    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n\t      regLineChange(cm, from.line, \"text\");\n\t    else\n\t      regChange(cm, from.line, to.line + 1, lendiff);\n\t\n\t    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n\t    if (changeHandler || changesHandler) {\n\t      var obj = {\n\t        from: from, to: to,\n\t        text: change.text,\n\t        removed: change.removed,\n\t        origin: change.origin\n\t      };\n\t      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n\t      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n\t    }\n\t    cm.display.selForContextMenu = null;\n\t  }\n\t\n\t  function replaceRange(doc, code, from, to, origin) {\n\t    if (!to) to = from;\n\t    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n\t    if (typeof code == \"string\") code = doc.splitLines(code);\n\t    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n\t  }\n\t\n\t  // SCROLLING THINGS INTO VIEW\n\t\n\t  // If an editor sits on the top or bottom of the window, partially\n\t  // scrolled out of view, this ensures that the cursor is visible.\n\t  function maybeScrollWindow(cm, coords) {\n\t    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\t\n\t    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n\t    if (coords.top + box.top < 0) doScroll = true;\n\t    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n\t    if (doScroll != null && !phantom) {\n\t      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n\t                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n\t                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n\t                           coords.left + \"px; width: 2px;\");\n\t      cm.display.lineSpace.appendChild(scrollNode);\n\t      scrollNode.scrollIntoView(doScroll);\n\t      cm.display.lineSpace.removeChild(scrollNode);\n\t    }\n\t  }\n\t\n\t  // Scroll a given position into view (immediately), verifying that\n\t  // it actually became visible (as line heights are accurately\n\t  // measured, the position of something may 'drift' during drawing).\n\t  function scrollPosIntoView(cm, pos, end, margin) {\n\t    if (margin == null) margin = 0;\n\t    for (var limit = 0; limit < 5; limit++) {\n\t      var changed = false, coords = cursorCoords(cm, pos);\n\t      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n\t      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n\t                                         Math.min(coords.top, endCoords.top) - margin,\n\t                                         Math.max(coords.left, endCoords.left),\n\t                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n\t      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n\t      if (scrollPos.scrollTop != null) {\n\t        setScrollTop(cm, scrollPos.scrollTop);\n\t        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n\t      }\n\t      if (scrollPos.scrollLeft != null) {\n\t        setScrollLeft(cm, scrollPos.scrollLeft);\n\t        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n\t      }\n\t      if (!changed) break;\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // Scroll a given set of coordinates into view (immediately).\n\t  function scrollIntoView(cm, x1, y1, x2, y2) {\n\t    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n\t    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n\t    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n\t  }\n\t\n\t  // Calculate a new scroll position needed to scroll the given\n\t  // rectangle into view. Returns an object with scrollTop and\n\t  // scrollLeft properties. When these are undefined, the\n\t  // vertical/horizontal position does not need to be adjusted.\n\t  function calculateScrollPos(cm, x1, y1, x2, y2) {\n\t    var display = cm.display, snapMargin = textHeight(cm.display);\n\t    if (y1 < 0) y1 = 0;\n\t    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n\t    var screen = displayHeight(cm), result = {};\n\t    if (y2 - y1 > screen) y2 = y1 + screen;\n\t    var docBottom = cm.doc.height + paddingVert(display);\n\t    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n\t    if (y1 < screentop) {\n\t      result.scrollTop = atTop ? 0 : y1;\n\t    } else if (y2 > screentop + screen) {\n\t      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n\t      if (newTop != screentop) result.scrollTop = newTop;\n\t    }\n\t\n\t    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n\t    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n\t    var tooWide = x2 - x1 > screenw;\n\t    if (tooWide) x2 = x1 + screenw;\n\t    if (x1 < 10)\n\t      result.scrollLeft = 0;\n\t    else if (x1 < screenleft)\n\t      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n\t    else if (x2 > screenw + screenleft - 3)\n\t      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n\t    return result;\n\t  }\n\t\n\t  // Store a relative adjustment to the scroll position in the current\n\t  // operation (to be applied when the operation finishes).\n\t  function addToScrollPos(cm, left, top) {\n\t    if (left != null || top != null) resolveScrollToPos(cm);\n\t    if (left != null)\n\t      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n\t    if (top != null)\n\t      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n\t  }\n\t\n\t  // Make sure that at the end of the operation the current cursor is\n\t  // shown.\n\t  function ensureCursorVisible(cm) {\n\t    resolveScrollToPos(cm);\n\t    var cur = cm.getCursor(), from = cur, to = cur;\n\t    if (!cm.options.lineWrapping) {\n\t      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n\t      to = Pos(cur.line, cur.ch + 1);\n\t    }\n\t    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n\t  }\n\t\n\t  // When an operation has its scrollToPos property set, and another\n\t  // scroll action is applied before the end of the operation, this\n\t  // 'simulates' scrolling that position into view in a cheap way, so\n\t  // that the effect of intermediate scroll commands is not ignored.\n\t  function resolveScrollToPos(cm) {\n\t    var range = cm.curOp.scrollToPos;\n\t    if (range) {\n\t      cm.curOp.scrollToPos = null;\n\t      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n\t      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n\t                                    Math.min(from.top, to.top) - range.margin,\n\t                                    Math.max(from.right, to.right),\n\t                                    Math.max(from.bottom, to.bottom) + range.margin);\n\t      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t    }\n\t  }\n\t\n\t  // API UTILITIES\n\t\n\t  // Indent the given line. The how parameter can be \"smart\",\n\t  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n\t  // (typically set to true for forced single-line indents), empty\n\t  // lines are not indented, and places where the mode returns Pass\n\t  // are left alone.\n\t  function indentLine(cm, n, how, aggressive) {\n\t    var doc = cm.doc, state;\n\t    if (how == null) how = \"add\";\n\t    if (how == \"smart\") {\n\t      // Fall back to \"prev\" when the mode doesn't have an indentation\n\t      // method.\n\t      if (!doc.mode.indent) how = \"prev\";\n\t      else state = getStateBefore(cm, n);\n\t    }\n\t\n\t    var tabSize = cm.options.tabSize;\n\t    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n\t    if (!aggressive && !/\\S/.test(line.text)) {\n\t      indentation = 0;\n\t      how = \"not\";\n\t    } else if (how == \"smart\") {\n\t      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n\t      if (indentation == Pass || indentation > 150) {\n\t        if (!aggressive) return;\n\t        how = \"prev\";\n\t      }\n\t    }\n\t    if (how == \"prev\") {\n\t      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n\t      else indentation = 0;\n\t    } else if (how == \"add\") {\n\t      indentation = curSpace + cm.options.indentUnit;\n\t    } else if (how == \"subtract\") {\n\t      indentation = curSpace - cm.options.indentUnit;\n\t    } else if (typeof how == \"number\") {\n\t      indentation = curSpace + how;\n\t    }\n\t    indentation = Math.max(0, indentation);\n\t\n\t    var indentString = \"\", pos = 0;\n\t    if (cm.options.indentWithTabs)\n\t      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n\t    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\t\n\t    if (indentString != curSpaceString) {\n\t      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n\t      line.stateAfter = null;\n\t      return true;\n\t    } else {\n\t      // Ensure that, if the cursor was in the whitespace at the start\n\t      // of the line, it is moved to the end of that space.\n\t      for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t        var range = doc.sel.ranges[i];\n\t        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n\t          var pos = Pos(n, curSpaceString.length);\n\t          replaceOneSelection(doc, i, new Range(pos, pos));\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // Utility for applying a change to a line by handle or number,\n\t  // returning the number and optionally registering the line as\n\t  // changed.\n\t  function changeLine(doc, handle, changeType, op) {\n\t    var no = handle, line = handle;\n\t    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n\t    else no = lineNo(handle);\n\t    if (no == null) return null;\n\t    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n\t    return line;\n\t  }\n\t\n\t  // Helper for deleting text near the selection(s), used to implement\n\t  // backspace, delete, and similar functionality.\n\t  function deleteNearSelection(cm, compute) {\n\t    var ranges = cm.doc.sel.ranges, kill = [];\n\t    // Build up a set of ranges to kill first, merging overlapping\n\t    // ranges.\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var toKill = compute(ranges[i]);\n\t      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n\t        var replaced = kill.pop();\n\t        if (cmp(replaced.from, toKill.from) < 0) {\n\t          toKill.from = replaced.from;\n\t          break;\n\t        }\n\t      }\n\t      kill.push(toKill);\n\t    }\n\t    // Next, remove those actual ranges.\n\t    runInOp(cm, function() {\n\t      for (var i = kill.length - 1; i >= 0; i--)\n\t        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n\t      ensureCursorVisible(cm);\n\t    });\n\t  }\n\t\n\t  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n\t  // right), unit can be \"char\", \"column\" (like char, but doesn't\n\t  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n\t  // the start of next group of word or non-word-non-whitespace\n\t  // chars). The visually param controls whether, in right-to-left\n\t  // text, direction 1 means to move towards the next index in the\n\t  // string, or towards the character to the right of the current\n\t  // position. The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosH(doc, pos, dir, unit, visually) {\n\t    var line = pos.line, ch = pos.ch, origDir = dir;\n\t    var lineObj = getLine(doc, line);\n\t    var possible = true;\n\t    function findNextLine() {\n\t      var l = line + dir;\n\t      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n\t      line = l;\n\t      return lineObj = getLine(doc, l);\n\t    }\n\t    function moveOnce(boundToLine) {\n\t      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n\t      if (next == null) {\n\t        if (!boundToLine && findNextLine()) {\n\t          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n\t          else ch = dir < 0 ? lineObj.text.length : 0;\n\t        } else return (possible = false);\n\t      } else ch = next;\n\t      return true;\n\t    }\n\t\n\t    if (unit == \"char\") moveOnce();\n\t    else if (unit == \"column\") moveOnce(true);\n\t    else if (unit == \"word\" || unit == \"group\") {\n\t      var sawType = null, group = unit == \"group\";\n\t      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n\t      for (var first = true;; first = false) {\n\t        if (dir < 0 && !moveOnce(!first)) break;\n\t        var cur = lineObj.text.charAt(ch) || \"\\n\";\n\t        var type = isWordChar(cur, helper) ? \"w\"\n\t          : group && cur == \"\\n\" ? \"n\"\n\t          : !group || /\\s/.test(cur) ? null\n\t          : \"p\";\n\t        if (group && !first && !type) type = \"s\";\n\t        if (sawType && sawType != type) {\n\t          if (dir < 0) {dir = 1; moveOnce();}\n\t          break;\n\t        }\n\t\n\t        if (type) sawType = type;\n\t        if (dir > 0 && !moveOnce(!first)) break;\n\t      }\n\t    }\n\t    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n\t    if (!possible) result.hitSide = true;\n\t    return result;\n\t  }\n\t\n\t  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n\t  // \"page\" or \"line\". The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosV(cm, pos, dir, unit) {\n\t    var doc = cm.doc, x = pos.left, y;\n\t    if (unit == \"page\") {\n\t      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n\t      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n\t    } else if (unit == \"line\") {\n\t      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n\t    }\n\t    for (;;) {\n\t      var target = coordsChar(cm, x, y);\n\t      if (!target.outside) break;\n\t      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n\t      y += dir * 5;\n\t    }\n\t    return target;\n\t  }\n\t\n\t  // EDITOR METHODS\n\t\n\t  // The publicly visible API. Note that methodOp(f) means\n\t  // 'wrap f in an operation, performed on its `this` parameter'.\n\t\n\t  // This is not the complete set of editor methods. Most of the\n\t  // methods defined on the Doc type are also injected into\n\t  // CodeMirror.prototype, for backwards compatibility and\n\t  // convenience.\n\t\n\t  CodeMirror.prototype = {\n\t    constructor: CodeMirror,\n\t    focus: function(){window.focus(); this.display.input.focus();},\n\t\n\t    setOption: function(option, value) {\n\t      var options = this.options, old = options[option];\n\t      if (options[option] == value && option != \"mode\") return;\n\t      options[option] = value;\n\t      if (optionHandlers.hasOwnProperty(option))\n\t        operation(this, optionHandlers[option])(this, value, old);\n\t    },\n\t\n\t    getOption: function(option) {return this.options[option];},\n\t    getDoc: function() {return this.doc;},\n\t\n\t    addKeyMap: function(map, bottom) {\n\t      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n\t    },\n\t    removeKeyMap: function(map) {\n\t      var maps = this.state.keyMaps;\n\t      for (var i = 0; i < maps.length; ++i)\n\t        if (maps[i] == map || maps[i].name == map) {\n\t          maps.splice(i, 1);\n\t          return true;\n\t        }\n\t    },\n\t\n\t    addOverlay: methodOp(function(spec, options) {\n\t      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n\t      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n\t      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n\t      this.state.modeGen++;\n\t      regChange(this);\n\t    }),\n\t    removeOverlay: methodOp(function(spec) {\n\t      var overlays = this.state.overlays;\n\t      for (var i = 0; i < overlays.length; ++i) {\n\t        var cur = overlays[i].modeSpec;\n\t        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n\t          overlays.splice(i, 1);\n\t          this.state.modeGen++;\n\t          regChange(this);\n\t          return;\n\t        }\n\t      }\n\t    }),\n\t\n\t    indentLine: methodOp(function(n, dir, aggressive) {\n\t      if (typeof dir != \"string\" && typeof dir != \"number\") {\n\t        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n\t        else dir = dir ? \"add\" : \"subtract\";\n\t      }\n\t      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n\t    }),\n\t    indentSelection: methodOp(function(how) {\n\t      var ranges = this.doc.sel.ranges, end = -1;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (!range.empty()) {\n\t          var from = range.from(), to = range.to();\n\t          var start = Math.max(end, from.line);\n\t          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n\t          for (var j = start; j < end; ++j)\n\t            indentLine(this, j, how);\n\t          var newRanges = this.doc.sel.ranges;\n\t          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n\t            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n\t        } else if (range.head.line > end) {\n\t          indentLine(this, range.head.line, how, true);\n\t          end = range.head.line;\n\t          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n\t        }\n\t      }\n\t    }),\n\t\n\t    // Fetch the parser token for a given character. Useful for hacks\n\t    // that want to inspect the mode state (say, for completion).\n\t    getTokenAt: function(pos, precise) {\n\t      return takeToken(this, pos, precise);\n\t    },\n\t\n\t    getLineTokens: function(line, precise) {\n\t      return takeToken(this, Pos(line), precise, true);\n\t    },\n\t\n\t    getTokenTypeAt: function(pos) {\n\t      pos = clipPos(this.doc, pos);\n\t      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n\t      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n\t      var type;\n\t      if (ch == 0) type = styles[2];\n\t      else for (;;) {\n\t        var mid = (before + after) >> 1;\n\t        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n\t        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n\t        else { type = styles[mid * 2 + 2]; break; }\n\t      }\n\t      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n\t      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n\t    },\n\t\n\t    getModeAt: function(pos) {\n\t      var mode = this.doc.mode;\n\t      if (!mode.innerMode) return mode;\n\t      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n\t    },\n\t\n\t    getHelper: function(pos, type) {\n\t      return this.getHelpers(pos, type)[0];\n\t    },\n\t\n\t    getHelpers: function(pos, type) {\n\t      var found = [];\n\t      if (!helpers.hasOwnProperty(type)) return found;\n\t      var help = helpers[type], mode = this.getModeAt(pos);\n\t      if (typeof mode[type] == \"string\") {\n\t        if (help[mode[type]]) found.push(help[mode[type]]);\n\t      } else if (mode[type]) {\n\t        for (var i = 0; i < mode[type].length; i++) {\n\t          var val = help[mode[type][i]];\n\t          if (val) found.push(val);\n\t        }\n\t      } else if (mode.helperType && help[mode.helperType]) {\n\t        found.push(help[mode.helperType]);\n\t      } else if (help[mode.name]) {\n\t        found.push(help[mode.name]);\n\t      }\n\t      for (var i = 0; i < help._global.length; i++) {\n\t        var cur = help._global[i];\n\t        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n\t          found.push(cur.val);\n\t      }\n\t      return found;\n\t    },\n\t\n\t    getStateAfter: function(line, precise) {\n\t      var doc = this.doc;\n\t      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n\t      return getStateBefore(this, line + 1, precise);\n\t    },\n\t\n\t    cursorCoords: function(start, mode) {\n\t      var pos, range = this.doc.sel.primary();\n\t      if (start == null) pos = range.head;\n\t      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n\t      else pos = start ? range.from() : range.to();\n\t      return cursorCoords(this, pos, mode || \"page\");\n\t    },\n\t\n\t    charCoords: function(pos, mode) {\n\t      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n\t    },\n\t\n\t    coordsChar: function(coords, mode) {\n\t      coords = fromCoordSystem(this, coords, mode || \"page\");\n\t      return coordsChar(this, coords.left, coords.top);\n\t    },\n\t\n\t    lineAtHeight: function(height, mode) {\n\t      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n\t      return lineAtHeight(this.doc, height + this.display.viewOffset);\n\t    },\n\t    heightAtLine: function(line, mode) {\n\t      var end = false, lineObj;\n\t      if (typeof line == \"number\") {\n\t        var last = this.doc.first + this.doc.size - 1;\n\t        if (line < this.doc.first) line = this.doc.first;\n\t        else if (line > last) { line = last; end = true; }\n\t        lineObj = getLine(this.doc, line);\n\t      } else {\n\t        lineObj = line;\n\t      }\n\t      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n\t        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n\t    },\n\t\n\t    defaultTextHeight: function() { return textHeight(this.display); },\n\t    defaultCharWidth: function() { return charWidth(this.display); },\n\t\n\t    setGutterMarker: methodOp(function(line, gutterID, value) {\n\t      return changeLine(this.doc, line, \"gutter\", function(line) {\n\t        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n\t        markers[gutterID] = value;\n\t        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    clearGutter: methodOp(function(gutterID) {\n\t      var cm = this, doc = cm.doc, i = doc.first;\n\t      doc.iter(function(line) {\n\t        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n\t          line.gutterMarkers[gutterID] = null;\n\t          regLineChange(cm, i, \"gutter\");\n\t          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n\t        }\n\t        ++i;\n\t      });\n\t    }),\n\t\n\t    lineInfo: function(line) {\n\t      if (typeof line == \"number\") {\n\t        if (!isLine(this.doc, line)) return null;\n\t        var n = line;\n\t        line = getLine(this.doc, line);\n\t        if (!line) return null;\n\t      } else {\n\t        var n = lineNo(line);\n\t        if (n == null) return null;\n\t      }\n\t      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n\t              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n\t              widgets: line.widgets};\n\t    },\n\t\n\t    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\t\n\t    addWidget: function(pos, node, scroll, vert, horiz) {\n\t      var display = this.display;\n\t      pos = cursorCoords(this, clipPos(this.doc, pos));\n\t      var top = pos.bottom, left = pos.left;\n\t      node.style.position = \"absolute\";\n\t      node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      this.display.input.setUneditable(node);\n\t      display.sizer.appendChild(node);\n\t      if (vert == \"over\") {\n\t        top = pos.top;\n\t      } else if (vert == \"above\" || vert == \"near\") {\n\t        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n\t        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n\t        // Default to positioning above (if specified and possible); otherwise default to positioning below\n\t        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n\t          top = pos.top - node.offsetHeight;\n\t        else if (pos.bottom + node.offsetHeight <= vspace)\n\t          top = pos.bottom;\n\t        if (left + node.offsetWidth > hspace)\n\t          left = hspace - node.offsetWidth;\n\t      }\n\t      node.style.top = top + \"px\";\n\t      node.style.left = node.style.right = \"\";\n\t      if (horiz == \"right\") {\n\t        left = display.sizer.clientWidth - node.offsetWidth;\n\t        node.style.right = \"0px\";\n\t      } else {\n\t        if (horiz == \"left\") left = 0;\n\t        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n\t        node.style.left = left + \"px\";\n\t      }\n\t      if (scroll)\n\t        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n\t    },\n\t\n\t    triggerOnKeyDown: methodOp(onKeyDown),\n\t    triggerOnKeyPress: methodOp(onKeyPress),\n\t    triggerOnKeyUp: onKeyUp,\n\t\n\t    execCommand: function(cmd) {\n\t      if (commands.hasOwnProperty(cmd))\n\t        return commands[cmd].call(null, this);\n\t    },\n\t\n\t    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\t\n\t    findPosH: function(from, amount, unit, visually) {\n\t      var dir = 1;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        cur = findPosH(this.doc, cur, dir, unit, visually);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveH: methodOp(function(dir, unit) {\n\t      var cm = this;\n\t      cm.extendSelectionsBy(function(range) {\n\t        if (cm.display.shift || cm.doc.extend || range.empty())\n\t          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n\t        else\n\t          return dir < 0 ? range.from() : range.to();\n\t      }, sel_move);\n\t    }),\n\t\n\t    deleteH: methodOp(function(dir, unit) {\n\t      var sel = this.doc.sel, doc = this.doc;\n\t      if (sel.somethingSelected())\n\t        doc.replaceSelection(\"\", null, \"+delete\");\n\t      else\n\t        deleteNearSelection(this, function(range) {\n\t          var other = findPosH(doc, range.head, dir, unit, false);\n\t          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n\t        });\n\t    }),\n\t\n\t    findPosV: function(from, amount, unit, goalColumn) {\n\t      var dir = 1, x = goalColumn;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        var coords = cursorCoords(this, cur, \"div\");\n\t        if (x == null) x = coords.left;\n\t        else coords.left = x;\n\t        cur = findPosV(this, coords, dir, unit);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveV: methodOp(function(dir, unit) {\n\t      var cm = this, doc = this.doc, goals = [];\n\t      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n\t      doc.extendSelectionsBy(function(range) {\n\t        if (collapse)\n\t          return dir < 0 ? range.from() : range.to();\n\t        var headPos = cursorCoords(cm, range.head, \"div\");\n\t        if (range.goalColumn != null) headPos.left = range.goalColumn;\n\t        goals.push(headPos.left);\n\t        var pos = findPosV(cm, headPos, dir, unit);\n\t        if (unit == \"page\" && range == doc.sel.primary())\n\t          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n\t        return pos;\n\t      }, sel_move);\n\t      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n\t        doc.sel.ranges[i].goalColumn = goals[i];\n\t    }),\n\t\n\t    // Find the word at the given position (as returned by coordsChar).\n\t    findWordAt: function(pos) {\n\t      var doc = this.doc, line = getLine(doc, pos.line).text;\n\t      var start = pos.ch, end = pos.ch;\n\t      if (line) {\n\t        var helper = this.getHelper(pos, \"wordChars\");\n\t        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n\t        var startChar = line.charAt(start);\n\t        var check = isWordChar(startChar, helper)\n\t          ? function(ch) { return isWordChar(ch, helper); }\n\t          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n\t          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n\t        while (start > 0 && check(line.charAt(start - 1))) --start;\n\t        while (end < line.length && check(line.charAt(end))) ++end;\n\t      }\n\t      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n\t    },\n\t\n\t    toggleOverwrite: function(value) {\n\t      if (value != null && value == this.state.overwrite) return;\n\t      if (this.state.overwrite = !this.state.overwrite)\n\t        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t      else\n\t        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t\n\t      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n\t    },\n\t    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n\t\n\t    scrollTo: methodOp(function(x, y) {\n\t      if (x != null || y != null) resolveScrollToPos(this);\n\t      if (x != null) this.curOp.scrollLeft = x;\n\t      if (y != null) this.curOp.scrollTop = y;\n\t    }),\n\t    getScrollInfo: function() {\n\t      var scroller = this.display.scroller;\n\t      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n\t              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n\t              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n\t              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n\t    },\n\t\n\t    scrollIntoView: methodOp(function(range, margin) {\n\t      if (range == null) {\n\t        range = {from: this.doc.sel.primary().head, to: null};\n\t        if (margin == null) margin = this.options.cursorScrollMargin;\n\t      } else if (typeof range == \"number\") {\n\t        range = {from: Pos(range, 0), to: null};\n\t      } else if (range.from == null) {\n\t        range = {from: range, to: null};\n\t      }\n\t      if (!range.to) range.to = range.from;\n\t      range.margin = margin || 0;\n\t\n\t      if (range.from.line != null) {\n\t        resolveScrollToPos(this);\n\t        this.curOp.scrollToPos = range;\n\t      } else {\n\t        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n\t                                      Math.min(range.from.top, range.to.top) - range.margin,\n\t                                      Math.max(range.from.right, range.to.right),\n\t                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n\t        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t      }\n\t    }),\n\t\n\t    setSize: methodOp(function(width, height) {\n\t      var cm = this;\n\t      function interpret(val) {\n\t        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n\t      }\n\t      if (width != null) cm.display.wrapper.style.width = interpret(width);\n\t      if (height != null) cm.display.wrapper.style.height = interpret(height);\n\t      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n\t      var lineNo = cm.display.viewFrom;\n\t      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n\t        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n\t          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n\t        ++lineNo;\n\t      });\n\t      cm.curOp.forceUpdate = true;\n\t      signal(cm, \"refresh\", this);\n\t    }),\n\t\n\t    operation: function(f){return runInOp(this, f);},\n\t\n\t    refresh: methodOp(function() {\n\t      var oldHeight = this.display.cachedTextHeight;\n\t      regChange(this);\n\t      this.curOp.forceUpdate = true;\n\t      clearCaches(this);\n\t      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n\t      updateGutterSpace(this);\n\t      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n\t        estimateLineHeights(this);\n\t      signal(this, \"refresh\", this);\n\t    }),\n\t\n\t    swapDoc: methodOp(function(doc) {\n\t      var old = this.doc;\n\t      old.cm = null;\n\t      attachDoc(this, doc);\n\t      clearCaches(this);\n\t      this.display.input.reset();\n\t      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n\t      this.curOp.forceScroll = true;\n\t      signalLater(this, \"swapDoc\", this, old);\n\t      return old;\n\t    }),\n\t\n\t    getInputField: function(){return this.display.input.getField();},\n\t    getWrapperElement: function(){return this.display.wrapper;},\n\t    getScrollerElement: function(){return this.display.scroller;},\n\t    getGutterElement: function(){return this.display.gutters;}\n\t  };\n\t  eventMixin(CodeMirror);\n\t\n\t  // OPTION DEFAULTS\n\t\n\t  // The default configuration options.\n\t  var defaults = CodeMirror.defaults = {};\n\t  // Functions to run when options are changed.\n\t  var optionHandlers = CodeMirror.optionHandlers = {};\n\t\n\t  function option(name, deflt, handle, notOnInit) {\n\t    CodeMirror.defaults[name] = deflt;\n\t    if (handle) optionHandlers[name] =\n\t      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n\t  }\n\t\n\t  // Passed to option handlers when there is no old value.\n\t  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\t\n\t  // These two are, on init, called from the constructor because they\n\t  // have to be initialized before the editor can start at all.\n\t  option(\"value\", \"\", function(cm, val) {\n\t    cm.setValue(val);\n\t  }, true);\n\t  option(\"mode\", null, function(cm, val) {\n\t    cm.doc.modeOption = val;\n\t    loadMode(cm);\n\t  }, true);\n\t\n\t  option(\"indentUnit\", 2, loadMode, true);\n\t  option(\"indentWithTabs\", false);\n\t  option(\"smartIndent\", true);\n\t  option(\"tabSize\", 4, function(cm) {\n\t    resetModeState(cm);\n\t    clearCaches(cm);\n\t    regChange(cm);\n\t  }, true);\n\t  option(\"lineSeparator\", null, function(cm, val) {\n\t    cm.doc.lineSep = val;\n\t    if (!val) return;\n\t    var newBreaks = [], lineNo = cm.doc.first;\n\t    cm.doc.iter(function(line) {\n\t      for (var pos = 0;;) {\n\t        var found = line.text.indexOf(val, pos);\n\t        if (found == -1) break;\n\t        pos = found + val.length;\n\t        newBreaks.push(Pos(lineNo, found));\n\t      }\n\t      lineNo++;\n\t    });\n\t    for (var i = newBreaks.length - 1; i >= 0; i--)\n\t      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n\t  });\n\t  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n\t    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n\t    if (old != CodeMirror.Init) cm.refresh();\n\t  });\n\t  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n\t  option(\"electricChars\", true);\n\t  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n\t    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n\t  }, true);\n\t  option(\"rtlMoveVisually\", !windows);\n\t  option(\"wholeLineUpdateBefore\", true);\n\t\n\t  option(\"theme\", \"default\", function(cm) {\n\t    themeChanged(cm);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"keyMap\", \"default\", function(cm, val, old) {\n\t    var next = getKeyMap(val);\n\t    var prev = old != CodeMirror.Init && getKeyMap(old);\n\t    if (prev && prev.detach) prev.detach(cm, next);\n\t    if (next.attach) next.attach(cm, prev || null);\n\t  });\n\t  option(\"extraKeys\", null);\n\t\n\t  option(\"lineWrapping\", false, wrappingChanged, true);\n\t  option(\"gutters\", [], function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"fixedGutter\", true, function(cm, val) {\n\t    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n\t    cm.refresh();\n\t  }, true);\n\t  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n\t  option(\"scrollbarStyle\", \"native\", function(cm) {\n\t    initScrollbars(cm);\n\t    updateScrollbars(cm);\n\t    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n\t    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n\t  }, true);\n\t  option(\"lineNumbers\", false, function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"firstLineNumber\", 1, guttersChanged, true);\n\t  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n\t  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\t\n\t  option(\"resetSelectionOnContextMenu\", true);\n\t  option(\"lineWiseCopyCut\", true);\n\t\n\t  option(\"readOnly\", false, function(cm, val) {\n\t    if (val == \"nocursor\") {\n\t      onBlur(cm);\n\t      cm.display.input.blur();\n\t      cm.display.disabled = true;\n\t    } else {\n\t      cm.display.disabled = false;\n\t    }\n\t    cm.display.input.readOnlyChanged(val)\n\t  });\n\t  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n\t  option(\"dragDrop\", true, dragDropChanged);\n\t  option(\"allowDropFileTypes\", null);\n\t\n\t  option(\"cursorBlinkRate\", 530);\n\t  option(\"cursorScrollMargin\", 0);\n\t  option(\"cursorHeight\", 1, updateSelection, true);\n\t  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n\t  option(\"workTime\", 100);\n\t  option(\"workDelay\", 100);\n\t  option(\"flattenSpans\", true, resetModeState, true);\n\t  option(\"addModeClass\", false, resetModeState, true);\n\t  option(\"pollInterval\", 100);\n\t  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n\t  option(\"historyEventDelay\", 1250);\n\t  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n\t  option(\"maxHighlightLength\", 10000, resetModeState, true);\n\t  option(\"moveInputWithCursor\", true, function(cm, val) {\n\t    if (!val) cm.display.input.resetPosition();\n\t  });\n\t\n\t  option(\"tabindex\", null, function(cm, val) {\n\t    cm.display.input.getField().tabIndex = val || \"\";\n\t  });\n\t  option(\"autofocus\", null);\n\t\n\t  // MODE DEFINITION AND QUERYING\n\t\n\t  // Known modes, by name and by MIME\n\t  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\t\n\t  // Extra arguments are stored as the mode's dependencies, which is\n\t  // used by (legacy) mechanisms like loadmode.js to automatically\n\t  // load a mode. (Preferred mechanism is the require/define calls.)\n\t  CodeMirror.defineMode = function(name, mode) {\n\t    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n\t    if (arguments.length > 2)\n\t      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n\t    modes[name] = mode;\n\t  };\n\t\n\t  CodeMirror.defineMIME = function(mime, spec) {\n\t    mimeModes[mime] = spec;\n\t  };\n\t\n\t  // Given a MIME type, a {name, ...options} config object, or a name\n\t  // string, return a mode config object.\n\t  CodeMirror.resolveMode = function(spec) {\n\t    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n\t      spec = mimeModes[spec];\n\t    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n\t      var found = mimeModes[spec.name];\n\t      if (typeof found == \"string\") found = {name: found};\n\t      spec = createObj(found, spec);\n\t      spec.name = found.name;\n\t    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n\t      return CodeMirror.resolveMode(\"application/xml\");\n\t    }\n\t    if (typeof spec == \"string\") return {name: spec};\n\t    else return spec || {name: \"null\"};\n\t  };\n\t\n\t  // Given a mode spec (anything that resolveMode accepts), find and\n\t  // initialize an actual mode object.\n\t  CodeMirror.getMode = function(options, spec) {\n\t    var spec = CodeMirror.resolveMode(spec);\n\t    var mfactory = modes[spec.name];\n\t    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n\t    var modeObj = mfactory(options, spec);\n\t    if (modeExtensions.hasOwnProperty(spec.name)) {\n\t      var exts = modeExtensions[spec.name];\n\t      for (var prop in exts) {\n\t        if (!exts.hasOwnProperty(prop)) continue;\n\t        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n\t        modeObj[prop] = exts[prop];\n\t      }\n\t    }\n\t    modeObj.name = spec.name;\n\t    if (spec.helperType) modeObj.helperType = spec.helperType;\n\t    if (spec.modeProps) for (var prop in spec.modeProps)\n\t      modeObj[prop] = spec.modeProps[prop];\n\t\n\t    return modeObj;\n\t  };\n\t\n\t  // Minimal default mode.\n\t  CodeMirror.defineMode(\"null\", function() {\n\t    return {token: function(stream) {stream.skipToEnd();}};\n\t  });\n\t  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\t\n\t  // This can be used to attach properties to mode objects from\n\t  // outside the actual mode definition.\n\t  var modeExtensions = CodeMirror.modeExtensions = {};\n\t  CodeMirror.extendMode = function(mode, properties) {\n\t    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n\t    copyObj(properties, exts);\n\t  };\n\t\n\t  // EXTENSIONS\n\t\n\t  CodeMirror.defineExtension = function(name, func) {\n\t    CodeMirror.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineDocExtension = function(name, func) {\n\t    Doc.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineOption = option;\n\t\n\t  var initHooks = [];\n\t  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\t\n\t  var helpers = CodeMirror.helpers = {};\n\t  CodeMirror.registerHelper = function(type, name, value) {\n\t    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n\t    helpers[type][name] = value;\n\t  };\n\t  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n\t    CodeMirror.registerHelper(type, name, value);\n\t    helpers[type]._global.push({pred: predicate, val: value});\n\t  };\n\t\n\t  // MODE STATE HANDLING\n\t\n\t  // Utility functions for working with state. Exported because nested\n\t  // modes need to do this for their inner modes.\n\t\n\t  var copyState = CodeMirror.copyState = function(mode, state) {\n\t    if (state === true) return state;\n\t    if (mode.copyState) return mode.copyState(state);\n\t    var nstate = {};\n\t    for (var n in state) {\n\t      var val = state[n];\n\t      if (val instanceof Array) val = val.concat([]);\n\t      nstate[n] = val;\n\t    }\n\t    return nstate;\n\t  };\n\t\n\t  var startState = CodeMirror.startState = function(mode, a1, a2) {\n\t    return mode.startState ? mode.startState(a1, a2) : true;\n\t  };\n\t\n\t  // Given a mode and a state (for that mode), find the inner mode and\n\t  // state at the position that the state refers to.\n\t  CodeMirror.innerMode = function(mode, state) {\n\t    while (mode.innerMode) {\n\t      var info = mode.innerMode(state);\n\t      if (!info || info.mode == mode) break;\n\t      state = info.state;\n\t      mode = info.mode;\n\t    }\n\t    return info || {mode: mode, state: state};\n\t  };\n\t\n\t  // STANDARD COMMANDS\n\t\n\t  // Commands are parameter-less actions that can be performed on an\n\t  // editor, mostly used for keybindings.\n\t  var commands = CodeMirror.commands = {\n\t    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n\t    singleSelection: function(cm) {\n\t      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n\t    },\n\t    killLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        if (range.empty()) {\n\t          var len = getLine(cm.doc, range.head.line).text.length;\n\t          if (range.head.ch == len && range.head.line < cm.lastLine())\n\t            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n\t          else\n\t            return {from: range.head, to: Pos(range.head.line, len)};\n\t        } else {\n\t          return {from: range.from(), to: range.to()};\n\t        }\n\t      });\n\t    },\n\t    deleteLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0),\n\t                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n\t      });\n\t    },\n\t    delLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0), to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        return {from: leftPos, to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineRight: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t        return {from: range.from(), to: rightPos };\n\t      });\n\t    },\n\t    undo: function(cm) {cm.undo();},\n\t    redo: function(cm) {cm.redo();},\n\t    undoSelection: function(cm) {cm.undoSelection();},\n\t    redoSelection: function(cm) {cm.redoSelection();},\n\t    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n\t    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n\t    goLineStart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineStartSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        return lineStartSmart(cm, range.head);\n\t      }, {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineEnd: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: -1});\n\t    },\n\t    goLineRight: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeft: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: 0, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeftSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n\t        return pos;\n\t      }, sel_move);\n\t    },\n\t    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n\t    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n\t    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n\t    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n\t    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n\t    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n\t    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n\t    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n\t    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n\t    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n\t    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n\t    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n\t    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n\t    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n\t    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n\t    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n\t    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n\t    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n\t    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n\t    indentMore: function(cm) {cm.indentSelection(\"add\");},\n\t    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n\t    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n\t    insertSoftTab: function(cm) {\n\t      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var pos = ranges[i].from();\n\t        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n\t        spaces.push(new Array(tabSize - col % tabSize + 1).join(\" \"));\n\t      }\n\t      cm.replaceSelections(spaces);\n\t    },\n\t    defaultTab: function(cm) {\n\t      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n\t      else cm.execCommand(\"insertTab\");\n\t    },\n\t    transposeChars: function(cm) {\n\t      runInOp(cm, function() {\n\t        var ranges = cm.listSelections(), newSel = [];\n\t        for (var i = 0; i < ranges.length; i++) {\n\t          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n\t          if (line) {\n\t            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n\t            if (cur.ch > 0) {\n\t              cur = new Pos(cur.line, cur.ch + 1);\n\t              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n\t                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n\t            } else if (cur.line > cm.doc.first) {\n\t              var prev = getLine(cm.doc, cur.line - 1).text;\n\t              if (prev)\n\t                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n\t                                prev.charAt(prev.length - 1),\n\t                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n\t            }\n\t          }\n\t          newSel.push(new Range(cur, cur));\n\t        }\n\t        cm.setSelections(newSel);\n\t      });\n\t    },\n\t    newlineAndIndent: function(cm) {\n\t      runInOp(cm, function() {\n\t        var len = cm.listSelections().length;\n\t        for (var i = 0; i < len; i++) {\n\t          var range = cm.listSelections()[i];\n\t          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n\t          cm.indentLine(range.from().line + 1, null, true);\n\t        }\n\t        ensureCursorVisible(cm);\n\t      });\n\t    },\n\t    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n\t  };\n\t\n\t\n\t  // STANDARD KEYMAPS\n\t\n\t  var keyMap = CodeMirror.keyMap = {};\n\t\n\t  keyMap.basic = {\n\t    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n\t    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n\t    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n\t    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n\t    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n\t    \"Esc\": \"singleSelection\"\n\t  };\n\t  // Note that the save and find-related commands aren't defined by\n\t  // default. User code or addons can define them. Unknown commands\n\t  // are simply ignored.\n\t  keyMap.pcDefault = {\n\t    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n\t    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n\t    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n\t    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n\t    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n\t    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n\t    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n\t    fallthrough: \"basic\"\n\t  };\n\t  // Very basic readline/emacs-style bindings, which are standard on Mac.\n\t  keyMap.emacsy = {\n\t    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n\t    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n\t    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n\t    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n\t  };\n\t  keyMap.macDefault = {\n\t    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n\t    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n\t    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n\t    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n\t    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n\t    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n\t    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n\t    fallthrough: [\"basic\", \"emacsy\"]\n\t  };\n\t  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\t\n\t  // KEYMAP DISPATCH\n\t\n\t  function normalizeKeyName(name) {\n\t    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n\t    var alt, ctrl, shift, cmd;\n\t    for (var i = 0; i < parts.length - 1; i++) {\n\t      var mod = parts[i];\n\t      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n\t      else if (/^a(lt)?$/i.test(mod)) alt = true;\n\t      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n\t      else if (/^s(hift)$/i.test(mod)) shift = true;\n\t      else throw new Error(\"Unrecognized modifier name: \" + mod);\n\t    }\n\t    if (alt) name = \"Alt-\" + name;\n\t    if (ctrl) name = \"Ctrl-\" + name;\n\t    if (cmd) name = \"Cmd-\" + name;\n\t    if (shift) name = \"Shift-\" + name;\n\t    return name;\n\t  }\n\t\n\t  // This is a kludge to keep keymaps mostly working as raw objects\n\t  // (backwards compatibility) while at the same time support features\n\t  // like normalization and multi-stroke key bindings. It compiles a\n\t  // new normalized keymap, and then updates the old object to reflect\n\t  // this.\n\t  CodeMirror.normalizeKeyMap = function(keymap) {\n\t    var copy = {};\n\t    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n\t      var value = keymap[keyname];\n\t      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n\t      if (value == \"...\") { delete keymap[keyname]; continue; }\n\t\n\t      var keys = map(keyname.split(\" \"), normalizeKeyName);\n\t      for (var i = 0; i < keys.length; i++) {\n\t        var val, name;\n\t        if (i == keys.length - 1) {\n\t          name = keys.join(\" \");\n\t          val = value;\n\t        } else {\n\t          name = keys.slice(0, i + 1).join(\" \");\n\t          val = \"...\";\n\t        }\n\t        var prev = copy[name];\n\t        if (!prev) copy[name] = val;\n\t        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n\t      }\n\t      delete keymap[keyname];\n\t    }\n\t    for (var prop in copy) keymap[prop] = copy[prop];\n\t    return keymap;\n\t  };\n\t\n\t  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n\t    map = getKeyMap(map);\n\t    var found = map.call ? map.call(key, context) : map[key];\n\t    if (found === false) return \"nothing\";\n\t    if (found === \"...\") return \"multi\";\n\t    if (found != null && handle(found)) return \"handled\";\n\t\n\t    if (map.fallthrough) {\n\t      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n\t        return lookupKey(key, map.fallthrough, handle, context);\n\t      for (var i = 0; i < map.fallthrough.length; i++) {\n\t        var result = lookupKey(key, map.fallthrough[i], handle, context);\n\t        if (result) return result;\n\t      }\n\t    }\n\t  };\n\t\n\t  // Modifier key presses don't count as 'real' key presses for the\n\t  // purpose of keymap fallthrough.\n\t  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n\t    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n\t    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n\t  };\n\t\n\t  // Look up the name of a key as indicated by an event object.\n\t  var keyName = CodeMirror.keyName = function(event, noShift) {\n\t    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n\t    var base = keyNames[event.keyCode], name = base;\n\t    if (name == null || event.altGraphKey) return false;\n\t    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n\t    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n\t    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n\t    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n\t    return name;\n\t  };\n\t\n\t  function getKeyMap(val) {\n\t    return typeof val == \"string\" ? keyMap[val] : val;\n\t  }\n\t\n\t  // FROMTEXTAREA\n\t\n\t  CodeMirror.fromTextArea = function(textarea, options) {\n\t    options = options ? copyObj(options) : {};\n\t    options.value = textarea.value;\n\t    if (!options.tabindex && textarea.tabIndex)\n\t      options.tabindex = textarea.tabIndex;\n\t    if (!options.placeholder && textarea.placeholder)\n\t      options.placeholder = textarea.placeholder;\n\t    // Set autofocus to true if this textarea is focused, or if it has\n\t    // autofocus and no other element is focused.\n\t    if (options.autofocus == null) {\n\t      var hasFocus = activeElt();\n\t      options.autofocus = hasFocus == textarea ||\n\t        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n\t    }\n\t\n\t    function save() {textarea.value = cm.getValue();}\n\t    if (textarea.form) {\n\t      on(textarea.form, \"submit\", save);\n\t      // Deplorable hack to make the submit method do the right thing.\n\t      if (!options.leaveSubmitMethodAlone) {\n\t        var form = textarea.form, realSubmit = form.submit;\n\t        try {\n\t          var wrappedSubmit = form.submit = function() {\n\t            save();\n\t            form.submit = realSubmit;\n\t            form.submit();\n\t            form.submit = wrappedSubmit;\n\t          };\n\t        } catch(e) {}\n\t      }\n\t    }\n\t\n\t    options.finishInit = function(cm) {\n\t      cm.save = save;\n\t      cm.getTextArea = function() { return textarea; };\n\t      cm.toTextArea = function() {\n\t        cm.toTextArea = isNaN; // Prevent this from being ran twice\n\t        save();\n\t        textarea.parentNode.removeChild(cm.getWrapperElement());\n\t        textarea.style.display = \"\";\n\t        if (textarea.form) {\n\t          off(textarea.form, \"submit\", save);\n\t          if (typeof textarea.form.submit == \"function\")\n\t            textarea.form.submit = realSubmit;\n\t        }\n\t      };\n\t    };\n\t\n\t    textarea.style.display = \"none\";\n\t    var cm = CodeMirror(function(node) {\n\t      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n\t    }, options);\n\t    return cm;\n\t  };\n\t\n\t  // STRING STREAM\n\t\n\t  // Fed to the mode parsers, provides helper functions to make\n\t  // parsers more succinct.\n\t\n\t  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n\t    this.pos = this.start = 0;\n\t    this.string = string;\n\t    this.tabSize = tabSize || 8;\n\t    this.lastColumnPos = this.lastColumnValue = 0;\n\t    this.lineStart = 0;\n\t  };\n\t\n\t  StringStream.prototype = {\n\t    eol: function() {return this.pos >= this.string.length;},\n\t    sol: function() {return this.pos == this.lineStart;},\n\t    peek: function() {return this.string.charAt(this.pos) || undefined;},\n\t    next: function() {\n\t      if (this.pos < this.string.length)\n\t        return this.string.charAt(this.pos++);\n\t    },\n\t    eat: function(match) {\n\t      var ch = this.string.charAt(this.pos);\n\t      if (typeof match == \"string\") var ok = ch == match;\n\t      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n\t      if (ok) {++this.pos; return ch;}\n\t    },\n\t    eatWhile: function(match) {\n\t      var start = this.pos;\n\t      while (this.eat(match)){}\n\t      return this.pos > start;\n\t    },\n\t    eatSpace: function() {\n\t      var start = this.pos;\n\t      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n\t      return this.pos > start;\n\t    },\n\t    skipToEnd: function() {this.pos = this.string.length;},\n\t    skipTo: function(ch) {\n\t      var found = this.string.indexOf(ch, this.pos);\n\t      if (found > -1) {this.pos = found; return true;}\n\t    },\n\t    backUp: function(n) {this.pos -= n;},\n\t    column: function() {\n\t      if (this.lastColumnPos < this.start) {\n\t        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n\t        this.lastColumnPos = this.start;\n\t      }\n\t      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    indentation: function() {\n\t      return countColumn(this.string, null, this.tabSize) -\n\t        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    match: function(pattern, consume, caseInsensitive) {\n\t      if (typeof pattern == \"string\") {\n\t        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n\t        var substr = this.string.substr(this.pos, pattern.length);\n\t        if (cased(substr) == cased(pattern)) {\n\t          if (consume !== false) this.pos += pattern.length;\n\t          return true;\n\t        }\n\t      } else {\n\t        var match = this.string.slice(this.pos).match(pattern);\n\t        if (match && match.index > 0) return null;\n\t        if (match && consume !== false) this.pos += match[0].length;\n\t        return match;\n\t      }\n\t    },\n\t    current: function(){return this.string.slice(this.start, this.pos);},\n\t    hideFirstChars: function(n, inner) {\n\t      this.lineStart += n;\n\t      try { return inner(); }\n\t      finally { this.lineStart -= n; }\n\t    }\n\t  };\n\t\n\t  // TEXTMARKERS\n\t\n\t  // Created with markText and setBookmark methods. A TextMarker is a\n\t  // handle that can be used to clear or find a marked position in the\n\t  // document. Line objects hold arrays (markedSpans) containing\n\t  // {from, to, marker} object pointing to such marker objects, and\n\t  // indicating that such a marker is present on that line. Multiple\n\t  // lines may point to the same marker when it spans across lines.\n\t  // The spans will have null for their from/to properties when the\n\t  // marker continues beyond the start/end of the line. Markers have\n\t  // links back to the lines they currently touch.\n\t\n\t  var nextMarkerId = 0;\n\t\n\t  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n\t    this.lines = [];\n\t    this.type = type;\n\t    this.doc = doc;\n\t    this.id = ++nextMarkerId;\n\t  };\n\t  eventMixin(TextMarker);\n\t\n\t  // Clear the marker.\n\t  TextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n\t    if (withOp) startOperation(cm);\n\t    if (hasHandler(this, \"clear\")) {\n\t      var found = this.find();\n\t      if (found) signalLater(this, \"clear\", found.from, found.to);\n\t    }\n\t    var min = null, max = null;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n\t      else if (cm) {\n\t        if (span.to != null) max = lineNo(line);\n\t        if (span.from != null) min = lineNo(line);\n\t      }\n\t      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n\t      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n\t        updateLineHeight(line, textHeight(cm.display));\n\t    }\n\t    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n\t      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n\t      if (len > cm.display.maxLineLength) {\n\t        cm.display.maxLine = visual;\n\t        cm.display.maxLineLength = len;\n\t        cm.display.maxLineChanged = true;\n\t      }\n\t    }\n\t\n\t    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n\t    this.lines.length = 0;\n\t    this.explicitlyCleared = true;\n\t    if (this.atomic && this.doc.cantEdit) {\n\t      this.doc.cantEdit = false;\n\t      if (cm) reCheckSelection(cm.doc);\n\t    }\n\t    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n\t    if (withOp) endOperation(cm);\n\t    if (this.parent) this.parent.clear();\n\t  };\n\t\n\t  // Find the position of the marker in the document. Returns a {from,\n\t  // to} object by default. Side can be passed to get a specific side\n\t  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n\t  // Pos objects returned contain a line object, rather than a line\n\t  // number (used to prevent looking up the same line twice).\n\t  TextMarker.prototype.find = function(side, lineObj) {\n\t    if (side == null && this.type == \"bookmark\") side = 1;\n\t    var from, to;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (span.from != null) {\n\t        from = Pos(lineObj ? line : lineNo(line), span.from);\n\t        if (side == -1) return from;\n\t      }\n\t      if (span.to != null) {\n\t        to = Pos(lineObj ? line : lineNo(line), span.to);\n\t        if (side == 1) return to;\n\t      }\n\t    }\n\t    return from && {from: from, to: to};\n\t  };\n\t\n\t  // Signals that the marker's widget changed, and surrounding layout\n\t  // should be recomputed.\n\t  TextMarker.prototype.changed = function() {\n\t    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n\t    if (!pos || !cm) return;\n\t    runInOp(cm, function() {\n\t      var line = pos.line, lineN = lineNo(pos.line);\n\t      var view = findViewForLine(cm, lineN);\n\t      if (view) {\n\t        clearLineMeasurementCacheFor(view);\n\t        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n\t      }\n\t      cm.curOp.updateMaxLine = true;\n\t      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n\t        var oldHeight = widget.height;\n\t        widget.height = null;\n\t        var dHeight = widgetHeight(widget) - oldHeight;\n\t        if (dHeight)\n\t          updateLineHeight(line, line.height + dHeight);\n\t      }\n\t    });\n\t  };\n\t\n\t  TextMarker.prototype.attachLine = function(line) {\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n\t        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n\t    }\n\t    this.lines.push(line);\n\t  };\n\t  TextMarker.prototype.detachLine = function(line) {\n\t    this.lines.splice(indexOf(this.lines, line), 1);\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n\t    }\n\t  };\n\t\n\t  // Collapsed markers have unique ids, in order to be able to order\n\t  // them, which is needed for uniquely determining an outer marker\n\t  // when they overlap (they may nest, but not partially overlap).\n\t  var nextMarkerId = 0;\n\t\n\t  // Create a marker, wire it up to the right lines, and\n\t  function markText(doc, from, to, options, type) {\n\t    // Shared markers (across linked documents) are handled separately\n\t    // (markTextShared will call out to this again, once per\n\t    // document).\n\t    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n\t    // Ensure we are in an operation.\n\t    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\t\n\t    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n\t    if (options) copyObj(options, marker, false);\n\t    // Don't connect empty markers unless clearWhenEmpty is false\n\t    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n\t      return marker;\n\t    if (marker.replacedWith) {\n\t      // Showing up as a widget implies collapsed (widget replaces text)\n\t      marker.collapsed = true;\n\t      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n\t      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n\t      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n\t    }\n\t    if (marker.collapsed) {\n\t      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n\t          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n\t        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n\t      sawCollapsedSpans = true;\n\t    }\n\t\n\t    if (marker.addToHistory)\n\t      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\t\n\t    var curLine = from.line, cm = doc.cm, updateMaxLine;\n\t    doc.iter(curLine, to.line + 1, function(line) {\n\t      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n\t        updateMaxLine = true;\n\t      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n\t      addMarkedSpan(line, new MarkedSpan(marker,\n\t                                         curLine == from.line ? from.ch : null,\n\t                                         curLine == to.line ? to.ch : null));\n\t      ++curLine;\n\t    });\n\t    // lineIsHidden depends on the presence of the spans, so needs a second pass\n\t    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n\t      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n\t    });\n\t\n\t    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\t\n\t    if (marker.readOnly) {\n\t      sawReadOnlySpans = true;\n\t      if (doc.history.done.length || doc.history.undone.length)\n\t        doc.clearHistory();\n\t    }\n\t    if (marker.collapsed) {\n\t      marker.id = ++nextMarkerId;\n\t      marker.atomic = true;\n\t    }\n\t    if (cm) {\n\t      // Sync editor state\n\t      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n\t      if (marker.collapsed)\n\t        regChange(cm, from.line, to.line + 1);\n\t      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n\t        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n\t      if (marker.atomic) reCheckSelection(cm.doc);\n\t      signalLater(cm, \"markerAdded\", cm, marker);\n\t    }\n\t    return marker;\n\t  }\n\t\n\t  // SHARED TEXTMARKERS\n\t\n\t  // A shared marker spans multiple linked documents. It is\n\t  // implemented as a meta-marker-object controlling multiple normal\n\t  // markers.\n\t  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n\t    this.markers = markers;\n\t    this.primary = primary;\n\t    for (var i = 0; i < markers.length; ++i)\n\t      markers[i].parent = this;\n\t  };\n\t  eventMixin(SharedTextMarker);\n\t\n\t  SharedTextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    this.explicitlyCleared = true;\n\t    for (var i = 0; i < this.markers.length; ++i)\n\t      this.markers[i].clear();\n\t    signalLater(this, \"clear\");\n\t  };\n\t  SharedTextMarker.prototype.find = function(side, lineObj) {\n\t    return this.primary.find(side, lineObj);\n\t  };\n\t\n\t  function markTextShared(doc, from, to, options, type) {\n\t    options = copyObj(options);\n\t    options.shared = false;\n\t    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n\t    var widget = options.widgetNode;\n\t    linkedDocs(doc, function(doc) {\n\t      if (widget) options.widgetNode = widget.cloneNode(true);\n\t      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n\t      for (var i = 0; i < doc.linked.length; ++i)\n\t        if (doc.linked[i].isParent) return;\n\t      primary = lst(markers);\n\t    });\n\t    return new SharedTextMarker(markers, primary);\n\t  }\n\t\n\t  function findSharedMarkers(doc) {\n\t    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n\t                         function(m) { return m.parent; });\n\t  }\n\t\n\t  function copySharedMarkers(doc, markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], pos = marker.find();\n\t      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n\t      if (cmp(mFrom, mTo)) {\n\t        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n\t        marker.markers.push(subMark);\n\t        subMark.parent = marker;\n\t      }\n\t    }\n\t  }\n\t\n\t  function detachSharedMarkers(markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], linked = [marker.primary.doc];;\n\t      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n\t      for (var j = 0; j < marker.markers.length; j++) {\n\t        var subMarker = marker.markers[j];\n\t        if (indexOf(linked, subMarker.doc) == -1) {\n\t          subMarker.parent = null;\n\t          marker.markers.splice(j--, 1);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // TEXTMARKER SPANS\n\t\n\t  function MarkedSpan(marker, from, to) {\n\t    this.marker = marker;\n\t    this.from = from; this.to = to;\n\t  }\n\t\n\t  // Search an array of spans for a span matching the given marker.\n\t  function getMarkedSpanFor(spans, marker) {\n\t    if (spans) for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.marker == marker) return span;\n\t    }\n\t  }\n\t  // Remove a span from an array, returning undefined if no spans are\n\t  // left (we don't store arrays for lines without spans).\n\t  function removeMarkedSpan(spans, span) {\n\t    for (var r, i = 0; i < spans.length; ++i)\n\t      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n\t    return r;\n\t  }\n\t  // Add a span to a line.\n\t  function addMarkedSpan(line, span) {\n\t    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n\t    span.marker.attachLine(line);\n\t  }\n\t\n\t  // Used for the algorithm that adjusts markers for a change in the\n\t  // document. These functions cut an array of spans at a given\n\t  // character position, returning an array of remaining chunks (or\n\t  // undefined if nothing remains).\n\t  function markedSpansBefore(old, startCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n\t      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n\t        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t  function markedSpansAfter(old, endCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n\t      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n\t        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n\t                                              span.to == null ? null : span.to - endCh));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t\n\t  // Given a change object, compute the new set of marker spans that\n\t  // cover the line in which the change took place. Removes spans\n\t  // entirely within the change, reconnects spans belonging to the\n\t  // same marker that appear on both sides of the change, and cuts off\n\t  // spans partially within the change. Returns an array of span\n\t  // arrays with one element for each line in (after) the change.\n\t  function stretchSpansOverChange(doc, change) {\n\t    if (change.full) return null;\n\t    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n\t    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n\t    if (!oldFirst && !oldLast) return null;\n\t\n\t    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n\t    // Get the spans that 'stick out' on both sides\n\t    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n\t    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\t\n\t    // Next, merge those two ends\n\t    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n\t    if (first) {\n\t      // Fix up .to properties of first\n\t      for (var i = 0; i < first.length; ++i) {\n\t        var span = first[i];\n\t        if (span.to == null) {\n\t          var found = getMarkedSpanFor(last, span.marker);\n\t          if (!found) span.to = startCh;\n\t          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n\t        }\n\t      }\n\t    }\n\t    if (last) {\n\t      // Fix up .from in last (or move them into first in case of sameLine)\n\t      for (var i = 0; i < last.length; ++i) {\n\t        var span = last[i];\n\t        if (span.to != null) span.to += offset;\n\t        if (span.from == null) {\n\t          var found = getMarkedSpanFor(first, span.marker);\n\t          if (!found) {\n\t            span.from = offset;\n\t            if (sameLine) (first || (first = [])).push(span);\n\t          }\n\t        } else {\n\t          span.from += offset;\n\t          if (sameLine) (first || (first = [])).push(span);\n\t        }\n\t      }\n\t    }\n\t    // Make sure we didn't create any zero-length spans\n\t    if (first) first = clearEmptySpans(first);\n\t    if (last && last != first) last = clearEmptySpans(last);\n\t\n\t    var newMarkers = [first];\n\t    if (!sameLine) {\n\t      // Fill gap with whole-line-spans\n\t      var gap = change.text.length - 2, gapMarkers;\n\t      if (gap > 0 && first)\n\t        for (var i = 0; i < first.length; ++i)\n\t          if (first[i].to == null)\n\t            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n\t      for (var i = 0; i < gap; ++i)\n\t        newMarkers.push(gapMarkers);\n\t      newMarkers.push(last);\n\t    }\n\t    return newMarkers;\n\t  }\n\t\n\t  // Remove spans that are empty and don't have a clearWhenEmpty\n\t  // option of false.\n\t  function clearEmptySpans(spans) {\n\t    for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n\t        spans.splice(i--, 1);\n\t    }\n\t    if (!spans.length) return null;\n\t    return spans;\n\t  }\n\t\n\t  // Used for un/re-doing changes from the history. Combines the\n\t  // result of computing the existing spans with the set of spans that\n\t  // existed in the history (so that deleting around a span and then\n\t  // undoing brings back the span).\n\t  function mergeOldSpans(doc, change) {\n\t    var old = getOldSpans(doc, change);\n\t    var stretched = stretchSpansOverChange(doc, change);\n\t    if (!old) return stretched;\n\t    if (!stretched) return old;\n\t\n\t    for (var i = 0; i < old.length; ++i) {\n\t      var oldCur = old[i], stretchCur = stretched[i];\n\t      if (oldCur && stretchCur) {\n\t        spans: for (var j = 0; j < stretchCur.length; ++j) {\n\t          var span = stretchCur[j];\n\t          for (var k = 0; k < oldCur.length; ++k)\n\t            if (oldCur[k].marker == span.marker) continue spans;\n\t          oldCur.push(span);\n\t        }\n\t      } else if (stretchCur) {\n\t        old[i] = stretchCur;\n\t      }\n\t    }\n\t    return old;\n\t  }\n\t\n\t  // Used to 'clip' out readOnly ranges when making a change.\n\t  function removeReadOnlyRanges(doc, from, to) {\n\t    var markers = null;\n\t    doc.iter(from.line, to.line + 1, function(line) {\n\t      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n\t        var mark = line.markedSpans[i].marker;\n\t        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n\t          (markers || (markers = [])).push(mark);\n\t      }\n\t    });\n\t    if (!markers) return null;\n\t    var parts = [{from: from, to: to}];\n\t    for (var i = 0; i < markers.length; ++i) {\n\t      var mk = markers[i], m = mk.find(0);\n\t      for (var j = 0; j < parts.length; ++j) {\n\t        var p = parts[j];\n\t        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n\t        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n\t        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n\t          newParts.push({from: p.from, to: m.from});\n\t        if (dto > 0 || !mk.inclusiveRight && !dto)\n\t          newParts.push({from: m.to, to: p.to});\n\t        parts.splice.apply(parts, newParts);\n\t        j += newParts.length - 1;\n\t      }\n\t    }\n\t    return parts;\n\t  }\n\t\n\t  // Connect or disconnect spans from a line.\n\t  function detachMarkedSpans(line) {\n\t    var spans = line.markedSpans;\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.detachLine(line);\n\t    line.markedSpans = null;\n\t  }\n\t  function attachMarkedSpans(line, spans) {\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.attachLine(line);\n\t    line.markedSpans = spans;\n\t  }\n\t\n\t  // Helpers used when computing which overlapping collapsed span\n\t  // counts as the larger one.\n\t  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n\t  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\t\n\t  // Returns a number indicating which of two overlapping collapsed\n\t  // spans is larger (and thus includes the other). Falls back to\n\t  // comparing ids when the spans cover exactly the same range.\n\t  function compareCollapsedMarkers(a, b) {\n\t    var lenDiff = a.lines.length - b.lines.length;\n\t    if (lenDiff != 0) return lenDiff;\n\t    var aPos = a.find(), bPos = b.find();\n\t    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n\t    if (fromCmp) return -fromCmp;\n\t    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n\t    if (toCmp) return toCmp;\n\t    return b.id - a.id;\n\t  }\n\t\n\t  // Find out whether a line ends or starts in a collapsed span. If\n\t  // so, return the marker for that span.\n\t  function collapsedSpanAtSide(line, start) {\n\t    var sps = sawCollapsedSpans && line.markedSpans, found;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n\t          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n\t        found = sp.marker;\n\t    }\n\t    return found;\n\t  }\n\t  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n\t  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\t\n\t  // Test whether there exists a collapsed span that partially\n\t  // overlaps (covers the start or end, but not both) of a new span.\n\t  // Such overlap is not allowed.\n\t  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n\t    var line = getLine(doc, lineNo);\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var i = 0; i < sps.length; ++i) {\n\t      var sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      var found = sp.marker.find(0);\n\t      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n\t      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n\t      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n\t      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\n\t          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // A visual line is a line as drawn on the screen. Folding, for\n\t  // example, can cause multiple logical lines to appear on the same\n\t  // visual line. This finds the start of the visual line that the\n\t  // given line is part of (usually that is the line itself).\n\t  function visualLine(line) {\n\t    var merged;\n\t    while (merged = collapsedSpanAtStart(line))\n\t      line = merged.find(-1, true).line;\n\t    return line;\n\t  }\n\t\n\t  // Returns an array of logical lines that continue the visual line\n\t  // started by the argument, or undefined if there are no such lines.\n\t  function visualLineContinued(line) {\n\t    var merged, lines;\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      (lines || (lines = [])).push(line);\n\t    }\n\t    return lines;\n\t  }\n\t\n\t  // Get the line number of the start of the visual line that the\n\t  // given line number is part of.\n\t  function visualLineNo(doc, lineN) {\n\t    var line = getLine(doc, lineN), vis = visualLine(line);\n\t    if (line == vis) return lineN;\n\t    return lineNo(vis);\n\t  }\n\t  // Get the line number of the start of the next visual line after\n\t  // the given line.\n\t  function visualLineEndNo(doc, lineN) {\n\t    if (lineN > doc.lastLine()) return lineN;\n\t    var line = getLine(doc, lineN), merged;\n\t    if (!lineIsHidden(doc, line)) return lineN;\n\t    while (merged = collapsedSpanAtEnd(line))\n\t      line = merged.find(1, true).line;\n\t    return lineNo(line) + 1;\n\t  }\n\t\n\t  // Compute whether a line is hidden. Lines count as hidden when they\n\t  // are part of a visual line that starts with another line, or when\n\t  // they are entirely covered by collapsed, non-widget span.\n\t  function lineIsHidden(doc, line) {\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      if (sp.from == null) return true;\n\t      if (sp.marker.widgetNode) continue;\n\t      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n\t        return true;\n\t    }\n\t  }\n\t  function lineIsHiddenInner(doc, line, span) {\n\t    if (span.to == null) {\n\t      var end = span.marker.find(1, true);\n\t      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n\t    }\n\t    if (span.marker.inclusiveRight && span.to == line.text.length)\n\t      return true;\n\t    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n\t      sp = line.markedSpans[i];\n\t      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n\t          (sp.to == null || sp.to != span.from) &&\n\t          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n\t          lineIsHiddenInner(doc, line, sp)) return true;\n\t    }\n\t  }\n\t\n\t  // LINE WIDGETS\n\t\n\t  // Line widgets are block elements displayed above or below a line.\n\t\n\t  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n\t    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n\t      this[opt] = options[opt];\n\t    this.doc = doc;\n\t    this.node = node;\n\t  };\n\t  eventMixin(LineWidget);\n\t\n\t  function adjustScrollWhenAboveVisible(cm, line, diff) {\n\t    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n\t      addToScrollPos(cm, null, diff);\n\t  }\n\t\n\t  LineWidget.prototype.clear = function() {\n\t    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n\t    if (no == null || !ws) return;\n\t    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n\t    if (!ws.length) line.widgets = null;\n\t    var height = widgetHeight(this);\n\t    updateLineHeight(line, Math.max(0, line.height - height));\n\t    if (cm) runInOp(cm, function() {\n\t      adjustScrollWhenAboveVisible(cm, line, -height);\n\t      regLineChange(cm, no, \"widget\");\n\t    });\n\t  };\n\t  LineWidget.prototype.changed = function() {\n\t    var oldH = this.height, cm = this.doc.cm, line = this.line;\n\t    this.height = null;\n\t    var diff = widgetHeight(this) - oldH;\n\t    if (!diff) return;\n\t    updateLineHeight(line, line.height + diff);\n\t    if (cm) runInOp(cm, function() {\n\t      cm.curOp.forceUpdate = true;\n\t      adjustScrollWhenAboveVisible(cm, line, diff);\n\t    });\n\t  };\n\t\n\t  function widgetHeight(widget) {\n\t    if (widget.height != null) return widget.height;\n\t    var cm = widget.doc.cm;\n\t    if (!cm) return 0;\n\t    if (!contains(document.body, widget.node)) {\n\t      var parentStyle = \"position: relative;\";\n\t      if (widget.coverGutter)\n\t        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n\t      if (widget.noHScroll)\n\t        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n\t      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n\t    }\n\t    return widget.height = widget.node.offsetHeight;\n\t  }\n\t\n\t  function addLineWidget(doc, handle, node, options) {\n\t    var widget = new LineWidget(doc, node, options);\n\t    var cm = doc.cm;\n\t    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n\t    changeLine(doc, handle, \"widget\", function(line) {\n\t      var widgets = line.widgets || (line.widgets = []);\n\t      if (widget.insertAt == null) widgets.push(widget);\n\t      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n\t      widget.line = line;\n\t      if (cm && !lineIsHidden(doc, line)) {\n\t        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n\t        updateLineHeight(line, line.height + widgetHeight(widget));\n\t        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n\t        cm.curOp.forceUpdate = true;\n\t      }\n\t      return true;\n\t    });\n\t    return widget;\n\t  }\n\t\n\t  // LINE DATA STRUCTURE\n\t\n\t  // Line objects. These hold state related to a line, including\n\t  // highlighting info (the styles array).\n\t  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n\t    this.text = text;\n\t    attachMarkedSpans(this, markedSpans);\n\t    this.height = estimateHeight ? estimateHeight(this) : 1;\n\t  };\n\t  eventMixin(Line);\n\t  Line.prototype.lineNo = function() { return lineNo(this); };\n\t\n\t  // Change the content (text, markers) of a line. Automatically\n\t  // invalidates cached information and tries to re-estimate the\n\t  // line's height.\n\t  function updateLine(line, text, markedSpans, estimateHeight) {\n\t    line.text = text;\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    if (line.styles) line.styles = null;\n\t    if (line.order != null) line.order = null;\n\t    detachMarkedSpans(line);\n\t    attachMarkedSpans(line, markedSpans);\n\t    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n\t    if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t  }\n\t\n\t  // Detach a line from the document tree and its markers.\n\t  function cleanUpLine(line) {\n\t    line.parent = null;\n\t    detachMarkedSpans(line);\n\t  }\n\t\n\t  function extractLineClasses(type, output) {\n\t    if (type) for (;;) {\n\t      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n\t      if (!lineClass) break;\n\t      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n\t      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n\t      if (output[prop] == null)\n\t        output[prop] = lineClass[2];\n\t      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n\t        output[prop] += \" \" + lineClass[2];\n\t    }\n\t    return type;\n\t  }\n\t\n\t  function callBlankLine(mode, state) {\n\t    if (mode.blankLine) return mode.blankLine(state);\n\t    if (!mode.innerMode) return;\n\t    var inner = CodeMirror.innerMode(mode, state);\n\t    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n\t  }\n\t\n\t  function readToken(mode, stream, state, inner) {\n\t    for (var i = 0; i < 10; i++) {\n\t      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n\t      var style = mode.token(stream, state);\n\t      if (stream.pos > stream.start) return style;\n\t    }\n\t    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n\t  }\n\t\n\t  // Utility for getTokenAt and getLineTokens\n\t  function takeToken(cm, pos, precise, asArray) {\n\t    function getObj(copy) {\n\t      return {start: stream.start, end: stream.pos,\n\t              string: stream.current(),\n\t              type: style || null,\n\t              state: copy ? copyState(doc.mode, state) : state};\n\t    }\n\t\n\t    var doc = cm.doc, mode = doc.mode, style;\n\t    pos = clipPos(doc, pos);\n\t    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n\t    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n\t    if (asArray) tokens = [];\n\t    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n\t      stream.start = stream.pos;\n\t      style = readToken(mode, stream, state);\n\t      if (asArray) tokens.push(getObj(true));\n\t    }\n\t    return asArray ? tokens : getObj();\n\t  }\n\t\n\t  // Run the given mode's parser over a line, calling f for each token.\n\t  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n\t    var flattenSpans = mode.flattenSpans;\n\t    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n\t    var curStart = 0, curStyle = null;\n\t    var stream = new StringStream(text, cm.options.tabSize), style;\n\t    var inner = cm.options.addModeClass && [null];\n\t    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n\t    while (!stream.eol()) {\n\t      if (stream.pos > cm.options.maxHighlightLength) {\n\t        flattenSpans = false;\n\t        if (forceToEnd) processLine(cm, text, state, stream.pos);\n\t        stream.pos = text.length;\n\t        style = null;\n\t      } else {\n\t        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n\t      }\n\t      if (inner) {\n\t        var mName = inner[0].name;\n\t        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n\t      }\n\t      if (!flattenSpans || curStyle != style) {\n\t        while (curStart < stream.start) {\n\t          curStart = Math.min(stream.start, curStart + 50000);\n\t          f(curStart, curStyle);\n\t        }\n\t        curStyle = style;\n\t      }\n\t      stream.start = stream.pos;\n\t    }\n\t    while (curStart < stream.pos) {\n\t      // Webkit seems to refuse to render text nodes longer than 57444 characters\n\t      var pos = Math.min(stream.pos, curStart + 50000);\n\t      f(pos, curStyle);\n\t      curStart = pos;\n\t    }\n\t  }\n\t\n\t  // Compute a style array (an array starting with a mode generation\n\t  // -- for invalidation -- followed by pairs of end positions and\n\t  // style strings), which is used to highlight the tokens on the\n\t  // line.\n\t  function highlightLine(cm, line, state, forceToEnd) {\n\t    // A styles array always starts with a number identifying the\n\t    // mode/overlays that it is based on (for easy invalidation).\n\t    var st = [cm.state.modeGen], lineClasses = {};\n\t    // Compute the base array of styles\n\t    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n\t      st.push(end, style);\n\t    }, lineClasses, forceToEnd);\n\t\n\t    // Run overlays, adjust style array.\n\t    for (var o = 0; o < cm.state.overlays.length; ++o) {\n\t      var overlay = cm.state.overlays[o], i = 1, at = 0;\n\t      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n\t        var start = i;\n\t        // Ensure there's a token end at the current position, and that i points at it\n\t        while (at < end) {\n\t          var i_end = st[i];\n\t          if (i_end > end)\n\t            st.splice(i, 1, end, st[i+1], i_end);\n\t          i += 2;\n\t          at = Math.min(end, i_end);\n\t        }\n\t        if (!style) return;\n\t        if (overlay.opaque) {\n\t          st.splice(start, i - start, end, \"cm-overlay \" + style);\n\t          i = start + 2;\n\t        } else {\n\t          for (; start < i; start += 2) {\n\t            var cur = st[start+1];\n\t            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n\t          }\n\t        }\n\t      }, lineClasses);\n\t    }\n\t\n\t    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n\t  }\n\t\n\t  function getLineStyles(cm, line, updateFrontier) {\n\t    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n\t      var state = getStateBefore(cm, lineNo(line));\n\t      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n\t      line.stateAfter = state;\n\t      line.styles = result.styles;\n\t      if (result.classes) line.styleClasses = result.classes;\n\t      else if (line.styleClasses) line.styleClasses = null;\n\t      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n\t    }\n\t    return line.styles;\n\t  }\n\t\n\t  // Lightweight form of highlight -- proceed over this line and\n\t  // update state, but don't save a style array. Used for lines that\n\t  // aren't currently visible.\n\t  function processLine(cm, text, state, startAt) {\n\t    var mode = cm.doc.mode;\n\t    var stream = new StringStream(text, cm.options.tabSize);\n\t    stream.start = stream.pos = startAt || 0;\n\t    if (text == \"\") callBlankLine(mode, state);\n\t    while (!stream.eol()) {\n\t      readToken(mode, stream, state);\n\t      stream.start = stream.pos;\n\t    }\n\t  }\n\t\n\t  // Convert a style as returned by a mode (either null, or a string\n\t  // containing one or more styles) to a CSS style. This is cached,\n\t  // and also looks for line-wide styles.\n\t  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n\t  function interpretTokenStyle(style, options) {\n\t    if (!style || /^\\s*$/.test(style)) return null;\n\t    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n\t    return cache[style] ||\n\t      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n\t  }\n\t\n\t  // Render the DOM representation of the text of a line. Also builds\n\t  // up a 'line map', which points at the DOM nodes that represent\n\t  // specific stretches of text, and is used by the measuring code.\n\t  // The returned object contains the DOM node, this map, and\n\t  // information about line-wide styles that were set by the mode.\n\t  function buildLineContent(cm, lineView) {\n\t    // The padding-right forces the element to have a 'border', which\n\t    // is needed on Webkit to be able to get line-level bounding\n\t    // rectangles for it (in measureChar).\n\t    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n\t    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n\t                   col: 0, pos: 0, cm: cm,\n\t                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n\t    lineView.measure = {};\n\t\n\t    // Iterate over the logical lines that make up this visual line.\n\t    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n\t      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n\t      builder.pos = 0;\n\t      builder.addToken = buildToken;\n\t      // Optionally wire in some hacks into the token-rendering\n\t      // algorithm, to deal with browser quirks.\n\t      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n\t        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n\t      builder.map = [];\n\t      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n\t      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n\t      if (line.styleClasses) {\n\t        if (line.styleClasses.bgClass)\n\t          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n\t        if (line.styleClasses.textClass)\n\t          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n\t      }\n\t\n\t      // Ensure at least a single node is present, for measuring.\n\t      if (builder.map.length == 0)\n\t        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\t\n\t      // Store the map and a cache object for the current logical line\n\t      if (i == 0) {\n\t        lineView.measure.map = builder.map;\n\t        lineView.measure.cache = {};\n\t      } else {\n\t        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n\t        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n\t      }\n\t    }\n\t\n\t    // See issue #2901\n\t    if (webkit && /\\bcm-tab\\b/.test(builder.content.lastChild.className))\n\t      builder.content.className = \"cm-tab-wrap-hack\";\n\t\n\t    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n\t    if (builder.pre.className)\n\t      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\t\n\t    return builder;\n\t  }\n\t\n\t  function defaultSpecialCharPlaceholder(ch) {\n\t    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n\t    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n\t    token.setAttribute(\"aria-label\", token.title);\n\t    return token;\n\t  }\n\t\n\t  // Build up the DOM representation for a single token, and add it to\n\t  // the line map. Takes care to render special characters separately.\n\t  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n\t    if (!text) return;\n\t    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;\n\t    var special = builder.cm.state.specialChars, mustWrap = false;\n\t    if (!special.test(text)) {\n\t      builder.col += text.length;\n\t      var content = document.createTextNode(displayText);\n\t      builder.map.push(builder.pos, builder.pos + text.length, content);\n\t      if (ie && ie_version < 9) mustWrap = true;\n\t      builder.pos += text.length;\n\t    } else {\n\t      var content = document.createDocumentFragment(), pos = 0;\n\t      while (true) {\n\t        special.lastIndex = pos;\n\t        var m = special.exec(text);\n\t        var skipped = m ? m.index - pos : text.length - pos;\n\t        if (skipped) {\n\t          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.map.push(builder.pos, builder.pos + skipped, txt);\n\t          builder.col += skipped;\n\t          builder.pos += skipped;\n\t        }\n\t        if (!m) break;\n\t        pos += skipped + 1;\n\t        if (m[0] == \"\\t\") {\n\t          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n\t          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n\t          txt.setAttribute(\"role\", \"presentation\");\n\t          txt.setAttribute(\"cm-text\", \"\\t\");\n\t          builder.col += tabWidth;\n\t        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n\t          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          builder.col += 1;\n\t        } else {\n\t          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.col += 1;\n\t        }\n\t        builder.map.push(builder.pos, builder.pos + 1, txt);\n\t        builder.pos++;\n\t      }\n\t    }\n\t    if (style || startStyle || endStyle || mustWrap || css) {\n\t      var fullStyle = style || \"\";\n\t      if (startStyle) fullStyle += startStyle;\n\t      if (endStyle) fullStyle += endStyle;\n\t      var token = elt(\"span\", [content], fullStyle, css);\n\t      if (title) token.title = title;\n\t      return builder.content.appendChild(token);\n\t    }\n\t    builder.content.appendChild(content);\n\t  }\n\t\n\t  function splitSpaces(old) {\n\t    var out = \" \";\n\t    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n\t    out += \" \";\n\t    return out;\n\t  }\n\t\n\t  // Work around nonsense dimensions being reported for stretches of\n\t  // right-to-left text.\n\t  function buildTokenBadBidi(inner, order) {\n\t    return function(builder, text, style, startStyle, endStyle, title, css) {\n\t      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n\t      var start = builder.pos, end = start + text.length;\n\t      for (;;) {\n\t        // Find the part that overlaps with the start of this text\n\t        for (var i = 0; i < order.length; i++) {\n\t          var part = order[i];\n\t          if (part.to > start && part.from <= start) break;\n\t        }\n\t        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n\t        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n\t        startStyle = null;\n\t        text = text.slice(part.to - start);\n\t        start = part.to;\n\t      }\n\t    };\n\t  }\n\t\n\t  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n\t    var widget = !ignoreWidget && marker.widgetNode;\n\t    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n\t    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n\t      if (!widget)\n\t        widget = builder.content.appendChild(document.createElement(\"span\"));\n\t      widget.setAttribute(\"cm-marker\", marker.id);\n\t    }\n\t    if (widget) {\n\t      builder.cm.display.input.setUneditable(widget);\n\t      builder.content.appendChild(widget);\n\t    }\n\t    builder.pos += size;\n\t  }\n\t\n\t  // Outputs a number of spans to make up a line, taking highlighting\n\t  // and marked text into account.\n\t  function insertLineContent(line, builder, styles) {\n\t    var spans = line.markedSpans, allText = line.text, at = 0;\n\t    if (!spans) {\n\t      for (var i = 1; i < styles.length; i+=2)\n\t        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n\t      return;\n\t    }\n\t\n\t    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n\t    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n\t    for (;;) {\n\t      if (nextChange == pos) { // Update current marker set\n\t        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n\t        collapsed = null; nextChange = Infinity;\n\t        var foundBookmarks = [];\n\t        for (var j = 0; j < spans.length; ++j) {\n\t          var sp = spans[j], m = sp.marker;\n\t          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n\t            foundBookmarks.push(m);\n\t          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n\t            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n\t              nextChange = sp.to;\n\t              spanEndStyle = \"\";\n\t            }\n\t            if (m.className) spanStyle += \" \" + m.className;\n\t            if (m.css) css = m.css;\n\t            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n\t            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\n\t            if (m.title && !title) title = m.title;\n\t            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n\t              collapsed = sp;\n\t          } else if (sp.from > pos && nextChange > sp.from) {\n\t            nextChange = sp.from;\n\t          }\n\t        }\n\t        if (collapsed && (collapsed.from || 0) == pos) {\n\t          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n\t                             collapsed.marker, collapsed.from == null);\n\t          if (collapsed.to == null) return;\n\t          if (collapsed.to == pos) collapsed = false;\n\t        }\n\t        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n\t          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n\t      }\n\t      if (pos >= len) break;\n\t\n\t      var upto = Math.min(len, nextChange);\n\t      while (true) {\n\t        if (text) {\n\t          var end = pos + text.length;\n\t          if (!collapsed) {\n\t            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n\t            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n\t                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n\t          }\n\t          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n\t          pos = end;\n\t          spanStartStyle = \"\";\n\t        }\n\t        text = allText.slice(at, at = styles[i++]);\n\t        style = interpretTokenStyle(styles[i++], builder.cm.options);\n\t      }\n\t    }\n\t  }\n\t\n\t  // DOCUMENT DATA STRUCTURE\n\t\n\t  // By default, updates that start and end at the beginning of a line\n\t  // are treated specially, in order to make the association of line\n\t  // widgets and marker elements with the text behave more intuitive.\n\t  function isWholeLineUpdate(doc, change) {\n\t    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n\t      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n\t  }\n\t\n\t  // Perform a change on the document data structure.\n\t  function updateDoc(doc, change, markedSpans, estimateHeight) {\n\t    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n\t    function update(line, text, spans) {\n\t      updateLine(line, text, spans, estimateHeight);\n\t      signalLater(line, \"change\", line, change);\n\t    }\n\t    function linesFor(start, end) {\n\t      for (var i = start, result = []; i < end; ++i)\n\t        result.push(new Line(text[i], spansFor(i), estimateHeight));\n\t      return result;\n\t    }\n\t\n\t    var from = change.from, to = change.to, text = change.text;\n\t    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n\t    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\t\n\t    // Adjust the line structure\n\t    if (change.full) {\n\t      doc.insert(0, linesFor(0, text.length));\n\t      doc.remove(text.length, doc.size - text.length);\n\t    } else if (isWholeLineUpdate(doc, change)) {\n\t      // This is a whole-line replace. Treated specially to make\n\t      // sure line objects move the way they are supposed to.\n\t      var added = linesFor(0, text.length - 1);\n\t      update(lastLine, lastLine.text, lastSpans);\n\t      if (nlines) doc.remove(from.line, nlines);\n\t      if (added.length) doc.insert(from.line, added);\n\t    } else if (firstLine == lastLine) {\n\t      if (text.length == 1) {\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n\t      } else {\n\t        var added = linesFor(1, text.length - 1);\n\t        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t        doc.insert(from.line + 1, added);\n\t      }\n\t    } else if (text.length == 1) {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n\t      doc.remove(from.line + 1, nlines);\n\t    } else {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n\t      var added = linesFor(1, text.length - 1);\n\t      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n\t      doc.insert(from.line + 1, added);\n\t    }\n\t\n\t    signalLater(doc, \"change\", doc, change);\n\t  }\n\t\n\t  // The document is represented as a BTree consisting of leaves, with\n\t  // chunk of lines in them, and branches, with up to ten leaves or\n\t  // other branch nodes below them. The top node is always a branch\n\t  // node, and is the document object itself (meaning it has\n\t  // additional methods and properties).\n\t  //\n\t  // All nodes have parent links. The tree is used both to go from\n\t  // line numbers to line objects, and to go from objects to numbers.\n\t  // It also indexes by height, and is used to convert between height\n\t  // and line object, and to find the total height of the document.\n\t  //\n\t  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\t\n\t  function LeafChunk(lines) {\n\t    this.lines = lines;\n\t    this.parent = null;\n\t    for (var i = 0, height = 0; i < lines.length; ++i) {\n\t      lines[i].parent = this;\n\t      height += lines[i].height;\n\t    }\n\t    this.height = height;\n\t  }\n\t\n\t  LeafChunk.prototype = {\n\t    chunkSize: function() { return this.lines.length; },\n\t    // Remove the n lines at offset 'at'.\n\t    removeInner: function(at, n) {\n\t      for (var i = at, e = at + n; i < e; ++i) {\n\t        var line = this.lines[i];\n\t        this.height -= line.height;\n\t        cleanUpLine(line);\n\t        signalLater(line, \"delete\");\n\t      }\n\t      this.lines.splice(at, n);\n\t    },\n\t    // Helper used to collapse a small branch into a single leaf.\n\t    collapse: function(lines) {\n\t      lines.push.apply(lines, this.lines);\n\t    },\n\t    // Insert the given array of lines at offset 'at', count them as\n\t    // having the given height.\n\t    insertInner: function(at, lines, height) {\n\t      this.height += height;\n\t      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n\t      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n\t    },\n\t    // Used to iterate over a part of the tree.\n\t    iterN: function(at, n, op) {\n\t      for (var e = at + n; at < e; ++at)\n\t        if (op(this.lines[at])) return true;\n\t    }\n\t  };\n\t\n\t  function BranchChunk(children) {\n\t    this.children = children;\n\t    var size = 0, height = 0;\n\t    for (var i = 0; i < children.length; ++i) {\n\t      var ch = children[i];\n\t      size += ch.chunkSize(); height += ch.height;\n\t      ch.parent = this;\n\t    }\n\t    this.size = size;\n\t    this.height = height;\n\t    this.parent = null;\n\t  }\n\t\n\t  BranchChunk.prototype = {\n\t    chunkSize: function() { return this.size; },\n\t    removeInner: function(at, n) {\n\t      this.size -= n;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var rm = Math.min(n, sz - at), oldHeight = child.height;\n\t          child.removeInner(at, rm);\n\t          this.height -= oldHeight - child.height;\n\t          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n\t          if ((n -= rm) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t      // If the result is smaller than 25 lines, ensure that it is a\n\t      // single leaf node.\n\t      if (this.size - n < 25 &&\n\t          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n\t        var lines = [];\n\t        this.collapse(lines);\n\t        this.children = [new LeafChunk(lines)];\n\t        this.children[0].parent = this;\n\t      }\n\t    },\n\t    collapse: function(lines) {\n\t      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n\t    },\n\t    insertInner: function(at, lines, height) {\n\t      this.size += lines.length;\n\t      this.height += height;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at <= sz) {\n\t          child.insertInner(at, lines, height);\n\t          if (child.lines && child.lines.length > 50) {\n\t            while (child.lines.length > 50) {\n\t              var spilled = child.lines.splice(child.lines.length - 25, 25);\n\t              var newleaf = new LeafChunk(spilled);\n\t              child.height -= newleaf.height;\n\t              this.children.splice(i + 1, 0, newleaf);\n\t              newleaf.parent = this;\n\t            }\n\t            this.maybeSpill();\n\t          }\n\t          break;\n\t        }\n\t        at -= sz;\n\t      }\n\t    },\n\t    // When a node has grown, check whether it should be split.\n\t    maybeSpill: function() {\n\t      if (this.children.length <= 10) return;\n\t      var me = this;\n\t      do {\n\t        var spilled = me.children.splice(me.children.length - 5, 5);\n\t        var sibling = new BranchChunk(spilled);\n\t        if (!me.parent) { // Become the parent node\n\t          var copy = new BranchChunk(me.children);\n\t          copy.parent = me;\n\t          me.children = [copy, sibling];\n\t          me = copy;\n\t        } else {\n\t          me.size -= sibling.size;\n\t          me.height -= sibling.height;\n\t          var myIndex = indexOf(me.parent.children, me);\n\t          me.parent.children.splice(myIndex + 1, 0, sibling);\n\t        }\n\t        sibling.parent = me.parent;\n\t      } while (me.children.length > 10);\n\t      me.parent.maybeSpill();\n\t    },\n\t    iterN: function(at, n, op) {\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var used = Math.min(n, sz - at);\n\t          if (child.iterN(at, used, op)) return true;\n\t          if ((n -= used) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t    }\n\t  };\n\t\n\t  var nextDocId = 0;\n\t  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n\t    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n\t    if (firstLine == null) firstLine = 0;\n\t\n\t    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n\t    this.first = firstLine;\n\t    this.scrollTop = this.scrollLeft = 0;\n\t    this.cantEdit = false;\n\t    this.cleanGeneration = 1;\n\t    this.frontier = firstLine;\n\t    var start = Pos(firstLine, 0);\n\t    this.sel = simpleSelection(start);\n\t    this.history = new History(null);\n\t    this.id = ++nextDocId;\n\t    this.modeOption = mode;\n\t    this.lineSep = lineSep;\n\t\n\t    if (typeof text == \"string\") text = this.splitLines(text);\n\t    updateDoc(this, {from: start, to: start, text: text});\n\t    setSelection(this, simpleSelection(start), sel_dontScroll);\n\t  };\n\t\n\t  Doc.prototype = createObj(BranchChunk.prototype, {\n\t    constructor: Doc,\n\t    // Iterate over the document. Supports two forms -- with only one\n\t    // argument, it calls that for each line in the document. With\n\t    // three, it iterates over the range given by the first two (with\n\t    // the second being non-inclusive).\n\t    iter: function(from, to, op) {\n\t      if (op) this.iterN(from - this.first, to - from, op);\n\t      else this.iterN(this.first, this.first + this.size, from);\n\t    },\n\t\n\t    // Non-public interface for adding and removing lines.\n\t    insert: function(at, lines) {\n\t      var height = 0;\n\t      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n\t      this.insertInner(at - this.first, lines, height);\n\t    },\n\t    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\t\n\t    // From here, the methods are part of the public interface. Most\n\t    // are also available from CodeMirror (editor) instances.\n\t\n\t    getValue: function(lineSep) {\n\t      var lines = getLines(this, this.first, this.first + this.size);\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    setValue: docMethodOp(function(code) {\n\t      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n\t      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n\t                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n\t      setSelection(this, simpleSelection(top));\n\t    }),\n\t    replaceRange: function(code, from, to, origin) {\n\t      from = clipPos(this, from);\n\t      to = to ? clipPos(this, to) : from;\n\t      replaceRange(this, code, from, to, origin);\n\t    },\n\t    getRange: function(from, to, lineSep) {\n\t      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t\n\t    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\t\n\t    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n\t    getLineNumber: function(line) {return lineNo(line);},\n\t\n\t    getLineHandleVisualStart: function(line) {\n\t      if (typeof line == \"number\") line = getLine(this, line);\n\t      return visualLine(line);\n\t    },\n\t\n\t    lineCount: function() {return this.size;},\n\t    firstLine: function() {return this.first;},\n\t    lastLine: function() {return this.first + this.size - 1;},\n\t\n\t    clipPos: function(pos) {return clipPos(this, pos);},\n\t\n\t    getCursor: function(start) {\n\t      var range = this.sel.primary(), pos;\n\t      if (start == null || start == \"head\") pos = range.head;\n\t      else if (start == \"anchor\") pos = range.anchor;\n\t      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n\t      else pos = range.from();\n\t      return pos;\n\t    },\n\t    listSelections: function() { return this.sel.ranges; },\n\t    somethingSelected: function() {return this.sel.somethingSelected();},\n\t\n\t    setCursor: docMethodOp(function(line, ch, options) {\n\t      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n\t    }),\n\t    setSelection: docMethodOp(function(anchor, head, options) {\n\t      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n\t    }),\n\t    extendSelection: docMethodOp(function(head, other, options) {\n\t      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n\t    }),\n\t    extendSelections: docMethodOp(function(heads, options) {\n\t      extendSelections(this, clipPosArray(this, heads, options));\n\t    }),\n\t    extendSelectionsBy: docMethodOp(function(f, options) {\n\t      extendSelections(this, map(this.sel.ranges, f), options);\n\t    }),\n\t    setSelections: docMethodOp(function(ranges, primary, options) {\n\t      if (!ranges.length) return;\n\t      for (var i = 0, out = []; i < ranges.length; i++)\n\t        out[i] = new Range(clipPos(this, ranges[i].anchor),\n\t                           clipPos(this, ranges[i].head));\n\t      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n\t      setSelection(this, normalizeSelection(out, primary), options);\n\t    }),\n\t    addSelection: docMethodOp(function(anchor, head, options) {\n\t      var ranges = this.sel.ranges.slice(0);\n\t      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n\t      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n\t    }),\n\t\n\t    getSelection: function(lineSep) {\n\t      var ranges = this.sel.ranges, lines;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        lines = lines ? lines.concat(sel) : sel;\n\t      }\n\t      if (lineSep === false) return lines;\n\t      else return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    getSelections: function(lineSep) {\n\t      var parts = [], ranges = this.sel.ranges;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n\t        parts[i] = sel;\n\t      }\n\t      return parts;\n\t    },\n\t    replaceSelection: function(code, collapse, origin) {\n\t      var dup = [];\n\t      for (var i = 0; i < this.sel.ranges.length; i++)\n\t        dup[i] = code;\n\t      this.replaceSelections(dup, collapse, origin || \"+input\");\n\t    },\n\t    replaceSelections: docMethodOp(function(code, collapse, origin) {\n\t      var changes = [], sel = this.sel;\n\t      for (var i = 0; i < sel.ranges.length; i++) {\n\t        var range = sel.ranges[i];\n\t        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n\t      }\n\t      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n\t      for (var i = changes.length - 1; i >= 0; i--)\n\t        makeChange(this, changes[i]);\n\t      if (newSel) setSelectionReplaceHistory(this, newSel);\n\t      else if (this.cm) ensureCursorVisible(this.cm);\n\t    }),\n\t    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n\t    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n\t    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n\t    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\t\n\t    setExtending: function(val) {this.extend = val;},\n\t    getExtending: function() {return this.extend;},\n\t\n\t    historySize: function() {\n\t      var hist = this.history, done = 0, undone = 0;\n\t      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n\t      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n\t      return {undo: done, redo: undone};\n\t    },\n\t    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\t\n\t    markClean: function() {\n\t      this.cleanGeneration = this.changeGeneration(true);\n\t    },\n\t    changeGeneration: function(forceSplit) {\n\t      if (forceSplit)\n\t        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n\t      return this.history.generation;\n\t    },\n\t    isClean: function (gen) {\n\t      return this.history.generation == (gen || this.cleanGeneration);\n\t    },\n\t\n\t    getHistory: function() {\n\t      return {done: copyHistoryArray(this.history.done),\n\t              undone: copyHistoryArray(this.history.undone)};\n\t    },\n\t    setHistory: function(histData) {\n\t      var hist = this.history = new History(this.history.maxGeneration);\n\t      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n\t      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n\t    },\n\t\n\t    addLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        if (!line[prop]) line[prop] = cls;\n\t        else if (classTest(cls).test(line[prop])) return false;\n\t        else line[prop] += \" \" + cls;\n\t        return true;\n\t      });\n\t    }),\n\t    removeLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        var cur = line[prop];\n\t        if (!cur) return false;\n\t        else if (cls == null) line[prop] = null;\n\t        else {\n\t          var found = cur.match(classTest(cls));\n\t          if (!found) return false;\n\t          var end = found.index + found[0].length;\n\t          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n\t        }\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    addLineWidget: docMethodOp(function(handle, node, options) {\n\t      return addLineWidget(this, handle, node, options);\n\t    }),\n\t    removeLineWidget: function(widget) { widget.clear(); },\n\t\n\t    markText: function(from, to, options) {\n\t      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n\t    },\n\t    setBookmark: function(pos, options) {\n\t      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n\t                      insertLeft: options && options.insertLeft,\n\t                      clearWhenEmpty: false, shared: options && options.shared,\n\t                      handleMouseEvents: options && options.handleMouseEvents};\n\t      pos = clipPos(this, pos);\n\t      return markText(this, pos, pos, realOpts, \"bookmark\");\n\t    },\n\t    findMarksAt: function(pos) {\n\t      pos = clipPos(this, pos);\n\t      var markers = [], spans = getLine(this, pos.line).markedSpans;\n\t      if (spans) for (var i = 0; i < spans.length; ++i) {\n\t        var span = spans[i];\n\t        if ((span.from == null || span.from <= pos.ch) &&\n\t            (span.to == null || span.to >= pos.ch))\n\t          markers.push(span.marker.parent || span.marker);\n\t      }\n\t      return markers;\n\t    },\n\t    findMarks: function(from, to, filter) {\n\t      from = clipPos(this, from); to = clipPos(this, to);\n\t      var found = [], lineNo = from.line;\n\t      this.iter(from.line, to.line + 1, function(line) {\n\t        var spans = line.markedSpans;\n\t        if (spans) for (var i = 0; i < spans.length; i++) {\n\t          var span = spans[i];\n\t          if (!(lineNo == from.line && from.ch > span.to ||\n\t                span.from == null && lineNo != from.line||\n\t                lineNo == to.line && span.from > to.ch) &&\n\t              (!filter || filter(span.marker)))\n\t            found.push(span.marker.parent || span.marker);\n\t        }\n\t        ++lineNo;\n\t      });\n\t      return found;\n\t    },\n\t    getAllMarks: function() {\n\t      var markers = [];\n\t      this.iter(function(line) {\n\t        var sps = line.markedSpans;\n\t        if (sps) for (var i = 0; i < sps.length; ++i)\n\t          if (sps[i].from != null) markers.push(sps[i].marker);\n\t      });\n\t      return markers;\n\t    },\n\t\n\t    posFromIndex: function(off) {\n\t      var ch, lineNo = this.first;\n\t      this.iter(function(line) {\n\t        var sz = line.text.length + 1;\n\t        if (sz > off) { ch = off; return true; }\n\t        off -= sz;\n\t        ++lineNo;\n\t      });\n\t      return clipPos(this, Pos(lineNo, ch));\n\t    },\n\t    indexFromPos: function (coords) {\n\t      coords = clipPos(this, coords);\n\t      var index = coords.ch;\n\t      if (coords.line < this.first || coords.ch < 0) return 0;\n\t      this.iter(this.first, coords.line, function (line) {\n\t        index += line.text.length + 1;\n\t      });\n\t      return index;\n\t    },\n\t\n\t    copy: function(copyHistory) {\n\t      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n\t                        this.modeOption, this.first, this.lineSep);\n\t      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n\t      doc.sel = this.sel;\n\t      doc.extend = false;\n\t      if (copyHistory) {\n\t        doc.history.undoDepth = this.history.undoDepth;\n\t        doc.setHistory(this.getHistory());\n\t      }\n\t      return doc;\n\t    },\n\t\n\t    linkedDoc: function(options) {\n\t      if (!options) options = {};\n\t      var from = this.first, to = this.first + this.size;\n\t      if (options.from != null && options.from > from) from = options.from;\n\t      if (options.to != null && options.to < to) to = options.to;\n\t      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n\t      if (options.sharedHist) copy.history = this.history;\n\t      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n\t      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n\t      copySharedMarkers(copy, findSharedMarkers(this));\n\t      return copy;\n\t    },\n\t    unlinkDoc: function(other) {\n\t      if (other instanceof CodeMirror) other = other.doc;\n\t      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n\t        var link = this.linked[i];\n\t        if (link.doc != other) continue;\n\t        this.linked.splice(i, 1);\n\t        other.unlinkDoc(this);\n\t        detachSharedMarkers(findSharedMarkers(this));\n\t        break;\n\t      }\n\t      // If the histories were shared, split them again\n\t      if (other.history == this.history) {\n\t        var splitIds = [other.id];\n\t        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n\t        other.history = new History(null);\n\t        other.history.done = copyHistoryArray(this.history.done, splitIds);\n\t        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n\t      }\n\t    },\n\t    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\t\n\t    getMode: function() {return this.mode;},\n\t    getEditor: function() {return this.cm;},\n\t\n\t    splitLines: function(str) {\n\t      if (this.lineSep) return str.split(this.lineSep);\n\t      return splitLinesAuto(str);\n\t    },\n\t    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n\t  });\n\t\n\t  // Public alias.\n\t  Doc.prototype.eachLine = Doc.prototype.iter;\n\t\n\t  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n\t  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n\t  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n\t    CodeMirror.prototype[prop] = (function(method) {\n\t      return function() {return method.apply(this.doc, arguments);};\n\t    })(Doc.prototype[prop]);\n\t\n\t  eventMixin(Doc);\n\t\n\t  // Call f for all linked documents.\n\t  function linkedDocs(doc, f, sharedHistOnly) {\n\t    function propagate(doc, skip, sharedHist) {\n\t      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n\t        var rel = doc.linked[i];\n\t        if (rel.doc == skip) continue;\n\t        var shared = sharedHist && rel.sharedHist;\n\t        if (sharedHistOnly && !shared) continue;\n\t        f(rel.doc, shared);\n\t        propagate(rel.doc, doc, shared);\n\t      }\n\t    }\n\t    propagate(doc, null, true);\n\t  }\n\t\n\t  // Attach a document to an editor.\n\t  function attachDoc(cm, doc) {\n\t    if (doc.cm) throw new Error(\"This document is already in use.\");\n\t    cm.doc = doc;\n\t    doc.cm = cm;\n\t    estimateLineHeights(cm);\n\t    loadMode(cm);\n\t    if (!cm.options.lineWrapping) findMaxLine(cm);\n\t    cm.options.mode = doc.modeOption;\n\t    regChange(cm);\n\t  }\n\t\n\t  // LINE UTILITIES\n\t\n\t  // Find the line object corresponding to the given line number.\n\t  function getLine(doc, n) {\n\t    n -= doc.first;\n\t    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n\t    for (var chunk = doc; !chunk.lines;) {\n\t      for (var i = 0;; ++i) {\n\t        var child = chunk.children[i], sz = child.chunkSize();\n\t        if (n < sz) { chunk = child; break; }\n\t        n -= sz;\n\t      }\n\t    }\n\t    return chunk.lines[n];\n\t  }\n\t\n\t  // Get the part of a document between two positions, as an array of\n\t  // strings.\n\t  function getBetween(doc, start, end) {\n\t    var out = [], n = start.line;\n\t    doc.iter(start.line, end.line + 1, function(line) {\n\t      var text = line.text;\n\t      if (n == end.line) text = text.slice(0, end.ch);\n\t      if (n == start.line) text = text.slice(start.ch);\n\t      out.push(text);\n\t      ++n;\n\t    });\n\t    return out;\n\t  }\n\t  // Get the lines between from and to, as array of strings.\n\t  function getLines(doc, from, to) {\n\t    var out = [];\n\t    doc.iter(from, to, function(line) { out.push(line.text); });\n\t    return out;\n\t  }\n\t\n\t  // Update the height of a line, propagating the height change\n\t  // upwards to parent nodes.\n\t  function updateLineHeight(line, height) {\n\t    var diff = height - line.height;\n\t    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n\t  }\n\t\n\t  // Given a line object, find its line number by walking up through\n\t  // its parent links.\n\t  function lineNo(line) {\n\t    if (line.parent == null) return null;\n\t    var cur = line.parent, no = indexOf(cur.lines, line);\n\t    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n\t      for (var i = 0;; ++i) {\n\t        if (chunk.children[i] == cur) break;\n\t        no += chunk.children[i].chunkSize();\n\t      }\n\t    }\n\t    return no + cur.first;\n\t  }\n\t\n\t  // Find the line at the given vertical position, using the height\n\t  // information in the document tree.\n\t  function lineAtHeight(chunk, h) {\n\t    var n = chunk.first;\n\t    outer: do {\n\t      for (var i = 0; i < chunk.children.length; ++i) {\n\t        var child = chunk.children[i], ch = child.height;\n\t        if (h < ch) { chunk = child; continue outer; }\n\t        h -= ch;\n\t        n += child.chunkSize();\n\t      }\n\t      return n;\n\t    } while (!chunk.lines);\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i], lh = line.height;\n\t      if (h < lh) break;\n\t      h -= lh;\n\t    }\n\t    return n + i;\n\t  }\n\t\n\t\n\t  // Find the height above the given line.\n\t  function heightAtLine(lineObj) {\n\t    lineObj = visualLine(lineObj);\n\t\n\t    var h = 0, chunk = lineObj.parent;\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i];\n\t      if (line == lineObj) break;\n\t      else h += line.height;\n\t    }\n\t    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n\t      for (var i = 0; i < p.children.length; ++i) {\n\t        var cur = p.children[i];\n\t        if (cur == chunk) break;\n\t        else h += cur.height;\n\t      }\n\t    }\n\t    return h;\n\t  }\n\t\n\t  // Get the bidi ordering for the given line (and cache it). Returns\n\t  // false for lines that are fully left-to-right, and an array of\n\t  // BidiSpan objects otherwise.\n\t  function getOrder(line) {\n\t    var order = line.order;\n\t    if (order == null) order = line.order = bidiOrdering(line.text);\n\t    return order;\n\t  }\n\t\n\t  // HISTORY\n\t\n\t  function History(startGen) {\n\t    // Arrays of change events and selections. Doing something adds an\n\t    // event to done and clears undo. Undoing moves events from done\n\t    // to undone, redoing moves them in the other direction.\n\t    this.done = []; this.undone = [];\n\t    this.undoDepth = Infinity;\n\t    // Used to track when changes can be merged into a single undo\n\t    // event\n\t    this.lastModTime = this.lastSelTime = 0;\n\t    this.lastOp = this.lastSelOp = null;\n\t    this.lastOrigin = this.lastSelOrigin = null;\n\t    // Used by the isClean() method\n\t    this.generation = this.maxGeneration = startGen || 1;\n\t  }\n\t\n\t  // Create a history change event from an updateDoc-style change\n\t  // object.\n\t  function historyChangeFromChange(doc, change) {\n\t    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n\t    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n\t    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n\t    return histChange;\n\t  }\n\t\n\t  // Pop all selection events off the end of a history array. Stop at\n\t  // a change event.\n\t  function clearSelectionEvents(array) {\n\t    while (array.length) {\n\t      var last = lst(array);\n\t      if (last.ranges) array.pop();\n\t      else break;\n\t    }\n\t  }\n\t\n\t  // Find the top change event in the history. Pop off selection\n\t  // events that are in the way.\n\t  function lastChangeEvent(hist, force) {\n\t    if (force) {\n\t      clearSelectionEvents(hist.done);\n\t      return lst(hist.done);\n\t    } else if (hist.done.length && !lst(hist.done).ranges) {\n\t      return lst(hist.done);\n\t    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n\t      hist.done.pop();\n\t      return lst(hist.done);\n\t    }\n\t  }\n\t\n\t  // Register a change in the history. Merges changes that are within\n\t  // a single operation, ore are close together with an origin that\n\t  // allows merging (starting with \"+\") into a single event.\n\t  function addChangeToHistory(doc, change, selAfter, opId) {\n\t    var hist = doc.history;\n\t    hist.undone.length = 0;\n\t    var time = +new Date, cur;\n\t\n\t    if ((hist.lastOp == opId ||\n\t         hist.lastOrigin == change.origin && change.origin &&\n\t         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n\t          change.origin.charAt(0) == \"*\")) &&\n\t        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n\t      // Merge this change into the last event\n\t      var last = lst(cur.changes);\n\t      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n\t        // Optimized case for simple insertion -- don't want to add\n\t        // new changesets for every character typed\n\t        last.to = changeEnd(change);\n\t      } else {\n\t        // Add new sub-event\n\t        cur.changes.push(historyChangeFromChange(doc, change));\n\t      }\n\t    } else {\n\t      // Can not be merged, start a new event.\n\t      var before = lst(hist.done);\n\t      if (!before || !before.ranges)\n\t        pushSelectionToHistory(doc.sel, hist.done);\n\t      cur = {changes: [historyChangeFromChange(doc, change)],\n\t             generation: hist.generation};\n\t      hist.done.push(cur);\n\t      while (hist.done.length > hist.undoDepth) {\n\t        hist.done.shift();\n\t        if (!hist.done[0].ranges) hist.done.shift();\n\t      }\n\t    }\n\t    hist.done.push(selAfter);\n\t    hist.generation = ++hist.maxGeneration;\n\t    hist.lastModTime = hist.lastSelTime = time;\n\t    hist.lastOp = hist.lastSelOp = opId;\n\t    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\t\n\t    if (!last) signal(doc, \"historyAdded\");\n\t  }\n\t\n\t  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n\t    var ch = origin.charAt(0);\n\t    return ch == \"*\" ||\n\t      ch == \"+\" &&\n\t      prev.ranges.length == sel.ranges.length &&\n\t      prev.somethingSelected() == sel.somethingSelected() &&\n\t      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n\t  }\n\t\n\t  // Called whenever the selection changes, sets the new selection as\n\t  // the pending selection in the history, and pushes the old pending\n\t  // selection into the 'done' array when it was significantly\n\t  // different (in number of selected ranges, emptiness, or time).\n\t  function addSelectionToHistory(doc, sel, opId, options) {\n\t    var hist = doc.history, origin = options && options.origin;\n\t\n\t    // A new event is started when the previous origin does not match\n\t    // the current, or the origins don't allow matching. Origins\n\t    // starting with * are always merged, those starting with + are\n\t    // merged when similar and close together in time.\n\t    if (opId == hist.lastSelOp ||\n\t        (origin && hist.lastSelOrigin == origin &&\n\t         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n\t          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n\t      hist.done[hist.done.length - 1] = sel;\n\t    else\n\t      pushSelectionToHistory(sel, hist.done);\n\t\n\t    hist.lastSelTime = +new Date;\n\t    hist.lastSelOrigin = origin;\n\t    hist.lastSelOp = opId;\n\t    if (options && options.clearRedo !== false)\n\t      clearSelectionEvents(hist.undone);\n\t  }\n\t\n\t  function pushSelectionToHistory(sel, dest) {\n\t    var top = lst(dest);\n\t    if (!(top && top.ranges && top.equals(sel)))\n\t      dest.push(sel);\n\t  }\n\t\n\t  // Used to store marked span information in the history.\n\t  function attachLocalSpans(doc, change, from, to) {\n\t    var existing = change[\"spans_\" + doc.id], n = 0;\n\t    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n\t      if (line.markedSpans)\n\t        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n\t      ++n;\n\t    });\n\t  }\n\t\n\t  // When un/re-doing restores text containing marked spans, those\n\t  // that have been explicitly cleared should not be restored.\n\t  function removeClearedSpans(spans) {\n\t    if (!spans) return null;\n\t    for (var i = 0, out; i < spans.length; ++i) {\n\t      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n\t      else if (out) out.push(spans[i]);\n\t    }\n\t    return !out ? spans : out.length ? out : null;\n\t  }\n\t\n\t  // Retrieve and filter the old marked spans stored in a change event.\n\t  function getOldSpans(doc, change) {\n\t    var found = change[\"spans_\" + doc.id];\n\t    if (!found) return null;\n\t    for (var i = 0, nw = []; i < change.text.length; ++i)\n\t      nw.push(removeClearedSpans(found[i]));\n\t    return nw;\n\t  }\n\t\n\t  // Used both to provide a JSON-safe object in .getHistory, and, when\n\t  // detaching a document, to split the history in two\n\t  function copyHistoryArray(events, newGroup, instantiateSel) {\n\t    for (var i = 0, copy = []; i < events.length; ++i) {\n\t      var event = events[i];\n\t      if (event.ranges) {\n\t        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n\t        continue;\n\t      }\n\t      var changes = event.changes, newChanges = [];\n\t      copy.push({changes: newChanges});\n\t      for (var j = 0; j < changes.length; ++j) {\n\t        var change = changes[j], m;\n\t        newChanges.push({from: change.from, to: change.to, text: change.text});\n\t        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n\t          if (indexOf(newGroup, Number(m[1])) > -1) {\n\t            lst(newChanges)[prop] = change[prop];\n\t            delete change[prop];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return copy;\n\t  }\n\t\n\t  // Rebasing/resetting history to deal with externally-sourced changes\n\t\n\t  function rebaseHistSelSingle(pos, from, to, diff) {\n\t    if (to < pos.line) {\n\t      pos.line += diff;\n\t    } else if (from < pos.line) {\n\t      pos.line = from;\n\t      pos.ch = 0;\n\t    }\n\t  }\n\t\n\t  // Tries to rebase an array of history events given a change in the\n\t  // document. If the change touches the same lines as the event, the\n\t  // event, and everything 'behind' it, is discarded. If the change is\n\t  // before the event, the event's positions are updated. Uses a\n\t  // copy-on-write scheme for the positions, to avoid having to\n\t  // reallocate them all on every rebase, but also avoid problems with\n\t  // shared position objects being unsafely updated.\n\t  function rebaseHistArray(array, from, to, diff) {\n\t    for (var i = 0; i < array.length; ++i) {\n\t      var sub = array[i], ok = true;\n\t      if (sub.ranges) {\n\t        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n\t        for (var j = 0; j < sub.ranges.length; j++) {\n\t          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n\t          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n\t        }\n\t        continue;\n\t      }\n\t      for (var j = 0; j < sub.changes.length; ++j) {\n\t        var cur = sub.changes[j];\n\t        if (to < cur.from.line) {\n\t          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n\t          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n\t        } else if (from <= cur.to.line) {\n\t          ok = false;\n\t          break;\n\t        }\n\t      }\n\t      if (!ok) {\n\t        array.splice(0, i + 1);\n\t        i = 0;\n\t      }\n\t    }\n\t  }\n\t\n\t  function rebaseHist(hist, change) {\n\t    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n\t    rebaseHistArray(hist.done, from, to, diff);\n\t    rebaseHistArray(hist.undone, from, to, diff);\n\t  }\n\t\n\t  // EVENT UTILITIES\n\t\n\t  // Due to the fact that we still support jurassic IE versions, some\n\t  // compatibility wrappers are needed.\n\t\n\t  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n\t    if (e.preventDefault) e.preventDefault();\n\t    else e.returnValue = false;\n\t  };\n\t  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n\t    if (e.stopPropagation) e.stopPropagation();\n\t    else e.cancelBubble = true;\n\t  };\n\t  function e_defaultPrevented(e) {\n\t    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n\t  }\n\t  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\t\n\t  function e_target(e) {return e.target || e.srcElement;}\n\t  function e_button(e) {\n\t    var b = e.which;\n\t    if (b == null) {\n\t      if (e.button & 1) b = 1;\n\t      else if (e.button & 2) b = 3;\n\t      else if (e.button & 4) b = 2;\n\t    }\n\t    if (mac && e.ctrlKey && b == 1) b = 3;\n\t    return b;\n\t  }\n\t\n\t  // EVENT HANDLING\n\t\n\t  // Lightweight event framework. on/off also work on DOM nodes,\n\t  // registering native DOM handlers.\n\t\n\t  var on = CodeMirror.on = function(emitter, type, f) {\n\t    if (emitter.addEventListener)\n\t      emitter.addEventListener(type, f, false);\n\t    else if (emitter.attachEvent)\n\t      emitter.attachEvent(\"on\" + type, f);\n\t    else {\n\t      var map = emitter._handlers || (emitter._handlers = {});\n\t      var arr = map[type] || (map[type] = []);\n\t      arr.push(f);\n\t    }\n\t  };\n\t\n\t  var noHandlers = []\n\t  function getHandlers(emitter, type, copy) {\n\t    var arr = emitter._handlers && emitter._handlers[type]\n\t    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n\t    else return arr || noHandlers\n\t  }\n\t\n\t  var off = CodeMirror.off = function(emitter, type, f) {\n\t    if (emitter.removeEventListener)\n\t      emitter.removeEventListener(type, f, false);\n\t    else if (emitter.detachEvent)\n\t      emitter.detachEvent(\"on\" + type, f);\n\t    else {\n\t      var handlers = getHandlers(emitter, type, false)\n\t      for (var i = 0; i < handlers.length; ++i)\n\t        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n\t    }\n\t  };\n\t\n\t  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n\t    var handlers = getHandlers(emitter, type, true)\n\t    if (!handlers.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2);\n\t    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n\t  };\n\t\n\t  var orphanDelayedCallbacks = null;\n\t\n\t  // Often, we want to signal events at a point where we are in the\n\t  // middle of some work, but don't want the handler to start calling\n\t  // other methods on the editor, which might be in an inconsistent\n\t  // state or simply not expect any other events to happen.\n\t  // signalLater looks whether there are any handlers, and schedules\n\t  // them to be executed when the last operation ends, or, if no\n\t  // operation is active, when a timeout fires.\n\t  function signalLater(emitter, type /*, values...*/) {\n\t    var arr = getHandlers(emitter, type, false)\n\t    if (!arr.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2), list;\n\t    if (operationGroup) {\n\t      list = operationGroup.delayedCallbacks;\n\t    } else if (orphanDelayedCallbacks) {\n\t      list = orphanDelayedCallbacks;\n\t    } else {\n\t      list = orphanDelayedCallbacks = [];\n\t      setTimeout(fireOrphanDelayed, 0);\n\t    }\n\t    function bnd(f) {return function(){f.apply(null, args);};};\n\t    for (var i = 0; i < arr.length; ++i)\n\t      list.push(bnd(arr[i]));\n\t  }\n\t\n\t  function fireOrphanDelayed() {\n\t    var delayed = orphanDelayedCallbacks;\n\t    orphanDelayedCallbacks = null;\n\t    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n\t  }\n\t\n\t  // The DOM events that CodeMirror handles can be overridden by\n\t  // registering a (non-DOM) handler on the editor for the event name,\n\t  // and preventDefault-ing the event in that handler.\n\t  function signalDOMEvent(cm, e, override) {\n\t    if (typeof e == \"string\")\n\t      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n\t    signal(cm, override || e.type, cm, e);\n\t    return e_defaultPrevented(e) || e.codemirrorIgnore;\n\t  }\n\t\n\t  function signalCursorActivity(cm) {\n\t    var arr = cm._handlers && cm._handlers.cursorActivity;\n\t    if (!arr) return;\n\t    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n\t    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n\t      set.push(arr[i]);\n\t  }\n\t\n\t  function hasHandler(emitter, type) {\n\t    return getHandlers(emitter, type).length > 0\n\t  }\n\t\n\t  // Add on and off methods to a constructor's prototype, to make\n\t  // registering events on such objects more convenient.\n\t  function eventMixin(ctor) {\n\t    ctor.prototype.on = function(type, f) {on(this, type, f);};\n\t    ctor.prototype.off = function(type, f) {off(this, type, f);};\n\t  }\n\t\n\t  // MISC UTILITIES\n\t\n\t  // Number of pixels added to scroller and sizer to hide scrollbar\n\t  var scrollerGap = 30;\n\t\n\t  // Returned or thrown by various protocols to signal 'I'm not\n\t  // handling this'.\n\t  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\t\n\t  // Reused option objects for setSelection & friends\n\t  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\t\n\t  function Delayed() {this.id = null;}\n\t  Delayed.prototype.set = function(ms, f) {\n\t    clearTimeout(this.id);\n\t    this.id = setTimeout(f, ms);\n\t  };\n\t\n\t  // Counts the column offset in a string, taking tabs into account.\n\t  // Used mostly to find indentation.\n\t  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n\t    if (end == null) {\n\t      end = string.search(/[^\\s\\u00a0]/);\n\t      if (end == -1) end = string.length;\n\t    }\n\t    for (var i = startIndex || 0, n = startValue || 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", i);\n\t      if (nextTab < 0 || nextTab >= end)\n\t        return n + (end - i);\n\t      n += nextTab - i;\n\t      n += tabSize - (n % tabSize);\n\t      i = nextTab + 1;\n\t    }\n\t  };\n\t\n\t  // The inverse of countColumn -- find the offset that corresponds to\n\t  // a particular column.\n\t  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n\t    for (var pos = 0, col = 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", pos);\n\t      if (nextTab == -1) nextTab = string.length;\n\t      var skipped = nextTab - pos;\n\t      if (nextTab == string.length || col + skipped >= goal)\n\t        return pos + Math.min(skipped, goal - col);\n\t      col += nextTab - pos;\n\t      col += tabSize - (col % tabSize);\n\t      pos = nextTab + 1;\n\t      if (col >= goal) return pos;\n\t    }\n\t  }\n\t\n\t  var spaceStrs = [\"\"];\n\t  function spaceStr(n) {\n\t    while (spaceStrs.length <= n)\n\t      spaceStrs.push(lst(spaceStrs) + \" \");\n\t    return spaceStrs[n];\n\t  }\n\t\n\t  function lst(arr) { return arr[arr.length-1]; }\n\t\n\t  var selectInput = function(node) { node.select(); };\n\t  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n\t    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n\t  else if (ie) // Suppress mysterious IE10 errors\n\t    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\t\n\t  function indexOf(array, elt) {\n\t    for (var i = 0; i < array.length; ++i)\n\t      if (array[i] == elt) return i;\n\t    return -1;\n\t  }\n\t  function map(array, f) {\n\t    var out = [];\n\t    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n\t    return out;\n\t  }\n\t\n\t  function nothing() {}\n\t\n\t  function createObj(base, props) {\n\t    var inst;\n\t    if (Object.create) {\n\t      inst = Object.create(base);\n\t    } else {\n\t      nothing.prototype = base;\n\t      inst = new nothing();\n\t    }\n\t    if (props) copyObj(props, inst);\n\t    return inst;\n\t  };\n\t\n\t  function copyObj(obj, target, overwrite) {\n\t    if (!target) target = {};\n\t    for (var prop in obj)\n\t      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n\t        target[prop] = obj[prop];\n\t    return target;\n\t  }\n\t\n\t  function bind(f) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    return function(){return f.apply(null, args);};\n\t  }\n\t\n\t  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\t  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n\t    return /\\w/.test(ch) || ch > \"\\x80\" &&\n\t      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n\t  };\n\t  function isWordChar(ch, helper) {\n\t    if (!helper) return isWordCharBasic(ch);\n\t    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n\t    return helper.test(ch);\n\t  }\n\t\n\t  function isEmpty(obj) {\n\t    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n\t    return true;\n\t  }\n\t\n\t  // Extending unicode characters. A series of a non-extending char +\n\t  // any number of extending chars is treated as a single unit as far\n\t  // as editing and measuring is concerned. This is not fully correct,\n\t  // since some scripts/fonts/browsers also treat other configurations\n\t  // of code points as a group.\n\t  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n\t  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\t\n\t  // DOM UTILITIES\n\t\n\t  function elt(tag, content, className, style) {\n\t    var e = document.createElement(tag);\n\t    if (className) e.className = className;\n\t    if (style) e.style.cssText = style;\n\t    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n\t    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n\t    return e;\n\t  }\n\t\n\t  var range;\n\t  if (document.createRange) range = function(node, start, end, endNode) {\n\t    var r = document.createRange();\n\t    r.setEnd(endNode || node, end);\n\t    r.setStart(node, start);\n\t    return r;\n\t  };\n\t  else range = function(node, start, end) {\n\t    var r = document.body.createTextRange();\n\t    try { r.moveToElementText(node.parentNode); }\n\t    catch(e) { return r; }\n\t    r.collapse(true);\n\t    r.moveEnd(\"character\", end);\n\t    r.moveStart(\"character\", start);\n\t    return r;\n\t  };\n\t\n\t  function removeChildren(e) {\n\t    for (var count = e.childNodes.length; count > 0; --count)\n\t      e.removeChild(e.firstChild);\n\t    return e;\n\t  }\n\t\n\t  function removeChildrenAndAdd(parent, e) {\n\t    return removeChildren(parent).appendChild(e);\n\t  }\n\t\n\t  var contains = CodeMirror.contains = function(parent, child) {\n\t    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n\t      child = child.parentNode;\n\t    if (parent.contains)\n\t      return parent.contains(child);\n\t    do {\n\t      if (child.nodeType == 11) child = child.host;\n\t      if (child == parent) return true;\n\t    } while (child = child.parentNode);\n\t  };\n\t\n\t  function activeElt() {\n\t    var activeElement = document.activeElement;\n\t    while (activeElement && activeElement.root && activeElement.root.activeElement)\n\t      activeElement = activeElement.root.activeElement;\n\t    return activeElement;\n\t  }\n\t  // Older versions of IE throws unspecified error when touching\n\t  // document.activeElement in some cases (during loading, in iframe)\n\t  if (ie && ie_version < 11) activeElt = function() {\n\t    try { return document.activeElement; }\n\t    catch(e) { return document.body; }\n\t  };\n\t\n\t  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n\t  var rmClass = CodeMirror.rmClass = function(node, cls) {\n\t    var current = node.className;\n\t    var match = classTest(cls).exec(current);\n\t    if (match) {\n\t      var after = current.slice(match.index + match[0].length);\n\t      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n\t    }\n\t  };\n\t  var addClass = CodeMirror.addClass = function(node, cls) {\n\t    var current = node.className;\n\t    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n\t  };\n\t  function joinClasses(a, b) {\n\t    var as = a.split(\" \");\n\t    for (var i = 0; i < as.length; i++)\n\t      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n\t    return b;\n\t  }\n\t\n\t  // WINDOW-WIDE EVENTS\n\t\n\t  // These must be handled carefully, because naively registering a\n\t  // handler for each editor will cause the editors to never be\n\t  // garbage collected.\n\t\n\t  function forEachCodeMirror(f) {\n\t    if (!document.body.getElementsByClassName) return;\n\t    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n\t    for (var i = 0; i < byClass.length; i++) {\n\t      var cm = byClass[i].CodeMirror;\n\t      if (cm) f(cm);\n\t    }\n\t  }\n\t\n\t  var globalsRegistered = false;\n\t  function ensureGlobalHandlers() {\n\t    if (globalsRegistered) return;\n\t    registerGlobalHandlers();\n\t    globalsRegistered = true;\n\t  }\n\t  function registerGlobalHandlers() {\n\t    // When the window resizes, we need to refresh active editors.\n\t    var resizeTimer;\n\t    on(window, \"resize\", function() {\n\t      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n\t        resizeTimer = null;\n\t        forEachCodeMirror(onResize);\n\t      }, 100);\n\t    });\n\t    // When the window loses focus, we want to show the editor as blurred\n\t    on(window, \"blur\", function() {\n\t      forEachCodeMirror(onBlur);\n\t    });\n\t  }\n\t\n\t  // FEATURE DETECTION\n\t\n\t  // Detect drag-and-drop\n\t  var dragAndDrop = function() {\n\t    // There is *some* kind of drag-and-drop support in IE6-8, but I\n\t    // couldn't get it to work yet.\n\t    if (ie && ie_version < 9) return false;\n\t    var div = elt('div');\n\t    return \"draggable\" in div || \"dragDrop\" in div;\n\t  }();\n\t\n\t  var zwspSupported;\n\t  function zeroWidthElement(measure) {\n\t    if (zwspSupported == null) {\n\t      var test = elt(\"span\", \"\\u200b\");\n\t      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n\t      if (measure.firstChild.offsetHeight != 0)\n\t        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n\t    }\n\t    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n\t      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n\t    node.setAttribute(\"cm-text\", \"\");\n\t    return node;\n\t  }\n\t\n\t  // Feature-detect IE's crummy client rect reporting for bidi text\n\t  var badBidiRects;\n\t  function hasBadBidiRects(measure) {\n\t    if (badBidiRects != null) return badBidiRects;\n\t    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n\t    var r0 = range(txt, 0, 1).getBoundingClientRect();\n\t    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n\t    var r1 = range(txt, 1, 2).getBoundingClientRect();\n\t    return badBidiRects = (r1.right - r0.right < 3);\n\t  }\n\t\n\t  // See if \"\".split is the broken IE version, if so, provide an\n\t  // alternative way to split lines.\n\t  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n\t    var pos = 0, result = [], l = string.length;\n\t    while (pos <= l) {\n\t      var nl = string.indexOf(\"\\n\", pos);\n\t      if (nl == -1) nl = string.length;\n\t      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n\t      var rt = line.indexOf(\"\\r\");\n\t      if (rt != -1) {\n\t        result.push(line.slice(0, rt));\n\t        pos += rt + 1;\n\t      } else {\n\t        result.push(line);\n\t        pos = nl + 1;\n\t      }\n\t    }\n\t    return result;\n\t  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\t\n\t  var hasSelection = window.getSelection ? function(te) {\n\t    try { return te.selectionStart != te.selectionEnd; }\n\t    catch(e) { return false; }\n\t  } : function(te) {\n\t    try {var range = te.ownerDocument.selection.createRange();}\n\t    catch(e) {}\n\t    if (!range || range.parentElement() != te) return false;\n\t    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n\t  };\n\t\n\t  var hasCopyEvent = (function() {\n\t    var e = elt(\"div\");\n\t    if (\"oncopy\" in e) return true;\n\t    e.setAttribute(\"oncopy\", \"return;\");\n\t    return typeof e.oncopy == \"function\";\n\t  })();\n\t\n\t  var badZoomedRects = null;\n\t  function hasBadZoomedRects(measure) {\n\t    if (badZoomedRects != null) return badZoomedRects;\n\t    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n\t    var normal = node.getBoundingClientRect();\n\t    var fromRange = range(node, 0, 1).getBoundingClientRect();\n\t    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n\t  }\n\t\n\t  // KEY NAMES\n\t\n\t  var keyNames = CodeMirror.keyNames = {\n\t    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n\t    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n\t    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n\t    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n\t    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n\t    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n\t    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n\t    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n\t  };\n\t  (function() {\n\t    // Number keys\n\t    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n\t    // Alphabetic keys\n\t    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n\t    // Function keys\n\t    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n\t  })();\n\t\n\t  // BIDI HELPERS\n\t\n\t  function iterateBidiSections(order, from, to, f) {\n\t    if (!order) return f(from, to, \"ltr\");\n\t    var found = false;\n\t    for (var i = 0; i < order.length; ++i) {\n\t      var part = order[i];\n\t      if (part.from < to && part.to > from || from == to && part.to == from) {\n\t        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n\t        found = true;\n\t      }\n\t    }\n\t    if (!found) f(from, to, \"ltr\");\n\t  }\n\t\n\t  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n\t  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\t\n\t  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n\t  function lineRight(line) {\n\t    var order = getOrder(line);\n\t    if (!order) return line.text.length;\n\t    return bidiRight(lst(order));\n\t  }\n\t\n\t  function lineStart(cm, lineN) {\n\t    var line = getLine(cm.doc, lineN);\n\t    var visual = visualLine(line);\n\t    if (visual != line) lineN = lineNo(visual);\n\t    var order = getOrder(visual);\n\t    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n\t    return Pos(lineN, ch);\n\t  }\n\t  function lineEnd(cm, lineN) {\n\t    var merged, line = getLine(cm.doc, lineN);\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      lineN = null;\n\t    }\n\t    var order = getOrder(line);\n\t    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n\t    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n\t  }\n\t  function lineStartSmart(cm, pos) {\n\t    var start = lineStart(cm, pos.line);\n\t    var line = getLine(cm.doc, start.line);\n\t    var order = getOrder(line);\n\t    if (!order || order[0].level == 0) {\n\t      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n\t      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n\t      return Pos(start.line, inWS ? 0 : firstNonWS);\n\t    }\n\t    return start;\n\t  }\n\t\n\t  function compareBidiLevel(order, a, b) {\n\t    var linedir = order[0].level;\n\t    if (a == linedir) return true;\n\t    if (b == linedir) return false;\n\t    return a < b;\n\t  }\n\t  var bidiOther;\n\t  function getBidiPartAt(order, pos) {\n\t    bidiOther = null;\n\t    for (var i = 0, found; i < order.length; ++i) {\n\t      var cur = order[i];\n\t      if (cur.from < pos && cur.to > pos) return i;\n\t      if ((cur.from == pos || cur.to == pos)) {\n\t        if (found == null) {\n\t          found = i;\n\t        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n\t          if (cur.from != cur.to) bidiOther = found;\n\t          return i;\n\t        } else {\n\t          if (cur.from != cur.to) bidiOther = i;\n\t          return found;\n\t        }\n\t      }\n\t    }\n\t    return found;\n\t  }\n\t\n\t  function moveInLine(line, pos, dir, byUnit) {\n\t    if (!byUnit) return pos + dir;\n\t    do pos += dir;\n\t    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n\t    return pos;\n\t  }\n\t\n\t  // This is needed in order to move 'visually' through bi-directional\n\t  // text -- i.e., pressing left should make the cursor go left, even\n\t  // when in RTL text. The tricky part is the 'jumps', where RTL and\n\t  // LTR text touch each other. This often requires the cursor offset\n\t  // to move more than one unit, in order to visually move one unit.\n\t  function moveVisually(line, start, dir, byUnit) {\n\t    var bidi = getOrder(line);\n\t    if (!bidi) return moveLogically(line, start, dir, byUnit);\n\t    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n\t    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\t\n\t    for (;;) {\n\t      if (target > part.from && target < part.to) return target;\n\t      if (target == part.from || target == part.to) {\n\t        if (getBidiPartAt(bidi, target) == pos) return target;\n\t        part = bidi[pos += dir];\n\t        return (dir > 0) == part.level % 2 ? part.to : part.from;\n\t      } else {\n\t        part = bidi[pos += dir];\n\t        if (!part) return null;\n\t        if ((dir > 0) == part.level % 2)\n\t          target = moveInLine(line, part.to, -1, byUnit);\n\t        else\n\t          target = moveInLine(line, part.from, 1, byUnit);\n\t      }\n\t    }\n\t  }\n\t\n\t  function moveLogically(line, start, dir, byUnit) {\n\t    var target = start + dir;\n\t    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n\t    return target < 0 || target > line.text.length ? null : target;\n\t  }\n\t\n\t  // Bidirectional ordering algorithm\n\t  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n\t  // that this (partially) implements.\n\t\n\t  // One-char codes used for character types:\n\t  // L (L):   Left-to-Right\n\t  // R (R):   Right-to-Left\n\t  // r (AL):  Right-to-Left Arabic\n\t  // 1 (EN):  European Number\n\t  // + (ES):  European Number Separator\n\t  // % (ET):  European Number Terminator\n\t  // n (AN):  Arabic Number\n\t  // , (CS):  Common Number Separator\n\t  // m (NSM): Non-Spacing Mark\n\t  // b (BN):  Boundary Neutral\n\t  // s (B):   Paragraph Separator\n\t  // t (S):   Segment Separator\n\t  // w (WS):  Whitespace\n\t  // N (ON):  Other Neutrals\n\t\n\t  // Returns null if characters are ordered as they appear\n\t  // (left-to-right), or an array of sections ({from, to, level}\n\t  // objects) in the order in which they occur visually.\n\t  var bidiOrdering = (function() {\n\t    // Character types for codepoints 0 to 0xff\n\t    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n\t    // Character types for codepoints 0x600 to 0x6ff\n\t    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n\t    function charType(code) {\n\t      if (code <= 0xf7) return lowTypes.charAt(code);\n\t      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n\t      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n\t      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n\t      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n\t      else if (code == 0x200c) return \"b\";\n\t      else return \"L\";\n\t    }\n\t\n\t    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n\t    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\t    // Browsers seem to always treat the boundaries of block elements as being L.\n\t    var outerType = \"L\";\n\t\n\t    function BidiSpan(level, from, to) {\n\t      this.level = level;\n\t      this.from = from; this.to = to;\n\t    }\n\t\n\t    return function(str) {\n\t      if (!bidiRE.test(str)) return false;\n\t      var len = str.length, types = [];\n\t      for (var i = 0, type; i < len; ++i)\n\t        types.push(type = charType(str.charCodeAt(i)));\n\t\n\t      // W1. Examine each non-spacing mark (NSM) in the level run, and\n\t      // change the type of the NSM to the type of the previous\n\t      // character. If the NSM is at the start of the level run, it will\n\t      // get the type of sor.\n\t      for (var i = 0, prev = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"m\") types[i] = prev;\n\t        else prev = type;\n\t      }\n\t\n\t      // W2. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, AL, or sor) is found. If an\n\t      // AL is found, change the type of the European number to Arabic\n\t      // number.\n\t      // W3. Change all ALs to R.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n\t        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n\t      }\n\t\n\t      // W4. A single European separator between two European numbers\n\t      // changes to a European number. A single common separator between\n\t      // two numbers of the same type changes to that type.\n\t      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n\t        var type = types[i];\n\t        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n\t        else if (type == \",\" && prev == types[i+1] &&\n\t                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n\t        prev = type;\n\t      }\n\t\n\t      // W5. A sequence of European terminators adjacent to European\n\t      // numbers changes to all European numbers.\n\t      // W6. Otherwise, separators and terminators change to Other\n\t      // Neutral.\n\t      for (var i = 0; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \",\") types[i] = \"N\";\n\t        else if (type == \"%\") {\n\t          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n\t          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // W7. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, or sor) is found. If an L is\n\t      // found, then change the type of the European number to L.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n\t        else if (isStrong.test(type)) cur = type;\n\t      }\n\t\n\t      // N1. A sequence of neutrals takes the direction of the\n\t      // surrounding strong text if the text on both sides has the same\n\t      // direction. European and Arabic numbers act as if they were R in\n\t      // terms of their influence on neutrals. Start-of-level-run (sor)\n\t      // and end-of-level-run (eor) are used at level run boundaries.\n\t      // N2. Any remaining neutrals take the embedding direction.\n\t      for (var i = 0; i < len; ++i) {\n\t        if (isNeutral.test(types[i])) {\n\t          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n\t          var before = (i ? types[i-1] : outerType) == \"L\";\n\t          var after = (end < len ? types[end] : outerType) == \"L\";\n\t          var replace = before || after ? \"L\" : \"R\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // Here we depart from the documented algorithm, in order to avoid\n\t      // building up an actual levels array. Since there are only three\n\t      // levels (0, 1, 2) in an implementation that doesn't take\n\t      // explicit embedding into account, we can build up the order on\n\t      // the fly, without following the level-based algorithm.\n\t      var order = [], m;\n\t      for (var i = 0; i < len;) {\n\t        if (countsAsLeft.test(types[i])) {\n\t          var start = i;\n\t          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n\t          order.push(new BidiSpan(0, start, i));\n\t        } else {\n\t          var pos = i, at = order.length;\n\t          for (++i; i < len && types[i] != \"L\"; ++i) {}\n\t          for (var j = pos; j < i;) {\n\t            if (countsAsNum.test(types[j])) {\n\t              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n\t              var nstart = j;\n\t              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n\t              order.splice(at, 0, new BidiSpan(2, nstart, j));\n\t              pos = j;\n\t            } else ++j;\n\t          }\n\t          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n\t        }\n\t      }\n\t      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n\t        order[0].from = m[0].length;\n\t        order.unshift(new BidiSpan(0, 0, m[0].length));\n\t      }\n\t      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n\t        lst(order).to -= m[0].length;\n\t        order.push(new BidiSpan(0, len - m[0].length, len));\n\t      }\n\t      if (order[0].level == 2)\n\t        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n\t      if (order[0].level != lst(order).level)\n\t        order.push(new BidiSpan(order[0].level, len, len));\n\t\n\t      return order;\n\t    };\n\t  })();\n\t\n\t  // THE END\n\t\n\t  CodeMirror.version = \"5.8.0\";\n\t\n\t  return CodeMirror;\n\t});\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(13), __webpack_require__(16), __webpack_require__(12), __webpack_require__(17));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\", \"../xml/xml\", \"../javascript/javascript\", \"../css/css\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  var defaultTags = {\n\t    script: [\n\t      [\"lang\", /(javascript|babel)/i, \"javascript\"],\n\t      [\"type\", /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^$/i, \"javascript\"],\n\t      [\"type\", /./, \"text/plain\"],\n\t      [null, null, \"javascript\"]\n\t    ],\n\t    style:  [\n\t      [\"lang\", /^css$/i, \"css\"],\n\t      [\"type\", /^(text\\/)?(x-)?(stylesheet|css)$/i, \"css\"],\n\t      [\"type\", /./, \"text/plain\"],\n\t      [null, null, \"css\"]\n\t    ]\n\t  };\n\t\n\t  function maybeBackup(stream, pat, style) {\n\t    var cur = stream.current(), close = cur.search(pat);\n\t    if (close > -1) {\n\t      stream.backUp(cur.length - close);\n\t    } else if (cur.match(/<\\/?$/)) {\n\t      stream.backUp(cur.length);\n\t      if (!stream.match(pat, false)) stream.match(cur);\n\t    }\n\t    return style;\n\t  }\n\t\n\t  var attrRegexpCache = {};\n\t  function getAttrRegexp(attr) {\n\t    var regexp = attrRegexpCache[attr];\n\t    if (regexp) return regexp;\n\t    return attrRegexpCache[attr] = new RegExp(\"\\\\s+\" + attr + \"\\\\s*=\\\\s*('|\\\")?([^'\\\"]+)('|\\\")?\\\\s*\");\n\t  }\n\t\n\t  function getAttrValue(stream, attr) {\n\t    var pos = stream.pos, match;\n\t    while (pos >= 0 && stream.string.charAt(pos) !== \"<\") pos--;\n\t    if (pos < 0) return pos;\n\t    if (match = stream.string.slice(pos, stream.pos).match(getAttrRegexp(attr)))\n\t      return match[2];\n\t    return \"\";\n\t  }\n\t\n\t  function getTagRegexp(tagName, anchored) {\n\t    return new RegExp((anchored ? \"^\" : \"\") + \"<\\/\\s*\" + tagName + \"\\s*>\", \"i\");\n\t  }\n\t\n\t  function addTags(from, to) {\n\t    for (var tag in from) {\n\t      var dest = to[tag] || (to[tag] = []);\n\t      var source = from[tag];\n\t      for (var i = source.length - 1; i >= 0; i--)\n\t        dest.unshift(source[i])\n\t    }\n\t  }\n\t\n\t  function findMatchingMode(tagInfo, stream) {\n\t    for (var i = 0; i < tagInfo.length; i++) {\n\t      var spec = tagInfo[i];\n\t      if (!spec[0] || spec[1].test(getAttrValue(stream, spec[0]))) return spec[2];\n\t    }\n\t  }\n\t\n\t  CodeMirror.defineMode(\"htmlmixed\", function (config, parserConfig) {\n\t    var htmlMode = CodeMirror.getMode(config, {\n\t      name: \"xml\",\n\t      htmlMode: true,\n\t      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,\n\t      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag\n\t    });\n\t\n\t    var tags = {};\n\t    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;\n\t    addTags(defaultTags, tags);\n\t    if (configTags) addTags(configTags, tags);\n\t    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)\n\t      tags.script.unshift([\"type\", configScript[i].matches, configScript[i].mode])\n\t\n\t    function html(stream, state) {\n\t      var tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase();\n\t      var tagInfo = tagName && tags.hasOwnProperty(tagName) && tags[tagName];\n\t\n\t      var style = htmlMode.token(stream, state.htmlState), modeSpec;\n\t\n\t      if (tagInfo && /\\btag\\b/.test(style) && stream.current() === \">\" &&\n\t          (modeSpec = findMatchingMode(tagInfo, stream))) {\n\t        var mode = CodeMirror.getMode(config, modeSpec);\n\t        var endTagA = getTagRegexp(tagName, true), endTag = getTagRegexp(tagName, false);\n\t        state.token = function (stream, state) {\n\t          if (stream.match(endTagA, false)) {\n\t            state.token = html;\n\t            state.localState = state.localMode = null;\n\t            return null;\n\t          }\n\t          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));\n\t        };\n\t        state.localMode = mode;\n\t        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, \"\"));\n\t      }\n\t      return style;\n\t    };\n\t\n\t    return {\n\t      startState: function () {\n\t        var state = htmlMode.startState();\n\t        return {token: html, localMode: null, localState: null, htmlState: state};\n\t      },\n\t\n\t      copyState: function (state) {\n\t        var local;\n\t        if (state.localState) {\n\t          local = CodeMirror.copyState(state.localMode, state.localState);\n\t        }\n\t        return {token: state.token, localMode: state.localMode, localState: local,\n\t                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n\t      },\n\t\n\t      token: function (stream, state) {\n\t        return state.token(stream, state);\n\t      },\n\t\n\t      indent: function (state, textAfter) {\n\t        if (!state.localMode || /^\\s*<\\//.test(textAfter))\n\t          return htmlMode.indent(state.htmlState, textAfter);\n\t        else if (state.localMode.indent)\n\t          return state.localMode.indent(state.localState, textAfter);\n\t        else\n\t          return CodeMirror.Pass;\n\t      },\n\t\n\t      innerMode: function (state) {\n\t        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n\t      }\n\t    };\n\t  }, \"xml\", \"javascript\", \"css\");\n\t\n\t  CodeMirror.defineMIME(\"text/html\", \"htmlmixed\");\n\t});\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(13));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tCodeMirror.defineMode(\"xml\", function(config, parserConfig) {\n\t  var indentUnit = config.indentUnit;\n\t  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;\n\t  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag;\n\t  if (multilineTagIndentPastTag == null) multilineTagIndentPastTag = true;\n\t\n\t  var Kludges = parserConfig.htmlMode ? {\n\t    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n\t                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n\t                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n\t                      'track': true, 'wbr': true, 'menuitem': true},\n\t    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n\t                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n\t                       'th': true, 'tr': true},\n\t    contextGrabbers: {\n\t      'dd': {'dd': true, 'dt': true},\n\t      'dt': {'dd': true, 'dt': true},\n\t      'li': {'li': true},\n\t      'option': {'option': true, 'optgroup': true},\n\t      'optgroup': {'optgroup': true},\n\t      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n\t            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n\t            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n\t            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n\t            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n\t      'rp': {'rp': true, 'rt': true},\n\t      'rt': {'rp': true, 'rt': true},\n\t      'tbody': {'tbody': true, 'tfoot': true},\n\t      'td': {'td': true, 'th': true},\n\t      'tfoot': {'tbody': true},\n\t      'th': {'td': true, 'th': true},\n\t      'thead': {'tbody': true, 'tfoot': true},\n\t      'tr': {'tr': true}\n\t    },\n\t    doNotIndent: {\"pre\": true},\n\t    allowUnquoted: true,\n\t    allowMissing: true,\n\t    caseFold: true\n\t  } : {\n\t    autoSelfClosers: {},\n\t    implicitlyClosed: {},\n\t    contextGrabbers: {},\n\t    doNotIndent: {},\n\t    allowUnquoted: false,\n\t    allowMissing: false,\n\t    caseFold: false\n\t  };\n\t  var alignCDATA = parserConfig.alignCDATA;\n\t\n\t  // Return variables for tokenizers\n\t  var type, setStyle;\n\t\n\t  function inText(stream, state) {\n\t    function chain(parser) {\n\t      state.tokenize = parser;\n\t      return parser(stream, state);\n\t    }\n\t\n\t    var ch = stream.next();\n\t    if (ch == \"<\") {\n\t      if (stream.eat(\"!\")) {\n\t        if (stream.eat(\"[\")) {\n\t          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n\t          else return null;\n\t        } else if (stream.match(\"--\")) {\n\t          return chain(inBlock(\"comment\", \"-->\"));\n\t        } else if (stream.match(\"DOCTYPE\", true, true)) {\n\t          stream.eatWhile(/[\\w\\._\\-]/);\n\t          return chain(doctype(1));\n\t        } else {\n\t          return null;\n\t        }\n\t      } else if (stream.eat(\"?\")) {\n\t        stream.eatWhile(/[\\w\\._\\-]/);\n\t        state.tokenize = inBlock(\"meta\", \"?>\");\n\t        return \"meta\";\n\t      } else {\n\t        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n\t        state.tokenize = inTag;\n\t        return \"tag bracket\";\n\t      }\n\t    } else if (ch == \"&\") {\n\t      var ok;\n\t      if (stream.eat(\"#\")) {\n\t        if (stream.eat(\"x\")) {\n\t          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n\t        } else {\n\t          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n\t        }\n\t      } else {\n\t        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n\t      }\n\t      return ok ? \"atom\" : \"error\";\n\t    } else {\n\t      stream.eatWhile(/[^&<]/);\n\t      return null;\n\t    }\n\t  }\n\t  inText.isInText = true;\n\t\n\t  function inTag(stream, state) {\n\t    var ch = stream.next();\n\t    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n\t      state.tokenize = inText;\n\t      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n\t      return \"tag bracket\";\n\t    } else if (ch == \"=\") {\n\t      type = \"equals\";\n\t      return null;\n\t    } else if (ch == \"<\") {\n\t      state.tokenize = inText;\n\t      state.state = baseState;\n\t      state.tagName = state.tagStart = null;\n\t      var next = state.tokenize(stream, state);\n\t      return next ? next + \" tag error\" : \"tag error\";\n\t    } else if (/[\\'\\\"]/.test(ch)) {\n\t      state.tokenize = inAttribute(ch);\n\t      state.stringStartCol = stream.column();\n\t      return state.tokenize(stream, state);\n\t    } else {\n\t      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n\t      return \"word\";\n\t    }\n\t  }\n\t\n\t  function inAttribute(quote) {\n\t    var closure = function(stream, state) {\n\t      while (!stream.eol()) {\n\t        if (stream.next() == quote) {\n\t          state.tokenize = inTag;\n\t          break;\n\t        }\n\t      }\n\t      return \"string\";\n\t    };\n\t    closure.isInAttribute = true;\n\t    return closure;\n\t  }\n\t\n\t  function inBlock(style, terminator) {\n\t    return function(stream, state) {\n\t      while (!stream.eol()) {\n\t        if (stream.match(terminator)) {\n\t          state.tokenize = inText;\n\t          break;\n\t        }\n\t        stream.next();\n\t      }\n\t      return style;\n\t    };\n\t  }\n\t  function doctype(depth) {\n\t    return function(stream, state) {\n\t      var ch;\n\t      while ((ch = stream.next()) != null) {\n\t        if (ch == \"<\") {\n\t          state.tokenize = doctype(depth + 1);\n\t          return state.tokenize(stream, state);\n\t        } else if (ch == \">\") {\n\t          if (depth == 1) {\n\t            state.tokenize = inText;\n\t            break;\n\t          } else {\n\t            state.tokenize = doctype(depth - 1);\n\t            return state.tokenize(stream, state);\n\t          }\n\t        }\n\t      }\n\t      return \"meta\";\n\t    };\n\t  }\n\t\n\t  function Context(state, tagName, startOfLine) {\n\t    this.prev = state.context;\n\t    this.tagName = tagName;\n\t    this.indent = state.indented;\n\t    this.startOfLine = startOfLine;\n\t    if (Kludges.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n\t      this.noIndent = true;\n\t  }\n\t  function popContext(state) {\n\t    if (state.context) state.context = state.context.prev;\n\t  }\n\t  function maybePopContext(state, nextTagName) {\n\t    var parentTagName;\n\t    while (true) {\n\t      if (!state.context) {\n\t        return;\n\t      }\n\t      parentTagName = state.context.tagName;\n\t      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||\n\t          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n\t        return;\n\t      }\n\t      popContext(state);\n\t    }\n\t  }\n\t\n\t  function baseState(type, stream, state) {\n\t    if (type == \"openTag\") {\n\t      state.tagStart = stream.column();\n\t      return tagNameState;\n\t    } else if (type == \"closeTag\") {\n\t      return closeTagNameState;\n\t    } else {\n\t      return baseState;\n\t    }\n\t  }\n\t  function tagNameState(type, stream, state) {\n\t    if (type == \"word\") {\n\t      state.tagName = stream.current();\n\t      setStyle = \"tag\";\n\t      return attrState;\n\t    } else {\n\t      setStyle = \"error\";\n\t      return tagNameState;\n\t    }\n\t  }\n\t  function closeTagNameState(type, stream, state) {\n\t    if (type == \"word\") {\n\t      var tagName = stream.current();\n\t      if (state.context && state.context.tagName != tagName &&\n\t          Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName))\n\t        popContext(state);\n\t      if (state.context && state.context.tagName == tagName) {\n\t        setStyle = \"tag\";\n\t        return closeState;\n\t      } else {\n\t        setStyle = \"tag error\";\n\t        return closeStateErr;\n\t      }\n\t    } else {\n\t      setStyle = \"error\";\n\t      return closeStateErr;\n\t    }\n\t  }\n\t\n\t  function closeState(type, _stream, state) {\n\t    if (type != \"endTag\") {\n\t      setStyle = \"error\";\n\t      return closeState;\n\t    }\n\t    popContext(state);\n\t    return baseState;\n\t  }\n\t  function closeStateErr(type, stream, state) {\n\t    setStyle = \"error\";\n\t    return closeState(type, stream, state);\n\t  }\n\t\n\t  function attrState(type, _stream, state) {\n\t    if (type == \"word\") {\n\t      setStyle = \"attribute\";\n\t      return attrEqState;\n\t    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n\t      var tagName = state.tagName, tagStart = state.tagStart;\n\t      state.tagName = state.tagStart = null;\n\t      if (type == \"selfcloseTag\" ||\n\t          Kludges.autoSelfClosers.hasOwnProperty(tagName)) {\n\t        maybePopContext(state, tagName);\n\t      } else {\n\t        maybePopContext(state, tagName);\n\t        state.context = new Context(state, tagName, tagStart == state.indented);\n\t      }\n\t      return baseState;\n\t    }\n\t    setStyle = \"error\";\n\t    return attrState;\n\t  }\n\t  function attrEqState(type, stream, state) {\n\t    if (type == \"equals\") return attrValueState;\n\t    if (!Kludges.allowMissing) setStyle = \"error\";\n\t    return attrState(type, stream, state);\n\t  }\n\t  function attrValueState(type, stream, state) {\n\t    if (type == \"string\") return attrContinuedState;\n\t    if (type == \"word\" && Kludges.allowUnquoted) {setStyle = \"string\"; return attrState;}\n\t    setStyle = \"error\";\n\t    return attrState(type, stream, state);\n\t  }\n\t  function attrContinuedState(type, stream, state) {\n\t    if (type == \"string\") return attrContinuedState;\n\t    return attrState(type, stream, state);\n\t  }\n\t\n\t  return {\n\t    startState: function() {\n\t      return {tokenize: inText,\n\t              state: baseState,\n\t              indented: 0,\n\t              tagName: null, tagStart: null,\n\t              context: null};\n\t    },\n\t\n\t    token: function(stream, state) {\n\t      if (!state.tagName && stream.sol())\n\t        state.indented = stream.indentation();\n\t\n\t      if (stream.eatSpace()) return null;\n\t      type = null;\n\t      var style = state.tokenize(stream, state);\n\t      if ((style || type) && style != \"comment\") {\n\t        setStyle = null;\n\t        state.state = state.state(type || style, stream, state);\n\t        if (setStyle)\n\t          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n\t      }\n\t      return style;\n\t    },\n\t\n\t    indent: function(state, textAfter, fullLine) {\n\t      var context = state.context;\n\t      // Indent multi-line strings (e.g. css).\n\t      if (state.tokenize.isInAttribute) {\n\t        if (state.tagStart == state.indented)\n\t          return state.stringStartCol + 1;\n\t        else\n\t          return state.indented + indentUnit;\n\t      }\n\t      if (context && context.noIndent) return CodeMirror.Pass;\n\t      if (state.tokenize != inTag && state.tokenize != inText)\n\t        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n\t      // Indent the starts of attribute names.\n\t      if (state.tagName) {\n\t        if (multilineTagIndentPastTag)\n\t          return state.tagStart + state.tagName.length + 2;\n\t        else\n\t          return state.tagStart + indentUnit * multilineTagIndentFactor;\n\t      }\n\t      if (alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n\t      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n\t      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n\t        while (context) {\n\t          if (context.tagName == tagAfter[2]) {\n\t            context = context.prev;\n\t            break;\n\t          } else if (Kludges.implicitlyClosed.hasOwnProperty(context.tagName)) {\n\t            context = context.prev;\n\t          } else {\n\t            break;\n\t          }\n\t        }\n\t      } else if (tagAfter) { // Opening tag spotted\n\t        while (context) {\n\t          var grabbers = Kludges.contextGrabbers[context.tagName];\n\t          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n\t            context = context.prev;\n\t          else\n\t            break;\n\t        }\n\t      }\n\t      while (context && !context.startOfLine)\n\t        context = context.prev;\n\t      if (context) return context.indent + indentUnit;\n\t      else return 0;\n\t    },\n\t\n\t    electricInput: /<\\/[\\s\\w:]+>$/,\n\t    blockCommentStart: \"<!--\",\n\t    blockCommentEnd: \"-->\",\n\t\n\t    configuration: parserConfig.htmlMode ? \"html\" : \"xml\",\n\t    helperType: parserConfig.htmlMode ? \"html\" : \"xml\"\n\t  };\n\t});\n\t\n\tCodeMirror.defineMIME(\"text/xml\", \"xml\");\n\tCodeMirror.defineMIME(\"application/xml\", \"xml\");\n\tif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n\t  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\t\n\t});\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(13));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t\"use strict\";\n\t\n\tCodeMirror.defineMode(\"css\", function(config, parserConfig) {\n\t  var provided = parserConfig;\n\t  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode(\"text/css\");\n\t  parserConfig.inline = provided.inline;\n\t\n\t  var indentUnit = config.indentUnit,\n\t      tokenHooks = parserConfig.tokenHooks,\n\t      documentTypes = parserConfig.documentTypes || {},\n\t      mediaTypes = parserConfig.mediaTypes || {},\n\t      mediaFeatures = parserConfig.mediaFeatures || {},\n\t      mediaValueKeywords = parserConfig.mediaValueKeywords || {},\n\t      propertyKeywords = parserConfig.propertyKeywords || {},\n\t      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},\n\t      fontProperties = parserConfig.fontProperties || {},\n\t      counterDescriptors = parserConfig.counterDescriptors || {},\n\t      colorKeywords = parserConfig.colorKeywords || {},\n\t      valueKeywords = parserConfig.valueKeywords || {},\n\t      allowNested = parserConfig.allowNested,\n\t      supportsAtComponent = parserConfig.supportsAtComponent === true;\n\t\n\t  var type, override;\n\t  function ret(style, tp) { type = tp; return style; }\n\t\n\t  // Tokenizers\n\t\n\t  function tokenBase(stream, state) {\n\t    var ch = stream.next();\n\t    if (tokenHooks[ch]) {\n\t      var result = tokenHooks[ch](stream, state);\n\t      if (result !== false) return result;\n\t    }\n\t    if (ch == \"@\") {\n\t      stream.eatWhile(/[\\w\\\\\\-]/);\n\t      return ret(\"def\", stream.current());\n\t    } else if (ch == \"=\" || (ch == \"~\" || ch == \"|\") && stream.eat(\"=\")) {\n\t      return ret(null, \"compare\");\n\t    } else if (ch == \"\\\"\" || ch == \"'\") {\n\t      state.tokenize = tokenString(ch);\n\t      return state.tokenize(stream, state);\n\t    } else if (ch == \"#\") {\n\t      stream.eatWhile(/[\\w\\\\\\-]/);\n\t      return ret(\"atom\", \"hash\");\n\t    } else if (ch == \"!\") {\n\t      stream.match(/^\\s*\\w*/);\n\t      return ret(\"keyword\", \"important\");\n\t    } else if (/\\d/.test(ch) || ch == \".\" && stream.eat(/\\d/)) {\n\t      stream.eatWhile(/[\\w.%]/);\n\t      return ret(\"number\", \"unit\");\n\t    } else if (ch === \"-\") {\n\t      if (/[\\d.]/.test(stream.peek())) {\n\t        stream.eatWhile(/[\\w.%]/);\n\t        return ret(\"number\", \"unit\");\n\t      } else if (stream.match(/^-[\\w\\\\\\-]+/)) {\n\t        stream.eatWhile(/[\\w\\\\\\-]/);\n\t        if (stream.match(/^\\s*:/, false))\n\t          return ret(\"variable-2\", \"variable-definition\");\n\t        return ret(\"variable-2\", \"variable\");\n\t      } else if (stream.match(/^\\w+-/)) {\n\t        return ret(\"meta\", \"meta\");\n\t      }\n\t    } else if (/[,+>*\\/]/.test(ch)) {\n\t      return ret(null, \"select-op\");\n\t    } else if (ch == \".\" && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n\t      return ret(\"qualifier\", \"qualifier\");\n\t    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n\t      return ret(null, ch);\n\t    } else if ((ch == \"u\" && stream.match(/rl(-prefix)?\\(/)) ||\n\t               (ch == \"d\" && stream.match(\"omain(\")) ||\n\t               (ch == \"r\" && stream.match(\"egexp(\"))) {\n\t      stream.backUp(1);\n\t      state.tokenize = tokenParenthesized;\n\t      return ret(\"property\", \"word\");\n\t    } else if (/[\\w\\\\\\-]/.test(ch)) {\n\t      stream.eatWhile(/[\\w\\\\\\-]/);\n\t      return ret(\"property\", \"word\");\n\t    } else {\n\t      return ret(null, null);\n\t    }\n\t  }\n\t\n\t  function tokenString(quote) {\n\t    return function(stream, state) {\n\t      var escaped = false, ch;\n\t      while ((ch = stream.next()) != null) {\n\t        if (ch == quote && !escaped) {\n\t          if (quote == \")\") stream.backUp(1);\n\t          break;\n\t        }\n\t        escaped = !escaped && ch == \"\\\\\";\n\t      }\n\t      if (ch == quote || !escaped && quote != \")\") state.tokenize = null;\n\t      return ret(\"string\", \"string\");\n\t    };\n\t  }\n\t\n\t  function tokenParenthesized(stream, state) {\n\t    stream.next(); // Must be '('\n\t    if (!stream.match(/\\s*[\\\"\\')]/, false))\n\t      state.tokenize = tokenString(\")\");\n\t    else\n\t      state.tokenize = null;\n\t    return ret(null, \"(\");\n\t  }\n\t\n\t  // Context management\n\t\n\t  function Context(type, indent, prev) {\n\t    this.type = type;\n\t    this.indent = indent;\n\t    this.prev = prev;\n\t  }\n\t\n\t  function pushContext(state, stream, type, indent) {\n\t    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\n\t    return type;\n\t  }\n\t\n\t  function popContext(state) {\n\t    if (state.context.prev)\n\t      state.context = state.context.prev;\n\t    return state.context.type;\n\t  }\n\t\n\t  function pass(type, stream, state) {\n\t    return states[state.context.type](type, stream, state);\n\t  }\n\t  function popAndPass(type, stream, state, n) {\n\t    for (var i = n || 1; i > 0; i--)\n\t      state.context = state.context.prev;\n\t    return pass(type, stream, state);\n\t  }\n\t\n\t  // Parser\n\t\n\t  function wordAsValue(stream) {\n\t    var word = stream.current().toLowerCase();\n\t    if (valueKeywords.hasOwnProperty(word))\n\t      override = \"atom\";\n\t    else if (colorKeywords.hasOwnProperty(word))\n\t      override = \"keyword\";\n\t    else\n\t      override = \"variable\";\n\t  }\n\t\n\t  var states = {};\n\t\n\t  states.top = function(type, stream, state) {\n\t    if (type == \"{\") {\n\t      return pushContext(state, stream, \"block\");\n\t    } else if (type == \"}\" && state.context.prev) {\n\t      return popContext(state);\n\t    } else if (supportsAtComponent && /@component/.test(type)) {\n\t      return pushContext(state, stream, \"atComponentBlock\");\n\t    } else if (/^@(-moz-)?document$/.test(type)) {\n\t      return pushContext(state, stream, \"documentTypes\");\n\t    } else if (/^@(media|supports|(-moz-)?document|import)$/.test(type)) {\n\t      return pushContext(state, stream, \"atBlock\");\n\t    } else if (/^@(font-face|counter-style)/.test(type)) {\n\t      state.stateArg = type;\n\t      return \"restricted_atBlock_before\";\n\t    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {\n\t      return \"keyframes\";\n\t    } else if (type && type.charAt(0) == \"@\") {\n\t      return pushContext(state, stream, \"at\");\n\t    } else if (type == \"hash\") {\n\t      override = \"builtin\";\n\t    } else if (type == \"word\") {\n\t      override = \"tag\";\n\t    } else if (type == \"variable-definition\") {\n\t      return \"maybeprop\";\n\t    } else if (type == \"interpolation\") {\n\t      return pushContext(state, stream, \"interpolation\");\n\t    } else if (type == \":\") {\n\t      return \"pseudo\";\n\t    } else if (allowNested && type == \"(\") {\n\t      return pushContext(state, stream, \"parens\");\n\t    }\n\t    return state.context.type;\n\t  };\n\t\n\t  states.block = function(type, stream, state) {\n\t    if (type == \"word\") {\n\t      var word = stream.current().toLowerCase();\n\t      if (propertyKeywords.hasOwnProperty(word)) {\n\t        override = \"property\";\n\t        return \"maybeprop\";\n\t      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {\n\t        override = \"string-2\";\n\t        return \"maybeprop\";\n\t      } else if (allowNested) {\n\t        override = stream.match(/^\\s*:(?:\\s|$)/, false) ? \"property\" : \"tag\";\n\t        return \"block\";\n\t      } else {\n\t        override += \" error\";\n\t        return \"maybeprop\";\n\t      }\n\t    } else if (type == \"meta\") {\n\t      return \"block\";\n\t    } else if (!allowNested && (type == \"hash\" || type == \"qualifier\")) {\n\t      override = \"error\";\n\t      return \"block\";\n\t    } else {\n\t      return states.top(type, stream, state);\n\t    }\n\t  };\n\t\n\t  states.maybeprop = function(type, stream, state) {\n\t    if (type == \":\") return pushContext(state, stream, \"prop\");\n\t    return pass(type, stream, state);\n\t  };\n\t\n\t  states.prop = function(type, stream, state) {\n\t    if (type == \";\") return popContext(state);\n\t    if (type == \"{\" && allowNested) return pushContext(state, stream, \"propBlock\");\n\t    if (type == \"}\" || type == \"{\") return popAndPass(type, stream, state);\n\t    if (type == \"(\") return pushContext(state, stream, \"parens\");\n\t\n\t    if (type == \"hash\" && !/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {\n\t      override += \" error\";\n\t    } else if (type == \"word\") {\n\t      wordAsValue(stream);\n\t    } else if (type == \"interpolation\") {\n\t      return pushContext(state, stream, \"interpolation\");\n\t    }\n\t    return \"prop\";\n\t  };\n\t\n\t  states.propBlock = function(type, _stream, state) {\n\t    if (type == \"}\") return popContext(state);\n\t    if (type == \"word\") { override = \"property\"; return \"maybeprop\"; }\n\t    return state.context.type;\n\t  };\n\t\n\t  states.parens = function(type, stream, state) {\n\t    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n\t    if (type == \")\") return popContext(state);\n\t    if (type == \"(\") return pushContext(state, stream, \"parens\");\n\t    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n\t    if (type == \"word\") wordAsValue(stream);\n\t    return \"parens\";\n\t  };\n\t\n\t  states.pseudo = function(type, stream, state) {\n\t    if (type == \"word\") {\n\t      override = \"variable-3\";\n\t      return state.context.type;\n\t    }\n\t    return pass(type, stream, state);\n\t  };\n\t\n\t  states.documentTypes = function(type, stream, state) {\n\t    if (type == \"word\" && documentTypes.hasOwnProperty(stream.current())) {\n\t      override = \"tag\";\n\t      return state.context.type;\n\t    } else {\n\t      return states.atBlock(type, stream, state);\n\t    }\n\t  };\n\t\n\t  states.atBlock = function(type, stream, state) {\n\t    if (type == \"(\") return pushContext(state, stream, \"atBlock_parens\");\n\t    if (type == \"}\" || type == \";\") return popAndPass(type, stream, state);\n\t    if (type == \"{\") return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\");\n\t\n\t    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n\t\n\t    if (type == \"word\") {\n\t      var word = stream.current().toLowerCase();\n\t      if (word == \"only\" || word == \"not\" || word == \"and\" || word == \"or\")\n\t        override = \"keyword\";\n\t      else if (mediaTypes.hasOwnProperty(word))\n\t        override = \"attribute\";\n\t      else if (mediaFeatures.hasOwnProperty(word))\n\t        override = \"property\";\n\t      else if (mediaValueKeywords.hasOwnProperty(word))\n\t        override = \"keyword\";\n\t      else if (propertyKeywords.hasOwnProperty(word))\n\t        override = \"property\";\n\t      else if (nonStandardPropertyKeywords.hasOwnProperty(word))\n\t        override = \"string-2\";\n\t      else if (valueKeywords.hasOwnProperty(word))\n\t        override = \"atom\";\n\t      else if (colorKeywords.hasOwnProperty(word))\n\t        override = \"keyword\";\n\t      else\n\t        override = \"error\";\n\t    }\n\t    return state.context.type;\n\t  };\n\t\n\t  states.atComponentBlock = function(type, stream, state) {\n\t    if (type == \"}\")\n\t      return popAndPass(type, stream, state);\n\t    if (type == \"{\")\n\t      return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\", false);\n\t    if (type == \"word\")\n\t      override = \"error\";\n\t    return state.context.type;\n\t  };\n\t\n\t  states.atBlock_parens = function(type, stream, state) {\n\t    if (type == \")\") return popContext(state);\n\t    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state, 2);\n\t    return states.atBlock(type, stream, state);\n\t  };\n\t\n\t  states.restricted_atBlock_before = function(type, stream, state) {\n\t    if (type == \"{\")\n\t      return pushContext(state, stream, \"restricted_atBlock\");\n\t    if (type == \"word\" && state.stateArg == \"@counter-style\") {\n\t      override = \"variable\";\n\t      return \"restricted_atBlock_before\";\n\t    }\n\t    return pass(type, stream, state);\n\t  };\n\t\n\t  states.restricted_atBlock = function(type, stream, state) {\n\t    if (type == \"}\") {\n\t      state.stateArg = null;\n\t      return popContext(state);\n\t    }\n\t    if (type == \"word\") {\n\t      if ((state.stateArg == \"@font-face\" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||\n\t          (state.stateArg == \"@counter-style\" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))\n\t        override = \"error\";\n\t      else\n\t        override = \"property\";\n\t      return \"maybeprop\";\n\t    }\n\t    return \"restricted_atBlock\";\n\t  };\n\t\n\t  states.keyframes = function(type, stream, state) {\n\t    if (type == \"word\") { override = \"variable\"; return \"keyframes\"; }\n\t    if (type == \"{\") return pushContext(state, stream, \"top\");\n\t    return pass(type, stream, state);\n\t  };\n\t\n\t  states.at = function(type, stream, state) {\n\t    if (type == \";\") return popContext(state);\n\t    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n\t    if (type == \"word\") override = \"tag\";\n\t    else if (type == \"hash\") override = \"builtin\";\n\t    return \"at\";\n\t  };\n\t\n\t  states.interpolation = function(type, stream, state) {\n\t    if (type == \"}\") return popContext(state);\n\t    if (type == \"{\" || type == \";\") return popAndPass(type, stream, state);\n\t    if (type == \"word\") override = \"variable\";\n\t    else if (type != \"variable\" && type != \"(\" && type != \")\") override = \"error\";\n\t    return \"interpolation\";\n\t  };\n\t\n\t  return {\n\t    startState: function(base) {\n\t      return {tokenize: null,\n\t              state: parserConfig.inline ? \"block\" : \"top\",\n\t              stateArg: null,\n\t              context: new Context(parserConfig.inline ? \"block\" : \"top\", base || 0, null)};\n\t    },\n\t\n\t    token: function(stream, state) {\n\t      if (!state.tokenize && stream.eatSpace()) return null;\n\t      var style = (state.tokenize || tokenBase)(stream, state);\n\t      if (style && typeof style == \"object\") {\n\t        type = style[1];\n\t        style = style[0];\n\t      }\n\t      override = style;\n\t      state.state = states[state.state](type, stream, state);\n\t      return override;\n\t    },\n\t\n\t    indent: function(state, textAfter) {\n\t      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n\t      var indent = cx.indent;\n\t      if (cx.type == \"prop\" && (ch == \"}\" || ch == \")\")) cx = cx.prev;\n\t      if (cx.prev) {\n\t        if (ch == \"}\" && (cx.type == \"block\" || cx.type == \"top\" ||\n\t                          cx.type == \"interpolation\" || cx.type == \"restricted_atBlock\")) {\n\t          // Resume indentation from parent context.\n\t          cx = cx.prev;\n\t          indent = cx.indent;\n\t        } else if (ch == \")\" && (cx.type == \"parens\" || cx.type == \"atBlock_parens\") ||\n\t            ch == \"{\" && (cx.type == \"at\" || cx.type == \"atBlock\")) {\n\t          // Dedent relative to current context.\n\t          indent = Math.max(0, cx.indent - indentUnit);\n\t          cx = cx.prev;\n\t        }\n\t      }\n\t      return indent;\n\t    },\n\t\n\t    electricChars: \"}\",\n\t    blockCommentStart: \"/*\",\n\t    blockCommentEnd: \"*/\",\n\t    fold: \"brace\"\n\t  };\n\t});\n\t\n\t  function keySet(array) {\n\t    var keys = {};\n\t    for (var i = 0; i < array.length; ++i) {\n\t      keys[array[i]] = true;\n\t    }\n\t    return keys;\n\t  }\n\t\n\t  var documentTypes_ = [\n\t    \"domain\", \"regexp\", \"url\", \"url-prefix\"\n\t  ], documentTypes = keySet(documentTypes_);\n\t\n\t  var mediaTypes_ = [\n\t    \"all\", \"aural\", \"braille\", \"handheld\", \"print\", \"projection\", \"screen\",\n\t    \"tty\", \"tv\", \"embossed\"\n\t  ], mediaTypes = keySet(mediaTypes_);\n\t\n\t  var mediaFeatures_ = [\n\t    \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\",\n\t    \"device-width\", \"min-device-width\", \"max-device-width\", \"device-height\",\n\t    \"min-device-height\", \"max-device-height\", \"aspect-ratio\",\n\t    \"min-aspect-ratio\", \"max-aspect-ratio\", \"device-aspect-ratio\",\n\t    \"min-device-aspect-ratio\", \"max-device-aspect-ratio\", \"color\", \"min-color\",\n\t    \"max-color\", \"color-index\", \"min-color-index\", \"max-color-index\",\n\t    \"monochrome\", \"min-monochrome\", \"max-monochrome\", \"resolution\",\n\t    \"min-resolution\", \"max-resolution\", \"scan\", \"grid\", \"orientation\",\n\t    \"device-pixel-ratio\", \"min-device-pixel-ratio\", \"max-device-pixel-ratio\",\n\t    \"pointer\", \"any-pointer\", \"hover\", \"any-hover\"\n\t  ], mediaFeatures = keySet(mediaFeatures_);\n\t\n\t  var mediaValueKeywords_ = [\n\t    \"landscape\", \"portrait\", \"none\", \"coarse\", \"fine\", \"on-demand\", \"hover\",\n\t    \"interlace\", \"progressive\"\n\t  ], mediaValueKeywords = keySet(mediaValueKeywords_);\n\t\n\t  var propertyKeywords_ = [\n\t    \"align-content\", \"align-items\", \"align-self\", \"alignment-adjust\",\n\t    \"alignment-baseline\", \"anchor-point\", \"animation\", \"animation-delay\",\n\t    \"animation-direction\", \"animation-duration\", \"animation-fill-mode\",\n\t    \"animation-iteration-count\", \"animation-name\", \"animation-play-state\",\n\t    \"animation-timing-function\", \"appearance\", \"azimuth\", \"backface-visibility\",\n\t    \"background\", \"background-attachment\", \"background-clip\", \"background-color\",\n\t    \"background-image\", \"background-origin\", \"background-position\",\n\t    \"background-repeat\", \"background-size\", \"baseline-shift\", \"binding\",\n\t    \"bleed\", \"bookmark-label\", \"bookmark-level\", \"bookmark-state\",\n\t    \"bookmark-target\", \"border\", \"border-bottom\", \"border-bottom-color\",\n\t    \"border-bottom-left-radius\", \"border-bottom-right-radius\",\n\t    \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\",\n\t    \"border-color\", \"border-image\", \"border-image-outset\",\n\t    \"border-image-repeat\", \"border-image-slice\", \"border-image-source\",\n\t    \"border-image-width\", \"border-left\", \"border-left-color\",\n\t    \"border-left-style\", \"border-left-width\", \"border-radius\", \"border-right\",\n\t    \"border-right-color\", \"border-right-style\", \"border-right-width\",\n\t    \"border-spacing\", \"border-style\", \"border-top\", \"border-top-color\",\n\t    \"border-top-left-radius\", \"border-top-right-radius\", \"border-top-style\",\n\t    \"border-top-width\", \"border-width\", \"bottom\", \"box-decoration-break\",\n\t    \"box-shadow\", \"box-sizing\", \"break-after\", \"break-before\", \"break-inside\",\n\t    \"caption-side\", \"clear\", \"clip\", \"color\", \"color-profile\", \"column-count\",\n\t    \"column-fill\", \"column-gap\", \"column-rule\", \"column-rule-color\",\n\t    \"column-rule-style\", \"column-rule-width\", \"column-span\", \"column-width\",\n\t    \"columns\", \"content\", \"counter-increment\", \"counter-reset\", \"crop\", \"cue\",\n\t    \"cue-after\", \"cue-before\", \"cursor\", \"direction\", \"display\",\n\t    \"dominant-baseline\", \"drop-initial-after-adjust\",\n\t    \"drop-initial-after-align\", \"drop-initial-before-adjust\",\n\t    \"drop-initial-before-align\", \"drop-initial-size\", \"drop-initial-value\",\n\t    \"elevation\", \"empty-cells\", \"fit\", \"fit-position\", \"flex\", \"flex-basis\",\n\t    \"flex-direction\", \"flex-flow\", \"flex-grow\", \"flex-shrink\", \"flex-wrap\",\n\t    \"float\", \"float-offset\", \"flow-from\", \"flow-into\", \"font\", \"font-feature-settings\",\n\t    \"font-family\", \"font-kerning\", \"font-language-override\", \"font-size\", \"font-size-adjust\",\n\t    \"font-stretch\", \"font-style\", \"font-synthesis\", \"font-variant\",\n\t    \"font-variant-alternates\", \"font-variant-caps\", \"font-variant-east-asian\",\n\t    \"font-variant-ligatures\", \"font-variant-numeric\", \"font-variant-position\",\n\t    \"font-weight\", \"grid\", \"grid-area\", \"grid-auto-columns\", \"grid-auto-flow\",\n\t    \"grid-auto-position\", \"grid-auto-rows\", \"grid-column\", \"grid-column-end\",\n\t    \"grid-column-start\", \"grid-row\", \"grid-row-end\", \"grid-row-start\",\n\t    \"grid-template\", \"grid-template-areas\", \"grid-template-columns\",\n\t    \"grid-template-rows\", \"hanging-punctuation\", \"height\", \"hyphens\",\n\t    \"icon\", \"image-orientation\", \"image-rendering\", \"image-resolution\",\n\t    \"inline-box-align\", \"justify-content\", \"left\", \"letter-spacing\",\n\t    \"line-break\", \"line-height\", \"line-stacking\", \"line-stacking-ruby\",\n\t    \"line-stacking-shift\", \"line-stacking-strategy\", \"list-style\",\n\t    \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\",\n\t    \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\",\n\t    \"marker-offset\", \"marks\", \"marquee-direction\", \"marquee-loop\",\n\t    \"marquee-play-count\", \"marquee-speed\", \"marquee-style\", \"max-height\",\n\t    \"max-width\", \"min-height\", \"min-width\", \"move-to\", \"nav-down\", \"nav-index\",\n\t    \"nav-left\", \"nav-right\", \"nav-up\", \"object-fit\", \"object-position\",\n\t    \"opacity\", \"order\", \"orphans\", \"outline\",\n\t    \"outline-color\", \"outline-offset\", \"outline-style\", \"outline-width\",\n\t    \"overflow\", \"overflow-style\", \"overflow-wrap\", \"overflow-x\", \"overflow-y\",\n\t    \"padding\", \"padding-bottom\", \"padding-left\", \"padding-right\", \"padding-top\",\n\t    \"page\", \"page-break-after\", \"page-break-before\", \"page-break-inside\",\n\t    \"page-policy\", \"pause\", \"pause-after\", \"pause-before\", \"perspective\",\n\t    \"perspective-origin\", \"pitch\", \"pitch-range\", \"play-during\", \"position\",\n\t    \"presentation-level\", \"punctuation-trim\", \"quotes\", \"region-break-after\",\n\t    \"region-break-before\", \"region-break-inside\", \"region-fragment\",\n\t    \"rendering-intent\", \"resize\", \"rest\", \"rest-after\", \"rest-before\", \"richness\",\n\t    \"right\", \"rotation\", \"rotation-point\", \"ruby-align\", \"ruby-overhang\",\n\t    \"ruby-position\", \"ruby-span\", \"shape-image-threshold\", \"shape-inside\", \"shape-margin\",\n\t    \"shape-outside\", \"size\", \"speak\", \"speak-as\", \"speak-header\",\n\t    \"speak-numeral\", \"speak-punctuation\", \"speech-rate\", \"stress\", \"string-set\",\n\t    \"tab-size\", \"table-layout\", \"target\", \"target-name\", \"target-new\",\n\t    \"target-position\", \"text-align\", \"text-align-last\", \"text-decoration\",\n\t    \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-skip\",\n\t    \"text-decoration-style\", \"text-emphasis\", \"text-emphasis-color\",\n\t    \"text-emphasis-position\", \"text-emphasis-style\", \"text-height\",\n\t    \"text-indent\", \"text-justify\", \"text-outline\", \"text-overflow\", \"text-shadow\",\n\t    \"text-size-adjust\", \"text-space-collapse\", \"text-transform\", \"text-underline-position\",\n\t    \"text-wrap\", \"top\", \"transform\", \"transform-origin\", \"transform-style\",\n\t    \"transition\", \"transition-delay\", \"transition-duration\",\n\t    \"transition-property\", \"transition-timing-function\", \"unicode-bidi\",\n\t    \"vertical-align\", \"visibility\", \"voice-balance\", \"voice-duration\",\n\t    \"voice-family\", \"voice-pitch\", \"voice-range\", \"voice-rate\", \"voice-stress\",\n\t    \"voice-volume\", \"volume\", \"white-space\", \"widows\", \"width\", \"word-break\",\n\t    \"word-spacing\", \"word-wrap\", \"z-index\",\n\t    // SVG-specific\n\t    \"clip-path\", \"clip-rule\", \"mask\", \"enable-background\", \"filter\", \"flood-color\",\n\t    \"flood-opacity\", \"lighting-color\", \"stop-color\", \"stop-opacity\", \"pointer-events\",\n\t    \"color-interpolation\", \"color-interpolation-filters\",\n\t    \"color-rendering\", \"fill\", \"fill-opacity\", \"fill-rule\", \"image-rendering\",\n\t    \"marker\", \"marker-end\", \"marker-mid\", \"marker-start\", \"shape-rendering\", \"stroke\",\n\t    \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\",\n\t    \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"text-rendering\",\n\t    \"baseline-shift\", \"dominant-baseline\", \"glyph-orientation-horizontal\",\n\t    \"glyph-orientation-vertical\", \"text-anchor\", \"writing-mode\"\n\t  ], propertyKeywords = keySet(propertyKeywords_);\n\t\n\t  var nonStandardPropertyKeywords_ = [\n\t    \"scrollbar-arrow-color\", \"scrollbar-base-color\", \"scrollbar-dark-shadow-color\",\n\t    \"scrollbar-face-color\", \"scrollbar-highlight-color\", \"scrollbar-shadow-color\",\n\t    \"scrollbar-3d-light-color\", \"scrollbar-track-color\", \"shape-inside\",\n\t    \"searchfield-cancel-button\", \"searchfield-decoration\", \"searchfield-results-button\",\n\t    \"searchfield-results-decoration\", \"zoom\"\n\t  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\n\t\n\t  var fontProperties_ = [\n\t    \"font-family\", \"src\", \"unicode-range\", \"font-variant\", \"font-feature-settings\",\n\t    \"font-stretch\", \"font-weight\", \"font-style\"\n\t  ], fontProperties = keySet(fontProperties_);\n\t\n\t  var counterDescriptors_ = [\n\t    \"additive-symbols\", \"fallback\", \"negative\", \"pad\", \"prefix\", \"range\",\n\t    \"speak-as\", \"suffix\", \"symbols\", \"system\"\n\t  ], counterDescriptors = keySet(counterDescriptors_);\n\t\n\t  var colorKeywords_ = [\n\t    \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\n\t    \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\n\t    \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\",\n\t    \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\",\n\t    \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\",\n\t    \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\",\n\t    \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\",\n\t    \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\",\n\t    \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\",\n\t    \"gold\", \"goldenrod\", \"gray\", \"grey\", \"green\", \"greenyellow\", \"honeydew\",\n\t    \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\n\t    \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\",\n\t    \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightpink\",\n\t    \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\",\n\t    \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\",\n\t    \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\",\n\t    \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n\t    \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\",\n\t    \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\",\n\t    \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\",\n\t    \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\",\n\t    \"purple\", \"rebeccapurple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\",\n\t    \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\n\t    \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\",\n\t    \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\",\n\t    \"whitesmoke\", \"yellow\", \"yellowgreen\"\n\t  ], colorKeywords = keySet(colorKeywords_);\n\t\n\t  var valueKeywords_ = [\n\t    \"above\", \"absolute\", \"activeborder\", \"additive\", \"activecaption\", \"afar\",\n\t    \"after-white-space\", \"ahead\", \"alias\", \"all\", \"all-scroll\", \"alphabetic\", \"alternate\",\n\t    \"always\", \"amharic\", \"amharic-abegede\", \"antialiased\", \"appworkspace\",\n\t    \"arabic-indic\", \"armenian\", \"asterisks\", \"attr\", \"auto\", \"avoid\", \"avoid-column\", \"avoid-page\",\n\t    \"avoid-region\", \"background\", \"backwards\", \"baseline\", \"below\", \"bidi-override\", \"binary\",\n\t    \"bengali\", \"blink\", \"block\", \"block-axis\", \"bold\", \"bolder\", \"border\", \"border-box\",\n\t    \"both\", \"bottom\", \"break\", \"break-all\", \"break-word\", \"bullets\", \"button\", \"button-bevel\",\n\t    \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\", \"calc\", \"cambodian\",\n\t    \"capitalize\", \"caps-lock-indicator\", \"caption\", \"captiontext\", \"caret\",\n\t    \"cell\", \"center\", \"checkbox\", \"circle\", \"cjk-decimal\", \"cjk-earthly-branch\",\n\t    \"cjk-heavenly-stem\", \"cjk-ideographic\", \"clear\", \"clip\", \"close-quote\",\n\t    \"col-resize\", \"collapse\", \"column\", \"column-reverse\", \"compact\", \"condensed\", \"contain\", \"content\",\n\t    \"content-box\", \"context-menu\", \"continuous\", \"copy\", \"counter\", \"counters\", \"cover\", \"crop\",\n\t    \"cross\", \"crosshair\", \"currentcolor\", \"cursive\", \"cyclic\", \"dashed\", \"decimal\",\n\t    \"decimal-leading-zero\", \"default\", \"default-button\", \"destination-atop\",\n\t    \"destination-in\", \"destination-out\", \"destination-over\", \"devanagari\",\n\t    \"disc\", \"discard\", \"disclosure-closed\", \"disclosure-open\", \"document\",\n\t    \"dot-dash\", \"dot-dot-dash\",\n\t    \"dotted\", \"double\", \"down\", \"e-resize\", \"ease\", \"ease-in\", \"ease-in-out\", \"ease-out\",\n\t    \"element\", \"ellipse\", \"ellipsis\", \"embed\", \"end\", \"ethiopic\", \"ethiopic-abegede\",\n\t    \"ethiopic-abegede-am-et\", \"ethiopic-abegede-gez\", \"ethiopic-abegede-ti-er\",\n\t    \"ethiopic-abegede-ti-et\", \"ethiopic-halehame-aa-er\",\n\t    \"ethiopic-halehame-aa-et\", \"ethiopic-halehame-am-et\",\n\t    \"ethiopic-halehame-gez\", \"ethiopic-halehame-om-et\",\n\t    \"ethiopic-halehame-sid-et\", \"ethiopic-halehame-so-et\",\n\t    \"ethiopic-halehame-ti-er\", \"ethiopic-halehame-ti-et\", \"ethiopic-halehame-tig\",\n\t    \"ethiopic-numeric\", \"ew-resize\", \"expanded\", \"extends\", \"extra-condensed\",\n\t    \"extra-expanded\", \"fantasy\", \"fast\", \"fill\", \"fixed\", \"flat\", \"flex\", \"flex-end\", \"flex-start\", \"footnotes\",\n\t    \"forwards\", \"from\", \"geometricPrecision\", \"georgian\", \"graytext\", \"groove\",\n\t    \"gujarati\", \"gurmukhi\", \"hand\", \"hangul\", \"hangul-consonant\", \"hebrew\",\n\t    \"help\", \"hidden\", \"hide\", \"higher\", \"highlight\", \"highlighttext\",\n\t    \"hiragana\", \"hiragana-iroha\", \"horizontal\", \"hsl\", \"hsla\", \"icon\", \"ignore\",\n\t    \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\", \"infinite\",\n\t    \"infobackground\", \"infotext\", \"inherit\", \"initial\", \"inline\", \"inline-axis\",\n\t    \"inline-block\", \"inline-flex\", \"inline-table\", \"inset\", \"inside\", \"intrinsic\", \"invert\",\n\t    \"italic\", \"japanese-formal\", \"japanese-informal\", \"justify\", \"kannada\",\n\t    \"katakana\", \"katakana-iroha\", \"keep-all\", \"khmer\",\n\t    \"korean-hangul-formal\", \"korean-hanja-formal\", \"korean-hanja-informal\",\n\t    \"landscape\", \"lao\", \"large\", \"larger\", \"left\", \"level\", \"lighter\",\n\t    \"line-through\", \"linear\", \"linear-gradient\", \"lines\", \"list-item\", \"listbox\", \"listitem\",\n\t    \"local\", \"logical\", \"loud\", \"lower\", \"lower-alpha\", \"lower-armenian\",\n\t    \"lower-greek\", \"lower-hexadecimal\", \"lower-latin\", \"lower-norwegian\",\n\t    \"lower-roman\", \"lowercase\", \"ltr\", \"malayalam\", \"match\", \"matrix\", \"matrix3d\",\n\t    \"media-controls-background\", \"media-current-time-display\",\n\t    \"media-fullscreen-button\", \"media-mute-button\", \"media-play-button\",\n\t    \"media-return-to-realtime-button\", \"media-rewind-button\",\n\t    \"media-seek-back-button\", \"media-seek-forward-button\", \"media-slider\",\n\t    \"media-sliderthumb\", \"media-time-remaining-display\", \"media-volume-slider\",\n\t    \"media-volume-slider-container\", \"media-volume-sliderthumb\", \"medium\",\n\t    \"menu\", \"menulist\", \"menulist-button\", \"menulist-text\",\n\t    \"menulist-textfield\", \"menutext\", \"message-box\", \"middle\", \"min-intrinsic\",\n\t    \"mix\", \"mongolian\", \"monospace\", \"move\", \"multiple\", \"myanmar\", \"n-resize\",\n\t    \"narrower\", \"ne-resize\", \"nesw-resize\", \"no-close-quote\", \"no-drop\",\n\t    \"no-open-quote\", \"no-repeat\", \"none\", \"normal\", \"not-allowed\", \"nowrap\",\n\t    \"ns-resize\", \"numbers\", \"numeric\", \"nw-resize\", \"nwse-resize\", \"oblique\", \"octal\", \"open-quote\",\n\t    \"optimizeLegibility\", \"optimizeSpeed\", \"oriya\", \"oromo\", \"outset\",\n\t    \"outside\", \"outside-shape\", \"overlay\", \"overline\", \"padding\", \"padding-box\",\n\t    \"painted\", \"page\", \"paused\", \"persian\", \"perspective\", \"plus-darker\", \"plus-lighter\",\n\t    \"pointer\", \"polygon\", \"portrait\", \"pre\", \"pre-line\", \"pre-wrap\", \"preserve-3d\",\n\t    \"progress\", \"push-button\", \"radial-gradient\", \"radio\", \"read-only\",\n\t    \"read-write\", \"read-write-plaintext-only\", \"rectangle\", \"region\",\n\t    \"relative\", \"repeat\", \"repeating-linear-gradient\",\n\t    \"repeating-radial-gradient\", \"repeat-x\", \"repeat-y\", \"reset\", \"reverse\",\n\t    \"rgb\", \"rgba\", \"ridge\", \"right\", \"rotate\", \"rotate3d\", \"rotateX\", \"rotateY\",\n\t    \"rotateZ\", \"round\", \"row\", \"row-resize\", \"row-reverse\", \"rtl\", \"run-in\", \"running\",\n\t    \"s-resize\", \"sans-serif\", \"scale\", \"scale3d\", \"scaleX\", \"scaleY\", \"scaleZ\",\n\t    \"scroll\", \"scrollbar\", \"se-resize\", \"searchfield\",\n\t    \"searchfield-cancel-button\", \"searchfield-decoration\",\n\t    \"searchfield-results-button\", \"searchfield-results-decoration\",\n\t    \"semi-condensed\", \"semi-expanded\", \"separate\", \"serif\", \"show\", \"sidama\",\n\t    \"simp-chinese-formal\", \"simp-chinese-informal\", \"single\",\n\t    \"skew\", \"skewX\", \"skewY\", \"skip-white-space\", \"slide\", \"slider-horizontal\",\n\t    \"slider-vertical\", \"sliderthumb-horizontal\", \"sliderthumb-vertical\", \"slow\",\n\t    \"small\", \"small-caps\", \"small-caption\", \"smaller\", \"solid\", \"somali\",\n\t    \"source-atop\", \"source-in\", \"source-out\", \"source-over\", \"space\", \"space-around\", \"space-between\", \"spell-out\", \"square\",\n\t    \"square-button\", \"start\", \"static\", \"status-bar\", \"stretch\", \"stroke\", \"sub\",\n\t    \"subpixel-antialiased\", \"super\", \"sw-resize\", \"symbolic\", \"symbols\", \"table\",\n\t    \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\",\n\t    \"table-footer-group\", \"table-header-group\", \"table-row\", \"table-row-group\",\n\t    \"tamil\",\n\t    \"telugu\", \"text\", \"text-bottom\", \"text-top\", \"textarea\", \"textfield\", \"thai\",\n\t    \"thick\", \"thin\", \"threeddarkshadow\", \"threedface\", \"threedhighlight\",\n\t    \"threedlightshadow\", \"threedshadow\", \"tibetan\", \"tigre\", \"tigrinya-er\",\n\t    \"tigrinya-er-abegede\", \"tigrinya-et\", \"tigrinya-et-abegede\", \"to\", \"top\",\n\t    \"trad-chinese-formal\", \"trad-chinese-informal\",\n\t    \"translate\", \"translate3d\", \"translateX\", \"translateY\", \"translateZ\",\n\t    \"transparent\", \"ultra-condensed\", \"ultra-expanded\", \"underline\", \"up\",\n\t    \"upper-alpha\", \"upper-armenian\", \"upper-greek\", \"upper-hexadecimal\",\n\t    \"upper-latin\", \"upper-norwegian\", \"upper-roman\", \"uppercase\", \"urdu\", \"url\",\n\t    \"var\", \"vertical\", \"vertical-text\", \"visible\", \"visibleFill\", \"visiblePainted\",\n\t    \"visibleStroke\", \"visual\", \"w-resize\", \"wait\", \"wave\", \"wider\",\n\t    \"window\", \"windowframe\", \"windowtext\", \"words\", \"wrap\", \"wrap-reverse\", \"x-large\", \"x-small\", \"xor\",\n\t    \"xx-large\", \"xx-small\"\n\t  ], valueKeywords = keySet(valueKeywords_);\n\t\n\t  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)\n\t    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)\n\t    .concat(valueKeywords_);\n\t  CodeMirror.registerHelper(\"hintWords\", \"css\", allWords);\n\t\n\t  function tokenCComment(stream, state) {\n\t    var maybeEnd = false, ch;\n\t    while ((ch = stream.next()) != null) {\n\t      if (maybeEnd && ch == \"/\") {\n\t        state.tokenize = null;\n\t        break;\n\t      }\n\t      maybeEnd = (ch == \"*\");\n\t    }\n\t    return [\"comment\", \"comment\"];\n\t  }\n\t\n\t  CodeMirror.defineMIME(\"text/css\", {\n\t    documentTypes: documentTypes,\n\t    mediaTypes: mediaTypes,\n\t    mediaFeatures: mediaFeatures,\n\t    mediaValueKeywords: mediaValueKeywords,\n\t    propertyKeywords: propertyKeywords,\n\t    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n\t    fontProperties: fontProperties,\n\t    counterDescriptors: counterDescriptors,\n\t    colorKeywords: colorKeywords,\n\t    valueKeywords: valueKeywords,\n\t    tokenHooks: {\n\t      \"/\": function(stream, state) {\n\t        if (!stream.eat(\"*\")) return false;\n\t        state.tokenize = tokenCComment;\n\t        return tokenCComment(stream, state);\n\t      }\n\t    },\n\t    name: \"css\"\n\t  });\n\t\n\t  CodeMirror.defineMIME(\"text/x-scss\", {\n\t    mediaTypes: mediaTypes,\n\t    mediaFeatures: mediaFeatures,\n\t    mediaValueKeywords: mediaValueKeywords,\n\t    propertyKeywords: propertyKeywords,\n\t    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n\t    colorKeywords: colorKeywords,\n\t    valueKeywords: valueKeywords,\n\t    fontProperties: fontProperties,\n\t    allowNested: true,\n\t    tokenHooks: {\n\t      \"/\": function(stream, state) {\n\t        if (stream.eat(\"/\")) {\n\t          stream.skipToEnd();\n\t          return [\"comment\", \"comment\"];\n\t        } else if (stream.eat(\"*\")) {\n\t          state.tokenize = tokenCComment;\n\t          return tokenCComment(stream, state);\n\t        } else {\n\t          return [\"operator\", \"operator\"];\n\t        }\n\t      },\n\t      \":\": function(stream) {\n\t        if (stream.match(/\\s*\\{/))\n\t          return [null, \"{\"];\n\t        return false;\n\t      },\n\t      \"$\": function(stream) {\n\t        stream.match(/^[\\w-]+/);\n\t        if (stream.match(/^\\s*:/, false))\n\t          return [\"variable-2\", \"variable-definition\"];\n\t        return [\"variable-2\", \"variable\"];\n\t      },\n\t      \"#\": function(stream) {\n\t        if (!stream.eat(\"{\")) return false;\n\t        return [null, \"interpolation\"];\n\t      }\n\t    },\n\t    name: \"css\",\n\t    helperType: \"scss\"\n\t  });\n\t\n\t  CodeMirror.defineMIME(\"text/x-less\", {\n\t    mediaTypes: mediaTypes,\n\t    mediaFeatures: mediaFeatures,\n\t    mediaValueKeywords: mediaValueKeywords,\n\t    propertyKeywords: propertyKeywords,\n\t    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n\t    colorKeywords: colorKeywords,\n\t    valueKeywords: valueKeywords,\n\t    fontProperties: fontProperties,\n\t    allowNested: true,\n\t    tokenHooks: {\n\t      \"/\": function(stream, state) {\n\t        if (stream.eat(\"/\")) {\n\t          stream.skipToEnd();\n\t          return [\"comment\", \"comment\"];\n\t        } else if (stream.eat(\"*\")) {\n\t          state.tokenize = tokenCComment;\n\t          return tokenCComment(stream, state);\n\t        } else {\n\t          return [\"operator\", \"operator\"];\n\t        }\n\t      },\n\t      \"@\": function(stream) {\n\t        if (stream.eat(\"{\")) return [null, \"interpolation\"];\n\t        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/, false)) return false;\n\t        stream.eatWhile(/[\\w\\\\\\-]/);\n\t        if (stream.match(/^\\s*:/, false))\n\t          return [\"variable-2\", \"variable-definition\"];\n\t        return [\"variable-2\", \"variable\"];\n\t      },\n\t      \"&\": function() {\n\t        return [\"atom\", \"atom\"];\n\t      }\n\t    },\n\t    name: \"css\",\n\t    helperType: \"less\"\n\t  });\n\t\n\t  CodeMirror.defineMIME(\"text/x-gss\", {\n\t    documentTypes: documentTypes,\n\t    mediaTypes: mediaTypes,\n\t    mediaFeatures: mediaFeatures,\n\t    propertyKeywords: propertyKeywords,\n\t    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n\t    fontProperties: fontProperties,\n\t    counterDescriptors: counterDescriptors,\n\t    colorKeywords: colorKeywords,\n\t    valueKeywords: valueKeywords,\n\t    supportsAtComponent: true,\n\t    tokenHooks: {\n\t      \"/\": function(stream, state) {\n\t        if (!stream.eat(\"*\")) return false;\n\t        state.tokenize = tokenCComment;\n\t        return tokenCComment(stream, state);\n\t      }\n\t    },\n\t    name: \"css\",\n\t    helperType: \"gss\"\n\t  });\n\t\n\t});\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* jshint evil: true */\n\t\n\t/**\n\t* Code inspired and taken from https://babeljs.io/scripts/repl.js.\n\t*/\n\t// import 'script!babel-polyfill/dist/polyfill';\n\t// import babel from 'script!babel-core/browser';\n\t\n\t// import $ from 'jquery';\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _underscore = __webpack_require__(19);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tvar _codemirrorLibCodemirror = __webpack_require__(13);\n\t\n\tvar _codemirrorLibCodemirror2 = _interopRequireDefault(_codemirrorLibCodemirror);\n\t\n\t__webpack_require__(20);\n\t\n\t__webpack_require__(21);\n\t\n\t// babel is provided in an external script tag\n\t\n\tvar BabelREPL = (function () {\n\t  function BabelREPL($context) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, BabelREPL);\n\t\n\t    this.$context = $context;\n\t\n\t    this.$consoleReporter = this.$context.find('.js-console');\n\t    this.$output = $context.find('.js-output');\n\t    this.$toggleFullScreen = $context.find('.js-toggle-fs');\n\t\n\t    // Create the CodeMirror editors which give us nice things\n\t    // like line number, key maps, and syntax highlighting.\n\t    this.editorCompiled = _codemirrorLibCodemirror2['default'].fromTextArea($context.find('.js-demo-compiled')[0], {\n\t      mode: \"javascript\",\n\t      lineNumbers: true,\n\t      matchBrackets: true,\n\t      tabSize: 2,\n\t      readOnly: true,\n\t      theme: 'seti',\n\t      keyMap: 'sublime'\n\t    });\n\t\n\t    this.editor = _codemirrorLibCodemirror2['default'].fromTextArea($context.find('.js-demo-text')[0], {\n\t      mode: \"javascript\",\n\t      lineNumbers: true,\n\t      matchBrackets: true,\n\t      tabSize: 2,\n\t      theme: 'seti',\n\t      keyMap: 'sublime'\n\t    });\n\t\n\t    // Compile what's already in there.\n\t    this.compile(this.editor.getValue());\n\t\n\t    // Attach to change event so we can recompile each time something\n\t    // changes.\n\t    this.editor.on('change', _underscore2['default'].debounce(this.handleCodeChange, 500).bind(this));\n\t\n\t    this.$toggleFullScreen.click(function () {\n\t      $context.toggleClass('is-full');\n\t\n\t      if ($context.hasClass('is-full')) {\n\t        _this.$toggleFullScreen.text('Exit Full Screen');\n\t      } else {\n\t        _this.$toggleFullScreen.text('Full Screen');\n\t      }\n\t\n\t      _this.editor.refresh();\n\t      _this.editorCompiled.refresh();\n\t    });\n\t  }\n\t\n\t  // The following methods are taken from Babel's REPL\n\t  // code, though many of them have been modified to\n\t  // fit our needs.\n\t\n\t  _createClass(BabelREPL, [{\n\t    key: 'refresh',\n\t    value: function refresh() {\n\t      // console.log('refresh');\n\t      this.editor.refresh();\n\t      this.editorCompiled.refresh();\n\t    }\n\t  }, {\n\t    key: 'handleCodeChange',\n\t    value: function handleCodeChange(instance, changeObj) {\n\t      this.compile(instance.getValue());\n\t    }\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      this.editorCompiled.setValue('');\n\t      this.$output.empty();\n\t      this.$consoleReporter.empty();\n\t    }\n\t  }, {\n\t    key: 'compile',\n\t    value: function compile(code) {\n\t      var transformed = undefined;\n\t\n\t      // Clear our output and console each time we recompile.\n\t      this.clear();\n\t\n\t      try {\n\t        // console.log('code', code);\n\t        transformed = babel.transform(code, {});\n\t        //console.log('past transform');\n\t        this.editorCompiled.setValue(transformed.code);\n\t        //console.log('past setValue');\n\t        this.evaluate(transformed.code);\n\t        //console.log('past evaluate');\n\t      } catch (err) {\n\t        // console.log('ERROR thrown', transformed.code);\n\t        // don't throw it.. just output it\n\t        this.$output.text(err.message);\n\t        this.$consoleReporter.text(err.message);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'evaluate',\n\t    value: function evaluate(code) {\n\t      if (typeof this.capturingConsole === 'undefined') {\n\t        // extend console\n\t        this.capturingConsole = Object.create(console);\n\t      }\n\t      var capturingConsole = this.capturingConsole;\n\t\n\t      var $consoleReporter = this.$consoleReporter;\n\t      var buffer = [];\n\t      var error = undefined;\n\t      var done = false;\n\t\n\t      function flush() {\n\t        //console.log('buffer', buffer);\n\t        $consoleReporter.text(buffer.join('\\n'));\n\t      }\n\t\n\t      function write(data) {\n\t        buffer.push(data);\n\t        if (done) {\n\t          flush();\n\t        }\n\t      }\n\t\n\t      capturingConsole.clear = function () {\n\t        buffer = [];\n\t        flush();\n\t      };\n\t\n\t      capturingConsole.error = function () {\n\t        error = true;\n\t        capturingConsole.log.apply(capturingConsole, arguments);\n\t      };\n\t\n\t      capturingConsole.log = capturingConsole.info = capturingConsole.debug = function () {\n\t        if (this !== capturingConsole) {\n\t          return;\n\t        }\n\t\n\t        var args = Array.prototype.slice.call(arguments);\n\t        Function.prototype.apply.call(console.log, console, args);\n\t\n\t        var logs = args.reduce(function (logs, log) {\n\t          console.log('log', log);\n\t          if (typeof log === 'string') {\n\t            // console.log('string');\n\t            logs.push(log);\n\t          } else if (typeof log === 'symbol') {\n\t            logs.push(String(log));\n\t          } else if (log instanceof Function) {\n\t            // console.log('function');\n\t            logs.push(log.toString());\n\t          } else {\n\t            // console.log('log', log);\n\t            // We need to account for DOM elements.\n\t            if (typeof log !== 'undefined' && typeof log.outerHTML !== 'undefined') {\n\t              logs.push(log.outerHTML);\n\t            } else {\n\t              try {\n\t                log = JSON.stringify(log);\n\t              } catch (e) {}\n\t              logs.push(String(log));\n\t            }\n\t          }\n\t\n\t          return logs;\n\t        }, []);\n\t\n\t        // console.log('logs', logs);\n\t        write(logs.join('\\n'));\n\t      };\n\t\n\t      try {\n\t        // So this is actually running the code we obtained\n\t        // and setting the console used as the capturingConsole\n\t        // we created. It's cool because it gives us control\n\t        // over what to replace in our block of our code.\n\t        // (function(console, $$, code) {}(capturingConsole, this.$output));\n\t        new Function('console', '$$', 'require', code)(capturingConsole, this.$output, this.myRequire);\n\t      } catch (err) {\n\t        error = err;\n\t        buffer.push(err.message);\n\t      }\n\t\n\t      done = true;\n\t      flush();\n\t\n\t      if (error) {\n\t        throw error;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'myRequire',\n\t    value: function myRequire(id) {\n\t      return {\n\t        a: function a() {\n\t          return 'i am a';\n\t        },\n\t        b: function b() {\n\t          return 'i am beaver';\n\t        }\n\t      };\n\t    }\n\t  }]);\n\t\n\t  return BabelREPL;\n\t})();\n\t\n\texports['default'] = BabelREPL;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3\n\t//     http://underscorejs.org\n\t//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t//     Underscore may be freely distributed under the MIT license.\n\t\n\t(function() {\n\t\n\t  // Baseline setup\n\t  // --------------\n\t\n\t  // Establish the root object, `window` in the browser, or `exports` on the server.\n\t  var root = this;\n\t\n\t  // Save the previous value of the `_` variable.\n\t  var previousUnderscore = root._;\n\t\n\t  // Save bytes in the minified (but not gzipped) version:\n\t  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\t\n\t  // Create quick reference variables for speed access to core prototypes.\n\t  var\n\t    push             = ArrayProto.push,\n\t    slice            = ArrayProto.slice,\n\t    toString         = ObjProto.toString,\n\t    hasOwnProperty   = ObjProto.hasOwnProperty;\n\t\n\t  // All **ECMAScript 5** native function implementations that we hope to use\n\t  // are declared here.\n\t  var\n\t    nativeIsArray      = Array.isArray,\n\t    nativeKeys         = Object.keys,\n\t    nativeBind         = FuncProto.bind,\n\t    nativeCreate       = Object.create;\n\t\n\t  // Naked function reference for surrogate-prototype-swapping.\n\t  var Ctor = function(){};\n\t\n\t  // Create a safe reference to the Underscore object for use below.\n\t  var _ = function(obj) {\n\t    if (obj instanceof _) return obj;\n\t    if (!(this instanceof _)) return new _(obj);\n\t    this._wrapped = obj;\n\t  };\n\t\n\t  // Export the Underscore object for **Node.js**, with\n\t  // backwards-compatibility for the old `require()` API. If we're in\n\t  // the browser, add `_` as a global object.\n\t  if (true) {\n\t    if (typeof module !== 'undefined' && module.exports) {\n\t      exports = module.exports = _;\n\t    }\n\t    exports._ = _;\n\t  } else {\n\t    root._ = _;\n\t  }\n\t\n\t  // Current version.\n\t  _.VERSION = '1.8.3';\n\t\n\t  // Internal function that returns an efficient (for current engines) version\n\t  // of the passed-in callback, to be repeatedly applied in other Underscore\n\t  // functions.\n\t  var optimizeCb = function(func, context, argCount) {\n\t    if (context === void 0) return func;\n\t    switch (argCount == null ? 3 : argCount) {\n\t      case 1: return function(value) {\n\t        return func.call(context, value);\n\t      };\n\t      case 2: return function(value, other) {\n\t        return func.call(context, value, other);\n\t      };\n\t      case 3: return function(value, index, collection) {\n\t        return func.call(context, value, index, collection);\n\t      };\n\t      case 4: return function(accumulator, value, index, collection) {\n\t        return func.call(context, accumulator, value, index, collection);\n\t      };\n\t    }\n\t    return function() {\n\t      return func.apply(context, arguments);\n\t    };\n\t  };\n\t\n\t  // A mostly-internal function to generate callbacks that can be applied\n\t  // to each element in a collection, returning the desired result — either\n\t  // identity, an arbitrary callback, a property matcher, or a property accessor.\n\t  var cb = function(value, context, argCount) {\n\t    if (value == null) return _.identity;\n\t    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n\t    if (_.isObject(value)) return _.matcher(value);\n\t    return _.property(value);\n\t  };\n\t  _.iteratee = function(value, context) {\n\t    return cb(value, context, Infinity);\n\t  };\n\t\n\t  // An internal function for creating assigner functions.\n\t  var createAssigner = function(keysFunc, undefinedOnly) {\n\t    return function(obj) {\n\t      var length = arguments.length;\n\t      if (length < 2 || obj == null) return obj;\n\t      for (var index = 1; index < length; index++) {\n\t        var source = arguments[index],\n\t            keys = keysFunc(source),\n\t            l = keys.length;\n\t        for (var i = 0; i < l; i++) {\n\t          var key = keys[i];\n\t          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n\t        }\n\t      }\n\t      return obj;\n\t    };\n\t  };\n\t\n\t  // An internal function for creating a new object that inherits from another.\n\t  var baseCreate = function(prototype) {\n\t    if (!_.isObject(prototype)) return {};\n\t    if (nativeCreate) return nativeCreate(prototype);\n\t    Ctor.prototype = prototype;\n\t    var result = new Ctor;\n\t    Ctor.prototype = null;\n\t    return result;\n\t  };\n\t\n\t  var property = function(key) {\n\t    return function(obj) {\n\t      return obj == null ? void 0 : obj[key];\n\t    };\n\t  };\n\t\n\t  // Helper for collection methods to determine whether a collection\n\t  // should be iterated as an array or as an object\n\t  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n\t  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n\t  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\t  var getLength = property('length');\n\t  var isArrayLike = function(collection) {\n\t    var length = getLength(collection);\n\t    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n\t  };\n\t\n\t  // Collection Functions\n\t  // --------------------\n\t\n\t  // The cornerstone, an `each` implementation, aka `forEach`.\n\t  // Handles raw objects in addition to array-likes. Treats all\n\t  // sparse array-likes as if they were dense.\n\t  _.each = _.forEach = function(obj, iteratee, context) {\n\t    iteratee = optimizeCb(iteratee, context);\n\t    var i, length;\n\t    if (isArrayLike(obj)) {\n\t      for (i = 0, length = obj.length; i < length; i++) {\n\t        iteratee(obj[i], i, obj);\n\t      }\n\t    } else {\n\t      var keys = _.keys(obj);\n\t      for (i = 0, length = keys.length; i < length; i++) {\n\t        iteratee(obj[keys[i]], keys[i], obj);\n\t      }\n\t    }\n\t    return obj;\n\t  };\n\t\n\t  // Return the results of applying the iteratee to each element.\n\t  _.map = _.collect = function(obj, iteratee, context) {\n\t    iteratee = cb(iteratee, context);\n\t    var keys = !isArrayLike(obj) && _.keys(obj),\n\t        length = (keys || obj).length,\n\t        results = Array(length);\n\t    for (var index = 0; index < length; index++) {\n\t      var currentKey = keys ? keys[index] : index;\n\t      results[index] = iteratee(obj[currentKey], currentKey, obj);\n\t    }\n\t    return results;\n\t  };\n\t\n\t  // Create a reducing function iterating left or right.\n\t  function createReduce(dir) {\n\t    // Optimized iterator function as using arguments.length\n\t    // in the main function will deoptimize the, see #1991.\n\t    function iterator(obj, iteratee, memo, keys, index, length) {\n\t      for (; index >= 0 && index < length; index += dir) {\n\t        var currentKey = keys ? keys[index] : index;\n\t        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n\t      }\n\t      return memo;\n\t    }\n\t\n\t    return function(obj, iteratee, memo, context) {\n\t      iteratee = optimizeCb(iteratee, context, 4);\n\t      var keys = !isArrayLike(obj) && _.keys(obj),\n\t          length = (keys || obj).length,\n\t          index = dir > 0 ? 0 : length - 1;\n\t      // Determine the initial value if none is provided.\n\t      if (arguments.length < 3) {\n\t        memo = obj[keys ? keys[index] : index];\n\t        index += dir;\n\t      }\n\t      return iterator(obj, iteratee, memo, keys, index, length);\n\t    };\n\t  }\n\t\n\t  // **Reduce** builds up a single result from a list of values, aka `inject`,\n\t  // or `foldl`.\n\t  _.reduce = _.foldl = _.inject = createReduce(1);\n\t\n\t  // The right-associative version of reduce, also known as `foldr`.\n\t  _.reduceRight = _.foldr = createReduce(-1);\n\t\n\t  // Return the first value which passes a truth test. Aliased as `detect`.\n\t  _.find = _.detect = function(obj, predicate, context) {\n\t    var key;\n\t    if (isArrayLike(obj)) {\n\t      key = _.findIndex(obj, predicate, context);\n\t    } else {\n\t      key = _.findKey(obj, predicate, context);\n\t    }\n\t    if (key !== void 0 && key !== -1) return obj[key];\n\t  };\n\t\n\t  // Return all the elements that pass a truth test.\n\t  // Aliased as `select`.\n\t  _.filter = _.select = function(obj, predicate, context) {\n\t    var results = [];\n\t    predicate = cb(predicate, context);\n\t    _.each(obj, function(value, index, list) {\n\t      if (predicate(value, index, list)) results.push(value);\n\t    });\n\t    return results;\n\t  };\n\t\n\t  // Return all the elements for which a truth test fails.\n\t  _.reject = function(obj, predicate, context) {\n\t    return _.filter(obj, _.negate(cb(predicate)), context);\n\t  };\n\t\n\t  // Determine whether all of the elements match a truth test.\n\t  // Aliased as `all`.\n\t  _.every = _.all = function(obj, predicate, context) {\n\t    predicate = cb(predicate, context);\n\t    var keys = !isArrayLike(obj) && _.keys(obj),\n\t        length = (keys || obj).length;\n\t    for (var index = 0; index < length; index++) {\n\t      var currentKey = keys ? keys[index] : index;\n\t      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n\t    }\n\t    return true;\n\t  };\n\t\n\t  // Determine if at least one element in the object matches a truth test.\n\t  // Aliased as `any`.\n\t  _.some = _.any = function(obj, predicate, context) {\n\t    predicate = cb(predicate, context);\n\t    var keys = !isArrayLike(obj) && _.keys(obj),\n\t        length = (keys || obj).length;\n\t    for (var index = 0; index < length; index++) {\n\t      var currentKey = keys ? keys[index] : index;\n\t      if (predicate(obj[currentKey], currentKey, obj)) return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  // Determine if the array or object contains a given item (using `===`).\n\t  // Aliased as `includes` and `include`.\n\t  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n\t    if (!isArrayLike(obj)) obj = _.values(obj);\n\t    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n\t    return _.indexOf(obj, item, fromIndex) >= 0;\n\t  };\n\t\n\t  // Invoke a method (with arguments) on every item in a collection.\n\t  _.invoke = function(obj, method) {\n\t    var args = slice.call(arguments, 2);\n\t    var isFunc = _.isFunction(method);\n\t    return _.map(obj, function(value) {\n\t      var func = isFunc ? method : value[method];\n\t      return func == null ? func : func.apply(value, args);\n\t    });\n\t  };\n\t\n\t  // Convenience version of a common use case of `map`: fetching a property.\n\t  _.pluck = function(obj, key) {\n\t    return _.map(obj, _.property(key));\n\t  };\n\t\n\t  // Convenience version of a common use case of `filter`: selecting only objects\n\t  // containing specific `key:value` pairs.\n\t  _.where = function(obj, attrs) {\n\t    return _.filter(obj, _.matcher(attrs));\n\t  };\n\t\n\t  // Convenience version of a common use case of `find`: getting the first object\n\t  // containing specific `key:value` pairs.\n\t  _.findWhere = function(obj, attrs) {\n\t    return _.find(obj, _.matcher(attrs));\n\t  };\n\t\n\t  // Return the maximum element (or element-based computation).\n\t  _.max = function(obj, iteratee, context) {\n\t    var result = -Infinity, lastComputed = -Infinity,\n\t        value, computed;\n\t    if (iteratee == null && obj != null) {\n\t      obj = isArrayLike(obj) ? obj : _.values(obj);\n\t      for (var i = 0, length = obj.length; i < length; i++) {\n\t        value = obj[i];\n\t        if (value > result) {\n\t          result = value;\n\t        }\n\t      }\n\t    } else {\n\t      iteratee = cb(iteratee, context);\n\t      _.each(obj, function(value, index, list) {\n\t        computed = iteratee(value, index, list);\n\t        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n\t          result = value;\n\t          lastComputed = computed;\n\t        }\n\t      });\n\t    }\n\t    return result;\n\t  };\n\t\n\t  // Return the minimum element (or element-based computation).\n\t  _.min = function(obj, iteratee, context) {\n\t    var result = Infinity, lastComputed = Infinity,\n\t        value, computed;\n\t    if (iteratee == null && obj != null) {\n\t      obj = isArrayLike(obj) ? obj : _.values(obj);\n\t      for (var i = 0, length = obj.length; i < length; i++) {\n\t        value = obj[i];\n\t        if (value < result) {\n\t          result = value;\n\t        }\n\t      }\n\t    } else {\n\t      iteratee = cb(iteratee, context);\n\t      _.each(obj, function(value, index, list) {\n\t        computed = iteratee(value, index, list);\n\t        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n\t          result = value;\n\t          lastComputed = computed;\n\t        }\n\t      });\n\t    }\n\t    return result;\n\t  };\n\t\n\t  // Shuffle a collection, using the modern version of the\n\t  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n\t  _.shuffle = function(obj) {\n\t    var set = isArrayLike(obj) ? obj : _.values(obj);\n\t    var length = set.length;\n\t    var shuffled = Array(length);\n\t    for (var index = 0, rand; index < length; index++) {\n\t      rand = _.random(0, index);\n\t      if (rand !== index) shuffled[index] = shuffled[rand];\n\t      shuffled[rand] = set[index];\n\t    }\n\t    return shuffled;\n\t  };\n\t\n\t  // Sample **n** random values from a collection.\n\t  // If **n** is not specified, returns a single random element.\n\t  // The internal `guard` argument allows it to work with `map`.\n\t  _.sample = function(obj, n, guard) {\n\t    if (n == null || guard) {\n\t      if (!isArrayLike(obj)) obj = _.values(obj);\n\t      return obj[_.random(obj.length - 1)];\n\t    }\n\t    return _.shuffle(obj).slice(0, Math.max(0, n));\n\t  };\n\t\n\t  // Sort the object's values by a criterion produced by an iteratee.\n\t  _.sortBy = function(obj, iteratee, context) {\n\t    iteratee = cb(iteratee, context);\n\t    return _.pluck(_.map(obj, function(value, index, list) {\n\t      return {\n\t        value: value,\n\t        index: index,\n\t        criteria: iteratee(value, index, list)\n\t      };\n\t    }).sort(function(left, right) {\n\t      var a = left.criteria;\n\t      var b = right.criteria;\n\t      if (a !== b) {\n\t        if (a > b || a === void 0) return 1;\n\t        if (a < b || b === void 0) return -1;\n\t      }\n\t      return left.index - right.index;\n\t    }), 'value');\n\t  };\n\t\n\t  // An internal function used for aggregate \"group by\" operations.\n\t  var group = function(behavior) {\n\t    return function(obj, iteratee, context) {\n\t      var result = {};\n\t      iteratee = cb(iteratee, context);\n\t      _.each(obj, function(value, index) {\n\t        var key = iteratee(value, index, obj);\n\t        behavior(result, value, key);\n\t      });\n\t      return result;\n\t    };\n\t  };\n\t\n\t  // Groups the object's values by a criterion. Pass either a string attribute\n\t  // to group by, or a function that returns the criterion.\n\t  _.groupBy = group(function(result, value, key) {\n\t    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n\t  });\n\t\n\t  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n\t  // when you know that your index values will be unique.\n\t  _.indexBy = group(function(result, value, key) {\n\t    result[key] = value;\n\t  });\n\t\n\t  // Counts instances of an object that group by a certain criterion. Pass\n\t  // either a string attribute to count by, or a function that returns the\n\t  // criterion.\n\t  _.countBy = group(function(result, value, key) {\n\t    if (_.has(result, key)) result[key]++; else result[key] = 1;\n\t  });\n\t\n\t  // Safely create a real, live array from anything iterable.\n\t  _.toArray = function(obj) {\n\t    if (!obj) return [];\n\t    if (_.isArray(obj)) return slice.call(obj);\n\t    if (isArrayLike(obj)) return _.map(obj, _.identity);\n\t    return _.values(obj);\n\t  };\n\t\n\t  // Return the number of elements in an object.\n\t  _.size = function(obj) {\n\t    if (obj == null) return 0;\n\t    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n\t  };\n\t\n\t  // Split a collection into two arrays: one whose elements all satisfy the given\n\t  // predicate, and one whose elements all do not satisfy the predicate.\n\t  _.partition = function(obj, predicate, context) {\n\t    predicate = cb(predicate, context);\n\t    var pass = [], fail = [];\n\t    _.each(obj, function(value, key, obj) {\n\t      (predicate(value, key, obj) ? pass : fail).push(value);\n\t    });\n\t    return [pass, fail];\n\t  };\n\t\n\t  // Array Functions\n\t  // ---------------\n\t\n\t  // Get the first element of an array. Passing **n** will return the first N\n\t  // values in the array. Aliased as `head` and `take`. The **guard** check\n\t  // allows it to work with `_.map`.\n\t  _.first = _.head = _.take = function(array, n, guard) {\n\t    if (array == null) return void 0;\n\t    if (n == null || guard) return array[0];\n\t    return _.initial(array, array.length - n);\n\t  };\n\t\n\t  // Returns everything but the last entry of the array. Especially useful on\n\t  // the arguments object. Passing **n** will return all the values in\n\t  // the array, excluding the last N.\n\t  _.initial = function(array, n, guard) {\n\t    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n\t  };\n\t\n\t  // Get the last element of an array. Passing **n** will return the last N\n\t  // values in the array.\n\t  _.last = function(array, n, guard) {\n\t    if (array == null) return void 0;\n\t    if (n == null || guard) return array[array.length - 1];\n\t    return _.rest(array, Math.max(0, array.length - n));\n\t  };\n\t\n\t  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n\t  // Especially useful on the arguments object. Passing an **n** will return\n\t  // the rest N values in the array.\n\t  _.rest = _.tail = _.drop = function(array, n, guard) {\n\t    return slice.call(array, n == null || guard ? 1 : n);\n\t  };\n\t\n\t  // Trim out all falsy values from an array.\n\t  _.compact = function(array) {\n\t    return _.filter(array, _.identity);\n\t  };\n\t\n\t  // Internal implementation of a recursive `flatten` function.\n\t  var flatten = function(input, shallow, strict, startIndex) {\n\t    var output = [], idx = 0;\n\t    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n\t      var value = input[i];\n\t      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n\t        //flatten current level of array or arguments object\n\t        if (!shallow) value = flatten(value, shallow, strict);\n\t        var j = 0, len = value.length;\n\t        output.length += len;\n\t        while (j < len) {\n\t          output[idx++] = value[j++];\n\t        }\n\t      } else if (!strict) {\n\t        output[idx++] = value;\n\t      }\n\t    }\n\t    return output;\n\t  };\n\t\n\t  // Flatten out an array, either recursively (by default), or just one level.\n\t  _.flatten = function(array, shallow) {\n\t    return flatten(array, shallow, false);\n\t  };\n\t\n\t  // Return a version of the array that does not contain the specified value(s).\n\t  _.without = function(array) {\n\t    return _.difference(array, slice.call(arguments, 1));\n\t  };\n\t\n\t  // Produce a duplicate-free version of the array. If the array has already\n\t  // been sorted, you have the option of using a faster algorithm.\n\t  // Aliased as `unique`.\n\t  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n\t    if (!_.isBoolean(isSorted)) {\n\t      context = iteratee;\n\t      iteratee = isSorted;\n\t      isSorted = false;\n\t    }\n\t    if (iteratee != null) iteratee = cb(iteratee, context);\n\t    var result = [];\n\t    var seen = [];\n\t    for (var i = 0, length = getLength(array); i < length; i++) {\n\t      var value = array[i],\n\t          computed = iteratee ? iteratee(value, i, array) : value;\n\t      if (isSorted) {\n\t        if (!i || seen !== computed) result.push(value);\n\t        seen = computed;\n\t      } else if (iteratee) {\n\t        if (!_.contains(seen, computed)) {\n\t          seen.push(computed);\n\t          result.push(value);\n\t        }\n\t      } else if (!_.contains(result, value)) {\n\t        result.push(value);\n\t      }\n\t    }\n\t    return result;\n\t  };\n\t\n\t  // Produce an array that contains the union: each distinct element from all of\n\t  // the passed-in arrays.\n\t  _.union = function() {\n\t    return _.uniq(flatten(arguments, true, true));\n\t  };\n\t\n\t  // Produce an array that contains every item shared between all the\n\t  // passed-in arrays.\n\t  _.intersection = function(array) {\n\t    var result = [];\n\t    var argsLength = arguments.length;\n\t    for (var i = 0, length = getLength(array); i < length; i++) {\n\t      var item = array[i];\n\t      if (_.contains(result, item)) continue;\n\t      for (var j = 1; j < argsLength; j++) {\n\t        if (!_.contains(arguments[j], item)) break;\n\t      }\n\t      if (j === argsLength) result.push(item);\n\t    }\n\t    return result;\n\t  };\n\t\n\t  // Take the difference between one array and a number of other arrays.\n\t  // Only the elements present in just the first array will remain.\n\t  _.difference = function(array) {\n\t    var rest = flatten(arguments, true, true, 1);\n\t    return _.filter(array, function(value){\n\t      return !_.contains(rest, value);\n\t    });\n\t  };\n\t\n\t  // Zip together multiple lists into a single array -- elements that share\n\t  // an index go together.\n\t  _.zip = function() {\n\t    return _.unzip(arguments);\n\t  };\n\t\n\t  // Complement of _.zip. Unzip accepts an array of arrays and groups\n\t  // each array's elements on shared indices\n\t  _.unzip = function(array) {\n\t    var length = array && _.max(array, getLength).length || 0;\n\t    var result = Array(length);\n\t\n\t    for (var index = 0; index < length; index++) {\n\t      result[index] = _.pluck(array, index);\n\t    }\n\t    return result;\n\t  };\n\t\n\t  // Converts lists into objects. Pass either a single array of `[key, value]`\n\t  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n\t  // the corresponding values.\n\t  _.object = function(list, values) {\n\t    var result = {};\n\t    for (var i = 0, length = getLength(list); i < length; i++) {\n\t      if (values) {\n\t        result[list[i]] = values[i];\n\t      } else {\n\t        result[list[i][0]] = list[i][1];\n\t      }\n\t    }\n\t    return result;\n\t  };\n\t\n\t  // Generator function to create the findIndex and findLastIndex functions\n\t  function createPredicateIndexFinder(dir) {\n\t    return function(array, predicate, context) {\n\t      predicate = cb(predicate, context);\n\t      var length = getLength(array);\n\t      var index = dir > 0 ? 0 : length - 1;\n\t      for (; index >= 0 && index < length; index += dir) {\n\t        if (predicate(array[index], index, array)) return index;\n\t      }\n\t      return -1;\n\t    };\n\t  }\n\t\n\t  // Returns the first index on an array-like that passes a predicate test\n\t  _.findIndex = createPredicateIndexFinder(1);\n\t  _.findLastIndex = createPredicateIndexFinder(-1);\n\t\n\t  // Use a comparator function to figure out the smallest index at which\n\t  // an object should be inserted so as to maintain order. Uses binary search.\n\t  _.sortedIndex = function(array, obj, iteratee, context) {\n\t    iteratee = cb(iteratee, context, 1);\n\t    var value = iteratee(obj);\n\t    var low = 0, high = getLength(array);\n\t    while (low < high) {\n\t      var mid = Math.floor((low + high) / 2);\n\t      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n\t    }\n\t    return low;\n\t  };\n\t\n\t  // Generator function to create the indexOf and lastIndexOf functions\n\t  function createIndexFinder(dir, predicateFind, sortedIndex) {\n\t    return function(array, item, idx) {\n\t      var i = 0, length = getLength(array);\n\t      if (typeof idx == 'number') {\n\t        if (dir > 0) {\n\t            i = idx >= 0 ? idx : Math.max(idx + length, i);\n\t        } else {\n\t            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n\t        }\n\t      } else if (sortedIndex && idx && length) {\n\t        idx = sortedIndex(array, item);\n\t        return array[idx] === item ? idx : -1;\n\t      }\n\t      if (item !== item) {\n\t        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n\t        return idx >= 0 ? idx + i : -1;\n\t      }\n\t      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n\t        if (array[idx] === item) return idx;\n\t      }\n\t      return -1;\n\t    };\n\t  }\n\t\n\t  // Return the position of the first occurrence of an item in an array,\n\t  // or -1 if the item is not included in the array.\n\t  // If the array is large and already in sort order, pass `true`\n\t  // for **isSorted** to use binary search.\n\t  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n\t  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\t\n\t  // Generate an integer Array containing an arithmetic progression. A port of\n\t  // the native Python `range()` function. See\n\t  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n\t  _.range = function(start, stop, step) {\n\t    if (stop == null) {\n\t      stop = start || 0;\n\t      start = 0;\n\t    }\n\t    step = step || 1;\n\t\n\t    var length = Math.max(Math.ceil((stop - start) / step), 0);\n\t    var range = Array(length);\n\t\n\t    for (var idx = 0; idx < length; idx++, start += step) {\n\t      range[idx] = start;\n\t    }\n\t\n\t    return range;\n\t  };\n\t\n\t  // Function (ahem) Functions\n\t  // ------------------\n\t\n\t  // Determines whether to execute a function as a constructor\n\t  // or a normal function with the provided arguments\n\t  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n\t    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n\t    var self = baseCreate(sourceFunc.prototype);\n\t    var result = sourceFunc.apply(self, args);\n\t    if (_.isObject(result)) return result;\n\t    return self;\n\t  };\n\t\n\t  // Create a function bound to a given object (assigning `this`, and arguments,\n\t  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n\t  // available.\n\t  _.bind = function(func, context) {\n\t    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n\t    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n\t    var args = slice.call(arguments, 2);\n\t    var bound = function() {\n\t      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n\t    };\n\t    return bound;\n\t  };\n\t\n\t  // Partially apply a function by creating a version that has had some of its\n\t  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n\t  // as a placeholder, allowing any combination of arguments to be pre-filled.\n\t  _.partial = function(func) {\n\t    var boundArgs = slice.call(arguments, 1);\n\t    var bound = function() {\n\t      var position = 0, length = boundArgs.length;\n\t      var args = Array(length);\n\t      for (var i = 0; i < length; i++) {\n\t        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n\t      }\n\t      while (position < arguments.length) args.push(arguments[position++]);\n\t      return executeBound(func, bound, this, this, args);\n\t    };\n\t    return bound;\n\t  };\n\t\n\t  // Bind a number of an object's methods to that object. Remaining arguments\n\t  // are the method names to be bound. Useful for ensuring that all callbacks\n\t  // defined on an object belong to it.\n\t  _.bindAll = function(obj) {\n\t    var i, length = arguments.length, key;\n\t    if (length <= 1) throw new Error('bindAll must be passed function names');\n\t    for (i = 1; i < length; i++) {\n\t      key = arguments[i];\n\t      obj[key] = _.bind(obj[key], obj);\n\t    }\n\t    return obj;\n\t  };\n\t\n\t  // Memoize an expensive function by storing its results.\n\t  _.memoize = function(func, hasher) {\n\t    var memoize = function(key) {\n\t      var cache = memoize.cache;\n\t      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n\t      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n\t      return cache[address];\n\t    };\n\t    memoize.cache = {};\n\t    return memoize;\n\t  };\n\t\n\t  // Delays a function for the given number of milliseconds, and then calls\n\t  // it with the arguments supplied.\n\t  _.delay = function(func, wait) {\n\t    var args = slice.call(arguments, 2);\n\t    return setTimeout(function(){\n\t      return func.apply(null, args);\n\t    }, wait);\n\t  };\n\t\n\t  // Defers a function, scheduling it to run after the current call stack has\n\t  // cleared.\n\t  _.defer = _.partial(_.delay, _, 1);\n\t\n\t  // Returns a function, that, when invoked, will only be triggered at most once\n\t  // during a given window of time. Normally, the throttled function will run\n\t  // as much as it can, without ever going more than once per `wait` duration;\n\t  // but if you'd like to disable the execution on the leading edge, pass\n\t  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n\t  _.throttle = function(func, wait, options) {\n\t    var context, args, result;\n\t    var timeout = null;\n\t    var previous = 0;\n\t    if (!options) options = {};\n\t    var later = function() {\n\t      previous = options.leading === false ? 0 : _.now();\n\t      timeout = null;\n\t      result = func.apply(context, args);\n\t      if (!timeout) context = args = null;\n\t    };\n\t    return function() {\n\t      var now = _.now();\n\t      if (!previous && options.leading === false) previous = now;\n\t      var remaining = wait - (now - previous);\n\t      context = this;\n\t      args = arguments;\n\t      if (remaining <= 0 || remaining > wait) {\n\t        if (timeout) {\n\t          clearTimeout(timeout);\n\t          timeout = null;\n\t        }\n\t        previous = now;\n\t        result = func.apply(context, args);\n\t        if (!timeout) context = args = null;\n\t      } else if (!timeout && options.trailing !== false) {\n\t        timeout = setTimeout(later, remaining);\n\t      }\n\t      return result;\n\t    };\n\t  };\n\t\n\t  // Returns a function, that, as long as it continues to be invoked, will not\n\t  // be triggered. The function will be called after it stops being called for\n\t  // N milliseconds. If `immediate` is passed, trigger the function on the\n\t  // leading edge, instead of the trailing.\n\t  _.debounce = function(func, wait, immediate) {\n\t    var timeout, args, context, timestamp, result;\n\t\n\t    var later = function() {\n\t      var last = _.now() - timestamp;\n\t\n\t      if (last < wait && last >= 0) {\n\t        timeout = setTimeout(later, wait - last);\n\t      } else {\n\t        timeout = null;\n\t        if (!immediate) {\n\t          result = func.apply(context, args);\n\t          if (!timeout) context = args = null;\n\t        }\n\t      }\n\t    };\n\t\n\t    return function() {\n\t      context = this;\n\t      args = arguments;\n\t      timestamp = _.now();\n\t      var callNow = immediate && !timeout;\n\t      if (!timeout) timeout = setTimeout(later, wait);\n\t      if (callNow) {\n\t        result = func.apply(context, args);\n\t        context = args = null;\n\t      }\n\t\n\t      return result;\n\t    };\n\t  };\n\t\n\t  // Returns the first function passed as an argument to the second,\n\t  // allowing you to adjust arguments, run code before and after, and\n\t  // conditionally execute the original function.\n\t  _.wrap = function(func, wrapper) {\n\t    return _.partial(wrapper, func);\n\t  };\n\t\n\t  // Returns a negated version of the passed-in predicate.\n\t  _.negate = function(predicate) {\n\t    return function() {\n\t      return !predicate.apply(this, arguments);\n\t    };\n\t  };\n\t\n\t  // Returns a function that is the composition of a list of functions, each\n\t  // consuming the return value of the function that follows.\n\t  _.compose = function() {\n\t    var args = arguments;\n\t    var start = args.length - 1;\n\t    return function() {\n\t      var i = start;\n\t      var result = args[start].apply(this, arguments);\n\t      while (i--) result = args[i].call(this, result);\n\t      return result;\n\t    };\n\t  };\n\t\n\t  // Returns a function that will only be executed on and after the Nth call.\n\t  _.after = function(times, func) {\n\t    return function() {\n\t      if (--times < 1) {\n\t        return func.apply(this, arguments);\n\t      }\n\t    };\n\t  };\n\t\n\t  // Returns a function that will only be executed up to (but not including) the Nth call.\n\t  _.before = function(times, func) {\n\t    var memo;\n\t    return function() {\n\t      if (--times > 0) {\n\t        memo = func.apply(this, arguments);\n\t      }\n\t      if (times <= 1) func = null;\n\t      return memo;\n\t    };\n\t  };\n\t\n\t  // Returns a function that will be executed at most one time, no matter how\n\t  // often you call it. Useful for lazy initialization.\n\t  _.once = _.partial(_.before, 2);\n\t\n\t  // Object Functions\n\t  // ----------------\n\t\n\t  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n\t  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n\t  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n\t                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\t\n\t  function collectNonEnumProps(obj, keys) {\n\t    var nonEnumIdx = nonEnumerableProps.length;\n\t    var constructor = obj.constructor;\n\t    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\t\n\t    // Constructor is a special case.\n\t    var prop = 'constructor';\n\t    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\t\n\t    while (nonEnumIdx--) {\n\t      prop = nonEnumerableProps[nonEnumIdx];\n\t      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n\t        keys.push(prop);\n\t      }\n\t    }\n\t  }\n\t\n\t  // Retrieve the names of an object's own properties.\n\t  // Delegates to **ECMAScript 5**'s native `Object.keys`\n\t  _.keys = function(obj) {\n\t    if (!_.isObject(obj)) return [];\n\t    if (nativeKeys) return nativeKeys(obj);\n\t    var keys = [];\n\t    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n\t    // Ahem, IE < 9.\n\t    if (hasEnumBug) collectNonEnumProps(obj, keys);\n\t    return keys;\n\t  };\n\t\n\t  // Retrieve all the property names of an object.\n\t  _.allKeys = function(obj) {\n\t    if (!_.isObject(obj)) return [];\n\t    var keys = [];\n\t    for (var key in obj) keys.push(key);\n\t    // Ahem, IE < 9.\n\t    if (hasEnumBug) collectNonEnumProps(obj, keys);\n\t    return keys;\n\t  };\n\t\n\t  // Retrieve the values of an object's properties.\n\t  _.values = function(obj) {\n\t    var keys = _.keys(obj);\n\t    var length = keys.length;\n\t    var values = Array(length);\n\t    for (var i = 0; i < length; i++) {\n\t      values[i] = obj[keys[i]];\n\t    }\n\t    return values;\n\t  };\n\t\n\t  // Returns the results of applying the iteratee to each element of the object\n\t  // In contrast to _.map it returns an object\n\t  _.mapObject = function(obj, iteratee, context) {\n\t    iteratee = cb(iteratee, context);\n\t    var keys =  _.keys(obj),\n\t          length = keys.length,\n\t          results = {},\n\t          currentKey;\n\t      for (var index = 0; index < length; index++) {\n\t        currentKey = keys[index];\n\t        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n\t      }\n\t      return results;\n\t  };\n\t\n\t  // Convert an object into a list of `[key, value]` pairs.\n\t  _.pairs = function(obj) {\n\t    var keys = _.keys(obj);\n\t    var length = keys.length;\n\t    var pairs = Array(length);\n\t    for (var i = 0; i < length; i++) {\n\t      pairs[i] = [keys[i], obj[keys[i]]];\n\t    }\n\t    return pairs;\n\t  };\n\t\n\t  // Invert the keys and values of an object. The values must be serializable.\n\t  _.invert = function(obj) {\n\t    var result = {};\n\t    var keys = _.keys(obj);\n\t    for (var i = 0, length = keys.length; i < length; i++) {\n\t      result[obj[keys[i]]] = keys[i];\n\t    }\n\t    return result;\n\t  };\n\t\n\t  // Return a sorted list of the function names available on the object.\n\t  // Aliased as `methods`\n\t  _.functions = _.methods = function(obj) {\n\t    var names = [];\n\t    for (var key in obj) {\n\t      if (_.isFunction(obj[key])) names.push(key);\n\t    }\n\t    return names.sort();\n\t  };\n\t\n\t  // Extend a given object with all the properties in passed-in object(s).\n\t  _.extend = createAssigner(_.allKeys);\n\t\n\t  // Assigns a given object with all the own properties in the passed-in object(s)\n\t  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n\t  _.extendOwn = _.assign = createAssigner(_.keys);\n\t\n\t  // Returns the first key on an object that passes a predicate test\n\t  _.findKey = function(obj, predicate, context) {\n\t    predicate = cb(predicate, context);\n\t    var keys = _.keys(obj), key;\n\t    for (var i = 0, length = keys.length; i < length; i++) {\n\t      key = keys[i];\n\t      if (predicate(obj[key], key, obj)) return key;\n\t    }\n\t  };\n\t\n\t  // Return a copy of the object only containing the whitelisted properties.\n\t  _.pick = function(object, oiteratee, context) {\n\t    var result = {}, obj = object, iteratee, keys;\n\t    if (obj == null) return result;\n\t    if (_.isFunction(oiteratee)) {\n\t      keys = _.allKeys(obj);\n\t      iteratee = optimizeCb(oiteratee, context);\n\t    } else {\n\t      keys = flatten(arguments, false, false, 1);\n\t      iteratee = function(value, key, obj) { return key in obj; };\n\t      obj = Object(obj);\n\t    }\n\t    for (var i = 0, length = keys.length; i < length; i++) {\n\t      var key = keys[i];\n\t      var value = obj[key];\n\t      if (iteratee(value, key, obj)) result[key] = value;\n\t    }\n\t    return result;\n\t  };\n\t\n\t   // Return a copy of the object without the blacklisted properties.\n\t  _.omit = function(obj, iteratee, context) {\n\t    if (_.isFunction(iteratee)) {\n\t      iteratee = _.negate(iteratee);\n\t    } else {\n\t      var keys = _.map(flatten(arguments, false, false, 1), String);\n\t      iteratee = function(value, key) {\n\t        return !_.contains(keys, key);\n\t      };\n\t    }\n\t    return _.pick(obj, iteratee, context);\n\t  };\n\t\n\t  // Fill in a given object with default properties.\n\t  _.defaults = createAssigner(_.allKeys, true);\n\t\n\t  // Creates an object that inherits from the given prototype object.\n\t  // If additional properties are provided then they will be added to the\n\t  // created object.\n\t  _.create = function(prototype, props) {\n\t    var result = baseCreate(prototype);\n\t    if (props) _.extendOwn(result, props);\n\t    return result;\n\t  };\n\t\n\t  // Create a (shallow-cloned) duplicate of an object.\n\t  _.clone = function(obj) {\n\t    if (!_.isObject(obj)) return obj;\n\t    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n\t  };\n\t\n\t  // Invokes interceptor with the obj, and then returns obj.\n\t  // The primary purpose of this method is to \"tap into\" a method chain, in\n\t  // order to perform operations on intermediate results within the chain.\n\t  _.tap = function(obj, interceptor) {\n\t    interceptor(obj);\n\t    return obj;\n\t  };\n\t\n\t  // Returns whether an object has a given set of `key:value` pairs.\n\t  _.isMatch = function(object, attrs) {\n\t    var keys = _.keys(attrs), length = keys.length;\n\t    if (object == null) return !length;\n\t    var obj = Object(object);\n\t    for (var i = 0; i < length; i++) {\n\t      var key = keys[i];\n\t      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n\t    }\n\t    return true;\n\t  };\n\t\n\t\n\t  // Internal recursive comparison function for `isEqual`.\n\t  var eq = function(a, b, aStack, bStack) {\n\t    // Identical objects are equal. `0 === -0`, but they aren't identical.\n\t    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n\t    if (a === b) return a !== 0 || 1 / a === 1 / b;\n\t    // A strict comparison is necessary because `null == undefined`.\n\t    if (a == null || b == null) return a === b;\n\t    // Unwrap any wrapped objects.\n\t    if (a instanceof _) a = a._wrapped;\n\t    if (b instanceof _) b = b._wrapped;\n\t    // Compare `[[Class]]` names.\n\t    var className = toString.call(a);\n\t    if (className !== toString.call(b)) return false;\n\t    switch (className) {\n\t      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n\t      case '[object RegExp]':\n\t      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n\t      case '[object String]':\n\t        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n\t        // equivalent to `new String(\"5\")`.\n\t        return '' + a === '' + b;\n\t      case '[object Number]':\n\t        // `NaN`s are equivalent, but non-reflexive.\n\t        // Object(NaN) is equivalent to NaN\n\t        if (+a !== +a) return +b !== +b;\n\t        // An `egal` comparison is performed for other numeric values.\n\t        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n\t      case '[object Date]':\n\t      case '[object Boolean]':\n\t        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n\t        // millisecond representations. Note that invalid dates with millisecond representations\n\t        // of `NaN` are not equivalent.\n\t        return +a === +b;\n\t    }\n\t\n\t    var areArrays = className === '[object Array]';\n\t    if (!areArrays) {\n\t      if (typeof a != 'object' || typeof b != 'object') return false;\n\t\n\t      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n\t      // from different frames are.\n\t      var aCtor = a.constructor, bCtor = b.constructor;\n\t      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n\t                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n\t                          && ('constructor' in a && 'constructor' in b)) {\n\t        return false;\n\t      }\n\t    }\n\t    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n\t    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\t\n\t    // Initializing stack of traversed objects.\n\t    // It's done here since we only need them for objects and arrays comparison.\n\t    aStack = aStack || [];\n\t    bStack = bStack || [];\n\t    var length = aStack.length;\n\t    while (length--) {\n\t      // Linear search. Performance is inversely proportional to the number of\n\t      // unique nested structures.\n\t      if (aStack[length] === a) return bStack[length] === b;\n\t    }\n\t\n\t    // Add the first object to the stack of traversed objects.\n\t    aStack.push(a);\n\t    bStack.push(b);\n\t\n\t    // Recursively compare objects and arrays.\n\t    if (areArrays) {\n\t      // Compare array lengths to determine if a deep comparison is necessary.\n\t      length = a.length;\n\t      if (length !== b.length) return false;\n\t      // Deep compare the contents, ignoring non-numeric properties.\n\t      while (length--) {\n\t        if (!eq(a[length], b[length], aStack, bStack)) return false;\n\t      }\n\t    } else {\n\t      // Deep compare objects.\n\t      var keys = _.keys(a), key;\n\t      length = keys.length;\n\t      // Ensure that both objects contain the same number of properties before comparing deep equality.\n\t      if (_.keys(b).length !== length) return false;\n\t      while (length--) {\n\t        // Deep compare each member\n\t        key = keys[length];\n\t        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n\t      }\n\t    }\n\t    // Remove the first object from the stack of traversed objects.\n\t    aStack.pop();\n\t    bStack.pop();\n\t    return true;\n\t  };\n\t\n\t  // Perform a deep comparison to check if two objects are equal.\n\t  _.isEqual = function(a, b) {\n\t    return eq(a, b);\n\t  };\n\t\n\t  // Is a given array, string, or object empty?\n\t  // An \"empty\" object has no enumerable own-properties.\n\t  _.isEmpty = function(obj) {\n\t    if (obj == null) return true;\n\t    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n\t    return _.keys(obj).length === 0;\n\t  };\n\t\n\t  // Is a given value a DOM element?\n\t  _.isElement = function(obj) {\n\t    return !!(obj && obj.nodeType === 1);\n\t  };\n\t\n\t  // Is a given value an array?\n\t  // Delegates to ECMA5's native Array.isArray\n\t  _.isArray = nativeIsArray || function(obj) {\n\t    return toString.call(obj) === '[object Array]';\n\t  };\n\t\n\t  // Is a given variable an object?\n\t  _.isObject = function(obj) {\n\t    var type = typeof obj;\n\t    return type === 'function' || type === 'object' && !!obj;\n\t  };\n\t\n\t  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n\t  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n\t    _['is' + name] = function(obj) {\n\t      return toString.call(obj) === '[object ' + name + ']';\n\t    };\n\t  });\n\t\n\t  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n\t  // there isn't any inspectable \"Arguments\" type.\n\t  if (!_.isArguments(arguments)) {\n\t    _.isArguments = function(obj) {\n\t      return _.has(obj, 'callee');\n\t    };\n\t  }\n\t\n\t  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n\t  // IE 11 (#1621), and in Safari 8 (#1929).\n\t  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n\t    _.isFunction = function(obj) {\n\t      return typeof obj == 'function' || false;\n\t    };\n\t  }\n\t\n\t  // Is a given object a finite number?\n\t  _.isFinite = function(obj) {\n\t    return isFinite(obj) && !isNaN(parseFloat(obj));\n\t  };\n\t\n\t  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n\t  _.isNaN = function(obj) {\n\t    return _.isNumber(obj) && obj !== +obj;\n\t  };\n\t\n\t  // Is a given value a boolean?\n\t  _.isBoolean = function(obj) {\n\t    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n\t  };\n\t\n\t  // Is a given value equal to null?\n\t  _.isNull = function(obj) {\n\t    return obj === null;\n\t  };\n\t\n\t  // Is a given variable undefined?\n\t  _.isUndefined = function(obj) {\n\t    return obj === void 0;\n\t  };\n\t\n\t  // Shortcut function for checking if an object has a given property directly\n\t  // on itself (in other words, not on a prototype).\n\t  _.has = function(obj, key) {\n\t    return obj != null && hasOwnProperty.call(obj, key);\n\t  };\n\t\n\t  // Utility Functions\n\t  // -----------------\n\t\n\t  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n\t  // previous owner. Returns a reference to the Underscore object.\n\t  _.noConflict = function() {\n\t    root._ = previousUnderscore;\n\t    return this;\n\t  };\n\t\n\t  // Keep the identity function around for default iteratees.\n\t  _.identity = function(value) {\n\t    return value;\n\t  };\n\t\n\t  // Predicate-generating functions. Often useful outside of Underscore.\n\t  _.constant = function(value) {\n\t    return function() {\n\t      return value;\n\t    };\n\t  };\n\t\n\t  _.noop = function(){};\n\t\n\t  _.property = property;\n\t\n\t  // Generates a function for a given object that returns a given property.\n\t  _.propertyOf = function(obj) {\n\t    return obj == null ? function(){} : function(key) {\n\t      return obj[key];\n\t    };\n\t  };\n\t\n\t  // Returns a predicate for checking whether an object has a given set of\n\t  // `key:value` pairs.\n\t  _.matcher = _.matches = function(attrs) {\n\t    attrs = _.extendOwn({}, attrs);\n\t    return function(obj) {\n\t      return _.isMatch(obj, attrs);\n\t    };\n\t  };\n\t\n\t  // Run a function **n** times.\n\t  _.times = function(n, iteratee, context) {\n\t    var accum = Array(Math.max(0, n));\n\t    iteratee = optimizeCb(iteratee, context, 1);\n\t    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n\t    return accum;\n\t  };\n\t\n\t  // Return a random integer between min and max (inclusive).\n\t  _.random = function(min, max) {\n\t    if (max == null) {\n\t      max = min;\n\t      min = 0;\n\t    }\n\t    return min + Math.floor(Math.random() * (max - min + 1));\n\t  };\n\t\n\t  // A (possibly faster) way to get the current timestamp as an integer.\n\t  _.now = Date.now || function() {\n\t    return new Date().getTime();\n\t  };\n\t\n\t   // List of HTML entities for escaping.\n\t  var escapeMap = {\n\t    '&': '&amp;',\n\t    '<': '&lt;',\n\t    '>': '&gt;',\n\t    '\"': '&quot;',\n\t    \"'\": '&#x27;',\n\t    '`': '&#x60;'\n\t  };\n\t  var unescapeMap = _.invert(escapeMap);\n\t\n\t  // Functions for escaping and unescaping strings to/from HTML interpolation.\n\t  var createEscaper = function(map) {\n\t    var escaper = function(match) {\n\t      return map[match];\n\t    };\n\t    // Regexes for identifying a key that needs to be escaped\n\t    var source = '(?:' + _.keys(map).join('|') + ')';\n\t    var testRegexp = RegExp(source);\n\t    var replaceRegexp = RegExp(source, 'g');\n\t    return function(string) {\n\t      string = string == null ? '' : '' + string;\n\t      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n\t    };\n\t  };\n\t  _.escape = createEscaper(escapeMap);\n\t  _.unescape = createEscaper(unescapeMap);\n\t\n\t  // If the value of the named `property` is a function then invoke it with the\n\t  // `object` as context; otherwise, return it.\n\t  _.result = function(object, property, fallback) {\n\t    var value = object == null ? void 0 : object[property];\n\t    if (value === void 0) {\n\t      value = fallback;\n\t    }\n\t    return _.isFunction(value) ? value.call(object) : value;\n\t  };\n\t\n\t  // Generate a unique integer id (unique within the entire client session).\n\t  // Useful for temporary DOM ids.\n\t  var idCounter = 0;\n\t  _.uniqueId = function(prefix) {\n\t    var id = ++idCounter + '';\n\t    return prefix ? prefix + id : id;\n\t  };\n\t\n\t  // By default, Underscore uses ERB-style template delimiters, change the\n\t  // following template settings to use alternative delimiters.\n\t  _.templateSettings = {\n\t    evaluate    : /<%([\\s\\S]+?)%>/g,\n\t    interpolate : /<%=([\\s\\S]+?)%>/g,\n\t    escape      : /<%-([\\s\\S]+?)%>/g\n\t  };\n\t\n\t  // When customizing `templateSettings`, if you don't want to define an\n\t  // interpolation, evaluation or escaping regex, we need one that is\n\t  // guaranteed not to match.\n\t  var noMatch = /(.)^/;\n\t\n\t  // Certain characters need to be escaped so that they can be put into a\n\t  // string literal.\n\t  var escapes = {\n\t    \"'\":      \"'\",\n\t    '\\\\':     '\\\\',\n\t    '\\r':     'r',\n\t    '\\n':     'n',\n\t    '\\u2028': 'u2028',\n\t    '\\u2029': 'u2029'\n\t  };\n\t\n\t  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\t\n\t  var escapeChar = function(match) {\n\t    return '\\\\' + escapes[match];\n\t  };\n\t\n\t  // JavaScript micro-templating, similar to John Resig's implementation.\n\t  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n\t  // and correctly escapes quotes within interpolated code.\n\t  // NB: `oldSettings` only exists for backwards compatibility.\n\t  _.template = function(text, settings, oldSettings) {\n\t    if (!settings && oldSettings) settings = oldSettings;\n\t    settings = _.defaults({}, settings, _.templateSettings);\n\t\n\t    // Combine delimiters into one regular expression via alternation.\n\t    var matcher = RegExp([\n\t      (settings.escape || noMatch).source,\n\t      (settings.interpolate || noMatch).source,\n\t      (settings.evaluate || noMatch).source\n\t    ].join('|') + '|$', 'g');\n\t\n\t    // Compile the template source, escaping string literals appropriately.\n\t    var index = 0;\n\t    var source = \"__p+='\";\n\t    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n\t      source += text.slice(index, offset).replace(escaper, escapeChar);\n\t      index = offset + match.length;\n\t\n\t      if (escape) {\n\t        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n\t      } else if (interpolate) {\n\t        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n\t      } else if (evaluate) {\n\t        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n\t      }\n\t\n\t      // Adobe VMs need the match returned to produce the correct offest.\n\t      return match;\n\t    });\n\t    source += \"';\\n\";\n\t\n\t    // If a variable is not specified, place data values in local scope.\n\t    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\t\n\t    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n\t      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n\t      source + 'return __p;\\n';\n\t\n\t    try {\n\t      var render = new Function(settings.variable || 'obj', '_', source);\n\t    } catch (e) {\n\t      e.source = source;\n\t      throw e;\n\t    }\n\t\n\t    var template = function(data) {\n\t      return render.call(this, data, _);\n\t    };\n\t\n\t    // Provide the compiled source as a convenience for precompilation.\n\t    var argument = settings.variable || 'obj';\n\t    template.source = 'function(' + argument + '){\\n' + source + '}';\n\t\n\t    return template;\n\t  };\n\t\n\t  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n\t  _.chain = function(obj) {\n\t    var instance = _(obj);\n\t    instance._chain = true;\n\t    return instance;\n\t  };\n\t\n\t  // OOP\n\t  // ---------------\n\t  // If Underscore is called as a function, it returns a wrapped object that\n\t  // can be used OO-style. This wrapper holds altered versions of all the\n\t  // underscore functions. Wrapped objects may be chained.\n\t\n\t  // Helper function to continue chaining intermediate results.\n\t  var result = function(instance, obj) {\n\t    return instance._chain ? _(obj).chain() : obj;\n\t  };\n\t\n\t  // Add your own custom functions to the Underscore object.\n\t  _.mixin = function(obj) {\n\t    _.each(_.functions(obj), function(name) {\n\t      var func = _[name] = obj[name];\n\t      _.prototype[name] = function() {\n\t        var args = [this._wrapped];\n\t        push.apply(args, arguments);\n\t        return result(this, func.apply(_, args));\n\t      };\n\t    });\n\t  };\n\t\n\t  // Add all of the Underscore functions to the wrapper object.\n\t  _.mixin(_);\n\t\n\t  // Add all mutator Array functions to the wrapper.\n\t  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n\t    var method = ArrayProto[name];\n\t    _.prototype[name] = function() {\n\t      var obj = this._wrapped;\n\t      method.apply(obj, arguments);\n\t      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n\t      return result(this, obj);\n\t    };\n\t  });\n\t\n\t  // Add all accessor Array functions to the wrapper.\n\t  _.each(['concat', 'join', 'slice'], function(name) {\n\t    var method = ArrayProto[name];\n\t    _.prototype[name] = function() {\n\t      return result(this, method.apply(this._wrapped, arguments));\n\t    };\n\t  });\n\t\n\t  // Extracts the result from a wrapped and chained object.\n\t  _.prototype.value = function() {\n\t    return this._wrapped;\n\t  };\n\t\n\t  // Provide unwrapping proxy for some methods used in engine operations\n\t  // such as arithmetic and JSON stringification.\n\t  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\t\n\t  _.prototype.toString = function() {\n\t    return '' + this._wrapped;\n\t  };\n\t\n\t  // AMD registration happens at the end for compatibility with AMD loaders\n\t  // that may not enforce next-turn semantics on modules. Even though general\n\t  // practice for AMD registration is to be anonymous, underscore registers\n\t  // as a named module because, like jQuery, it is a base library that is\n\t  // popular enough to be bundled in a third party lib, but not be part of\n\t  // an AMD load request. Those cases could generate an error when an\n\t  // anonymous define() is called outside of a loader request.\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return _;\n\t    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t}.call(this));\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(13));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  var noOptions = {};\n\t  var nonWS = /[^\\s\\u00a0]/;\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  function firstNonWS(str) {\n\t    var found = str.search(nonWS);\n\t    return found == -1 ? 0 : found;\n\t  }\n\t\n\t  CodeMirror.commands.toggleComment = function(cm) {\n\t    cm.toggleComment();\n\t  };\n\t\n\t  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n\t    if (!options) options = noOptions;\n\t    var cm = this;\n\t    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n\t    for (var i = ranges.length - 1; i >= 0; i--) {\n\t      var from = ranges[i].from(), to = ranges[i].to();\n\t      if (from.line >= minLine) continue;\n\t      if (to.line >= minLine) to = Pos(minLine, 0);\n\t      minLine = from.line;\n\t      if (mode == null) {\n\t        if (cm.uncomment(from, to, options)) mode = \"un\";\n\t        else { cm.lineComment(from, to, options); mode = \"line\"; }\n\t      } else if (mode == \"un\") {\n\t        cm.uncomment(from, to, options);\n\t      } else {\n\t        cm.lineComment(from, to, options);\n\t      }\n\t    }\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n\t    if (!options) options = noOptions;\n\t    var self = this, mode = self.getModeAt(from);\n\t    var commentString = options.lineComment || mode.lineComment;\n\t    if (!commentString) {\n\t      if (options.blockCommentStart || mode.blockCommentStart) {\n\t        options.fullLines = true;\n\t        self.blockComment(from, to, options);\n\t      }\n\t      return;\n\t    }\n\t    var firstLine = self.getLine(from.line);\n\t    if (firstLine == null) return;\n\t    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n\t    var pad = options.padding == null ? \" \" : options.padding;\n\t    var blankLines = options.commentBlankLines || from.line == to.line;\n\t\n\t    self.operation(function() {\n\t      if (options.indent) {\n\t        var baseString = null;\n\t        for (var i = from.line; i < end; ++i) {\n\t          var line = self.getLine(i);\n\t          var whitespace = line.slice(0, firstNonWS(line));\n\t          if (baseString == null || baseString.length > whitespace.length) {\n\t            baseString = whitespace;\n\t          }\n\t        }\n\t        for (var i = from.line; i < end; ++i) {\n\t          var line = self.getLine(i), cut = baseString.length;\n\t          if (!blankLines && !nonWS.test(line)) continue;\n\t          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n\t          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n\t        }\n\t      } else {\n\t        for (var i = from.line; i < end; ++i) {\n\t          if (blankLines || nonWS.test(self.getLine(i)))\n\t            self.replaceRange(commentString + pad, Pos(i, 0));\n\t        }\n\t      }\n\t    });\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n\t    if (!options) options = noOptions;\n\t    var self = this, mode = self.getModeAt(from);\n\t    var startString = options.blockCommentStart || mode.blockCommentStart;\n\t    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n\t    if (!startString || !endString) {\n\t      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n\t        self.lineComment(from, to, options);\n\t      return;\n\t    }\n\t\n\t    var end = Math.min(to.line, self.lastLine());\n\t    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\t\n\t    var pad = options.padding == null ? \" \" : options.padding;\n\t    if (from.line > end) return;\n\t\n\t    self.operation(function() {\n\t      if (options.fullLines != false) {\n\t        var lastLineHasText = nonWS.test(self.getLine(end));\n\t        self.replaceRange(pad + endString, Pos(end));\n\t        self.replaceRange(startString + pad, Pos(from.line, 0));\n\t        var lead = options.blockCommentLead || mode.blockCommentLead;\n\t        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n\t          if (i != end || lastLineHasText)\n\t            self.replaceRange(lead + pad, Pos(i, 0));\n\t      } else {\n\t        self.replaceRange(endString, to);\n\t        self.replaceRange(startString, from);\n\t      }\n\t    });\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n\t    if (!options) options = noOptions;\n\t    var self = this, mode = self.getModeAt(from);\n\t    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\t\n\t    // Try finding line comments\n\t    var lineString = options.lineComment || mode.lineComment, lines = [];\n\t    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n\t    lineComment: {\n\t      if (!lineString) break lineComment;\n\t      for (var i = start; i <= end; ++i) {\n\t        var line = self.getLine(i);\n\t        var found = line.indexOf(lineString);\n\t        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n\t        if (found == -1 && (i != end || i == start) && nonWS.test(line)) break lineComment;\n\t        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n\t        lines.push(line);\n\t      }\n\t      self.operation(function() {\n\t        for (var i = start; i <= end; ++i) {\n\t          var line = lines[i - start];\n\t          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n\t          if (pos < 0) continue;\n\t          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n\t          didSomething = true;\n\t          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n\t        }\n\t      });\n\t      if (didSomething) return true;\n\t    }\n\t\n\t    // Try block comments\n\t    var startString = options.blockCommentStart || mode.blockCommentStart;\n\t    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n\t    if (!startString || !endString) return false;\n\t    var lead = options.blockCommentLead || mode.blockCommentLead;\n\t    var startLine = self.getLine(start), endLine = end == start ? startLine : self.getLine(end);\n\t    var open = startLine.indexOf(startString), close = endLine.lastIndexOf(endString);\n\t    if (close == -1 && start != end) {\n\t      endLine = self.getLine(--end);\n\t      close = endLine.lastIndexOf(endString);\n\t    }\n\t    if (open == -1 || close == -1 ||\n\t        !/comment/.test(self.getTokenTypeAt(Pos(start, open + 1))) ||\n\t        !/comment/.test(self.getTokenTypeAt(Pos(end, close + 1))))\n\t      return false;\n\t\n\t    // Avoid killing block comments completely outside the selection.\n\t    // Positions of the last startString before the start of the selection, and the first endString after it.\n\t    var lastStart = startLine.lastIndexOf(startString, from.ch);\n\t    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n\t    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n\t    // Positions of the first endString after the end of the selection, and the last startString before it.\n\t    firstEnd = endLine.indexOf(endString, to.ch);\n\t    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n\t    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n\t    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\t\n\t    self.operation(function() {\n\t      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n\t                        Pos(end, close + endString.length));\n\t      var openEnd = open + startString.length;\n\t      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n\t      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n\t      if (lead) for (var i = start + 1; i <= end; ++i) {\n\t        var line = self.getLine(i), found = line.indexOf(lead);\n\t        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n\t        var foundEnd = found + lead.length;\n\t        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n\t        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n\t      }\n\t    });\n\t    return true;\n\t  });\n\t});\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// A rough approximation of Sublime Text's keybindings\n\t// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(13), __webpack_require__(22), __webpack_require__(23));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  var map = CodeMirror.keyMap.sublime = {fallthrough: \"default\"};\n\t  var cmds = CodeMirror.commands;\n\t  var Pos = CodeMirror.Pos;\n\t  var mac = CodeMirror.keyMap[\"default\"] == CodeMirror.keyMap.macDefault;\n\t  var ctrl = mac ? \"Cmd-\" : \"Ctrl-\";\n\t\n\t  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n\t  function findPosSubword(doc, start, dir) {\n\t    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n\t    var line = doc.getLine(start.line);\n\t    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n\t    var state = \"start\", type;\n\t    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n\t      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n\t      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n\t      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n\t      if (state == \"start\") {\n\t        if (cat != \"o\") { state = \"in\"; type = cat; }\n\t      } else if (state == \"in\") {\n\t        if (type != cat) {\n\t          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n\t          if (type == \"W\" && cat == \"w\" && dir > 0) { type = \"w\"; continue; }\n\t          break;\n\t        }\n\t      }\n\t    }\n\t    return Pos(start.line, pos);\n\t  }\n\t\n\t  function moveSubword(cm, dir) {\n\t    cm.extendSelectionsBy(function(range) {\n\t      if (cm.display.shift || cm.doc.extend || range.empty())\n\t        return findPosSubword(cm.doc, range.head, dir);\n\t      else\n\t        return dir < 0 ? range.from() : range.to();\n\t    });\n\t  }\n\t\n\t  cmds[map[\"Alt-Left\"] = \"goSubwordLeft\"] = function(cm) { moveSubword(cm, -1); };\n\t  cmds[map[\"Alt-Right\"] = \"goSubwordRight\"] = function(cm) { moveSubword(cm, 1); };\n\t\n\t  var scrollLineCombo = mac ? \"Ctrl-Alt-\" : \"Ctrl-\";\n\t\n\t  cmds[map[scrollLineCombo + \"Up\"] = \"scrollLineUp\"] = function(cm) {\n\t    var info = cm.getScrollInfo();\n\t    if (!cm.somethingSelected()) {\n\t      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n\t      if (cm.getCursor().line >= visibleBottomLine)\n\t        cm.execCommand(\"goLineUp\");\n\t    }\n\t    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n\t  };\n\t  cmds[map[scrollLineCombo + \"Down\"] = \"scrollLineDown\"] = function(cm) {\n\t    var info = cm.getScrollInfo();\n\t    if (!cm.somethingSelected()) {\n\t      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n\t      if (cm.getCursor().line <= visibleTopLine)\n\t        cm.execCommand(\"goLineDown\");\n\t    }\n\t    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n\t  };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"L\"] = \"splitSelectionByLine\"] = function(cm) {\n\t    var ranges = cm.listSelections(), lineRanges = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var from = ranges[i].from(), to = ranges[i].to();\n\t      for (var line = from.line; line <= to.line; ++line)\n\t        if (!(to.line > from.line && line == to.line && to.ch == 0))\n\t          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n\t                           head: line == to.line ? to : Pos(line)});\n\t    }\n\t    cm.setSelections(lineRanges, 0);\n\t  };\n\t\n\t  map[\"Shift-Tab\"] = \"indentLess\";\n\t\n\t  cmds[map[\"Esc\"] = \"singleSelectionTop\"] = function(cm) {\n\t    var range = cm.listSelections()[0];\n\t    cm.setSelection(range.anchor, range.head, {scroll: false});\n\t  };\n\t\n\t  cmds[map[ctrl + \"L\"] = \"selectLine\"] = function(cm) {\n\t    var ranges = cm.listSelections(), extended = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i];\n\t      extended.push({anchor: Pos(range.from().line, 0),\n\t                     head: Pos(range.to().line + 1, 0)});\n\t    }\n\t    cm.setSelections(extended);\n\t  };\n\t\n\t  map[\"Shift-\" + ctrl + \"K\"] = \"deleteLine\";\n\t\n\t  function insertLine(cm, above) {\n\t    cm.operation(function() {\n\t      var len = cm.listSelections().length, newSelection = [], last = -1;\n\t      for (var i = 0; i < len; i++) {\n\t        var head = cm.listSelections()[i].head;\n\t        if (head.line <= last) continue;\n\t        var at = Pos(head.line + (above ? 0 : 1), 0);\n\t        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n\t        cm.indentLine(at.line, null, true);\n\t        newSelection.push({head: at, anchor: at});\n\t        last = head.line + 1;\n\t      }\n\t      cm.setSelections(newSelection);\n\t    });\n\t  }\n\t\n\t  cmds[map[ctrl + \"Enter\"] = \"insertLineAfter\"] = function(cm) { insertLine(cm, false); };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"Enter\"] = \"insertLineBefore\"] = function(cm) { insertLine(cm, true); };\n\t\n\t  function wordAt(cm, pos) {\n\t    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n\t    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n\t    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n\t    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n\t  }\n\t\n\t  cmds[map[ctrl + \"D\"] = \"selectNextOccurrence\"] = function(cm) {\n\t    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n\t    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n\t    if (CodeMirror.cmpPos(from, to) == 0) {\n\t      var word = wordAt(cm, from);\n\t      if (!word.word) return;\n\t      cm.setSelection(word.from, word.to);\n\t      fullWord = true;\n\t    } else {\n\t      var text = cm.getRange(from, to);\n\t      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n\t      var cur = cm.getSearchCursor(query, to);\n\t      if (cur.findNext()) {\n\t        cm.addSelection(cur.from(), cur.to());\n\t      } else {\n\t        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n\t        if (cur.findNext())\n\t          cm.addSelection(cur.from(), cur.to());\n\t      }\n\t    }\n\t    if (fullWord)\n\t      cm.state.sublimeFindFullWord = cm.doc.sel;\n\t  };\n\t\n\t  var mirror = \"(){}[]\";\n\t  function selectBetweenBrackets(cm) {\n\t    var pos = cm.getCursor(), opening = cm.scanForBracket(pos, -1);\n\t    if (!opening) return;\n\t    for (;;) {\n\t      var closing = cm.scanForBracket(pos, 1);\n\t      if (!closing) return;\n\t      if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n\t        cm.setSelection(Pos(opening.pos.line, opening.pos.ch + 1), closing.pos, false);\n\t        return true;\n\t      }\n\t      pos = Pos(closing.pos.line, closing.pos.ch + 1);\n\t    }\n\t  }\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"Space\"] = \"selectScope\"] = function(cm) {\n\t    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n\t  };\n\t  cmds[map[\"Shift-\" + ctrl + \"M\"] = \"selectBetweenBrackets\"] = function(cm) {\n\t    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n\t  };\n\t\n\t  cmds[map[ctrl + \"M\"] = \"goToBracket\"] = function(cm) {\n\t    cm.extendSelectionsBy(function(range) {\n\t      var next = cm.scanForBracket(range.head, 1);\n\t      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n\t      var prev = cm.scanForBracket(range.head, -1);\n\t      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n\t    });\n\t  };\n\t\n\t  var swapLineCombo = mac ? \"Cmd-Ctrl-\" : \"Shift-Ctrl-\";\n\t\n\t  cmds[map[swapLineCombo + \"Up\"] = \"swapLineUp\"] = function(cm) {\n\t    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n\t      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n\t                    head: Pos(range.head.line - 1, range.head.ch)});\n\t      if (range.to().ch == 0 && !range.empty()) --to;\n\t      if (from > at) linesToMove.push(from, to);\n\t      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n\t      at = to;\n\t    }\n\t    cm.operation(function() {\n\t      for (var i = 0; i < linesToMove.length; i += 2) {\n\t        var from = linesToMove[i], to = linesToMove[i + 1];\n\t        var line = cm.getLine(from);\n\t        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n\t        if (to > cm.lastLine())\n\t          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n\t        else\n\t          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n\t      }\n\t      cm.setSelections(newSels);\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  cmds[map[swapLineCombo + \"Down\"] = \"swapLineDown\"] = function(cm) {\n\t    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n\t    for (var i = ranges.length - 1; i >= 0; i--) {\n\t      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n\t      if (range.to().ch == 0 && !range.empty()) from--;\n\t      if (from < at) linesToMove.push(from, to);\n\t      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n\t      at = to;\n\t    }\n\t    cm.operation(function() {\n\t      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n\t        var from = linesToMove[i], to = linesToMove[i + 1];\n\t        var line = cm.getLine(from);\n\t        if (from == cm.lastLine())\n\t          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n\t        else\n\t          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n\t        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n\t      }\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  map[ctrl + \"/\"] = function(cm) {\n\t    cm.toggleComment({ indent: true });\n\t  }\n\t\n\t  cmds[map[ctrl + \"J\"] = \"joinLines\"] = function(cm) {\n\t    var ranges = cm.listSelections(), joined = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i], from = range.from();\n\t      var start = from.line, end = range.to().line;\n\t      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n\t        end = ranges[++i].to().line;\n\t      joined.push({start: start, end: end, anchor: !range.empty() && from});\n\t    }\n\t    cm.operation(function() {\n\t      var offset = 0, ranges = [];\n\t      for (var i = 0; i < joined.length; i++) {\n\t        var obj = joined[i];\n\t        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n\t        for (var line = obj.start; line <= obj.end; line++) {\n\t          var actual = line - offset;\n\t          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n\t          if (actual < cm.lastLine()) {\n\t            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n\t            ++offset;\n\t          }\n\t        }\n\t        ranges.push({anchor: anchor || head, head: head});\n\t      }\n\t      cm.setSelections(ranges, 0);\n\t    });\n\t  };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"D\"] = \"duplicateLine\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var rangeCount = cm.listSelections().length;\n\t      for (var i = 0; i < rangeCount; i++) {\n\t        var range = cm.listSelections()[i];\n\t        if (range.empty())\n\t          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n\t        else\n\t          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n\t      }\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  map[ctrl + \"T\"] = \"transposeChars\";\n\t\n\t  function sortLines(cm, caseSensitive) {\n\t    var ranges = cm.listSelections(), toSort = [], selected;\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i];\n\t      if (range.empty()) continue;\n\t      var from = range.from().line, to = range.to().line;\n\t      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n\t        to = range[++i].to().line;\n\t      toSort.push(from, to);\n\t    }\n\t    if (toSort.length) selected = true;\n\t    else toSort.push(cm.firstLine(), cm.lastLine());\n\t\n\t    cm.operation(function() {\n\t      var ranges = [];\n\t      for (var i = 0; i < toSort.length; i += 2) {\n\t        var from = toSort[i], to = toSort[i + 1];\n\t        var start = Pos(from, 0), end = Pos(to);\n\t        var lines = cm.getRange(start, end, false);\n\t        if (caseSensitive)\n\t          lines.sort();\n\t        else\n\t          lines.sort(function(a, b) {\n\t            var au = a.toUpperCase(), bu = b.toUpperCase();\n\t            if (au != bu) { a = au; b = bu; }\n\t            return a < b ? -1 : a == b ? 0 : 1;\n\t          });\n\t        cm.replaceRange(lines, start, end);\n\t        if (selected) ranges.push({anchor: start, head: end});\n\t      }\n\t      if (selected) cm.setSelections(ranges, 0);\n\t    });\n\t  }\n\t\n\t  cmds[map[\"F9\"] = \"sortLines\"] = function(cm) { sortLines(cm, true); };\n\t  cmds[map[ctrl + \"F9\"] = \"sortLinesInsensitive\"] = function(cm) { sortLines(cm, false); };\n\t\n\t  cmds[map[\"F2\"] = \"nextBookmark\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks;\n\t    if (marks) while (marks.length) {\n\t      var current = marks.shift();\n\t      var found = current.find();\n\t      if (found) {\n\t        marks.push(current);\n\t        return cm.setSelection(found.from, found.to);\n\t      }\n\t    }\n\t  };\n\t\n\t  cmds[map[\"Shift-F2\"] = \"prevBookmark\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks;\n\t    if (marks) while (marks.length) {\n\t      marks.unshift(marks.pop());\n\t      var found = marks[marks.length - 1].find();\n\t      if (!found)\n\t        marks.pop();\n\t      else\n\t        return cm.setSelection(found.from, found.to);\n\t    }\n\t  };\n\t\n\t  cmds[map[ctrl + \"F2\"] = \"toggleBookmark\"] = function(cm) {\n\t    var ranges = cm.listSelections();\n\t    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var from = ranges[i].from(), to = ranges[i].to();\n\t      var found = cm.findMarks(from, to);\n\t      for (var j = 0; j < found.length; j++) {\n\t        if (found[j].sublimeBookmark) {\n\t          found[j].clear();\n\t          for (var k = 0; k < marks.length; k++)\n\t            if (marks[k] == found[j])\n\t              marks.splice(k--, 1);\n\t          break;\n\t        }\n\t      }\n\t      if (j == found.length)\n\t        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n\t    }\n\t  };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"F2\"] = \"clearBookmarks\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks;\n\t    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n\t    marks.length = 0;\n\t  };\n\t\n\t  cmds[map[\"Alt-F2\"] = \"selectBookmarks\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks, ranges = [];\n\t    if (marks) for (var i = 0; i < marks.length; i++) {\n\t      var found = marks[i].find();\n\t      if (!found)\n\t        marks.splice(i--, 0);\n\t      else\n\t        ranges.push({anchor: found.from, head: found.to});\n\t    }\n\t    if (ranges.length)\n\t      cm.setSelections(ranges, 0);\n\t  };\n\t\n\t  map[\"Alt-Q\"] = \"wrapLines\";\n\t\n\t  var cK = ctrl + \"K \";\n\t\n\t  function modifyWordOrSelection(cm, mod) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections(), indices = [], replacements = [];\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n\t        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n\t      }\n\t      cm.replaceSelections(replacements, \"around\", \"case\");\n\t      for (var i = indices.length - 1, at; i >= 0; i--) {\n\t        var range = ranges[indices[i]];\n\t        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n\t        var word = wordAt(cm, range.head);\n\t        at = word.from;\n\t        cm.replaceRange(mod(word.word), word.from, word.to);\n\t      }\n\t    });\n\t  }\n\t\n\t  map[cK + ctrl + \"Backspace\"] = \"delLineLeft\";\n\t\n\t  cmds[map[\"Backspace\"] = \"smartBackspace\"] = function(cm) {\n\t    if (cm.somethingSelected()) return CodeMirror.Pass;\n\t\n\t    var cursor = cm.getCursor();\n\t    var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n\t    var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\t    var indentUnit = cm.getOption(\"indentUnit\");\n\t\n\t    if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n\t      var prevIndent = new Pos(cursor.line,\n\t        CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\t\n\t      // If no smart delete is happening (due to tab sizing) just do a regular delete\n\t      if (prevIndent.ch == cursor.ch) return CodeMirror.Pass;\n\t\n\t      return cm.replaceRange(\"\", prevIndent, cursor, \"+delete\");\n\t    } else {\n\t      return CodeMirror.Pass;\n\t    }\n\t  };\n\t\n\t  cmds[map[cK + ctrl + \"K\"] = \"delLineRight\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections();\n\t      for (var i = ranges.length - 1; i >= 0; i--)\n\t        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  cmds[map[cK + ctrl + \"U\"] = \"upcaseAtCursor\"] = function(cm) {\n\t    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n\t  };\n\t  cmds[map[cK + ctrl + \"L\"] = \"downcaseAtCursor\"] = function(cm) {\n\t    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n\t  };\n\t\n\t  cmds[map[cK + ctrl + \"Space\"] = \"setSublimeMark\"] = function(cm) {\n\t    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n\t    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n\t  };\n\t  cmds[map[cK + ctrl + \"A\"] = \"selectToSublimeMark\"] = function(cm) {\n\t    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n\t    if (found) cm.setSelection(cm.getCursor(), found);\n\t  };\n\t  cmds[map[cK + ctrl + \"W\"] = \"deleteToSublimeMark\"] = function(cm) {\n\t    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n\t    if (found) {\n\t      var from = cm.getCursor(), to = found;\n\t      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n\t      cm.state.sublimeKilled = cm.getRange(from, to);\n\t      cm.replaceRange(\"\", from, to);\n\t    }\n\t  };\n\t  cmds[map[cK + ctrl + \"X\"] = \"swapWithSublimeMark\"] = function(cm) {\n\t    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n\t    if (found) {\n\t      cm.state.sublimeMark.clear();\n\t      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n\t      cm.setCursor(found);\n\t    }\n\t  };\n\t  cmds[map[cK + ctrl + \"Y\"] = \"sublimeYank\"] = function(cm) {\n\t    if (cm.state.sublimeKilled != null)\n\t      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n\t  };\n\t\n\t  map[cK + ctrl + \"G\"] = \"clearBookmarks\";\n\t  cmds[map[cK + ctrl + \"C\"] = \"showInCenter\"] = function(cm) {\n\t    var pos = cm.cursorCoords(null, \"local\");\n\t    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n\t  };\n\t\n\t  cmds[map[\"Shift-Alt-Up\"] = \"selectLinesUpward\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections();\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (range.head.line > cm.firstLine())\n\t          cm.addSelection(Pos(range.head.line - 1, range.head.ch));\n\t      }\n\t    });\n\t  };\n\t  cmds[map[\"Shift-Alt-Down\"] = \"selectLinesDownward\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections();\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (range.head.line < cm.lastLine())\n\t          cm.addSelection(Pos(range.head.line + 1, range.head.ch));\n\t      }\n\t    });\n\t  };\n\t\n\t  function getTarget(cm) {\n\t    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n\t    if (CodeMirror.cmpPos(from, to) == 0) {\n\t      var word = wordAt(cm, from);\n\t      if (!word.word) return;\n\t      from = word.from;\n\t      to = word.to;\n\t    }\n\t    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n\t  }\n\t\n\t  function findAndGoTo(cm, forward) {\n\t    var target = getTarget(cm);\n\t    if (!target) return;\n\t    var query = target.query;\n\t    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\t\n\t    if (forward ? cur.findNext() : cur.findPrevious()) {\n\t      cm.setSelection(cur.from(), cur.to());\n\t    } else {\n\t      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n\t                                              : cm.clipPos(Pos(cm.lastLine())));\n\t      if (forward ? cur.findNext() : cur.findPrevious())\n\t        cm.setSelection(cur.from(), cur.to());\n\t      else if (target.word)\n\t        cm.setSelection(target.from, target.to);\n\t    }\n\t  };\n\t  cmds[map[ctrl + \"F3\"] = \"findUnder\"] = function(cm) { findAndGoTo(cm, true); };\n\t  cmds[map[\"Shift-\" + ctrl + \"F3\"] = \"findUnderPrevious\"] = function(cm) { findAndGoTo(cm,false); };\n\t  cmds[map[\"Alt-F3\"] = \"findAllUnder\"] = function(cm) {\n\t    var target = getTarget(cm);\n\t    if (!target) return;\n\t    var cur = cm.getSearchCursor(target.query);\n\t    var matches = [];\n\t    var primaryIndex = -1;\n\t    while (cur.findNext()) {\n\t      matches.push({anchor: cur.from(), head: cur.to()});\n\t      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n\t        primaryIndex++;\n\t    }\n\t    cm.setSelections(matches, primaryIndex);\n\t  };\n\t\n\t  map[\"Shift-\" + ctrl + \"[\"] = \"fold\";\n\t  map[\"Shift-\" + ctrl + \"]\"] = \"unfold\";\n\t  map[cK + ctrl + \"0\"] = map[cK + ctrl + \"j\"] = \"unfoldAll\";\n\t\n\t  map[ctrl + \"I\"] = \"findIncremental\";\n\t  map[\"Shift-\" + ctrl + \"I\"] = \"findIncrementalReverse\";\n\t  map[ctrl + \"H\"] = \"replace\";\n\t  map[\"F3\"] = \"findNext\";\n\t  map[\"Shift-F3\"] = \"findPrev\";\n\t\n\t  CodeMirror.normalizeKeyMap(map);\n\t});\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(13));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  function SearchCursor(doc, query, pos, caseFold) {\n\t    this.atOccurrence = false; this.doc = doc;\n\t    if (caseFold == null && typeof query == \"string\") caseFold = false;\n\t\n\t    pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n\t    this.pos = {from: pos, to: pos};\n\t\n\t    // The matches method is filled in based on the type of query.\n\t    // It takes a position and a direction, and returns an object\n\t    // describing the next occurrence of the query, or null if no\n\t    // more matches were found.\n\t    if (typeof query != \"string\") { // Regexp match\n\t      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? \"ig\" : \"g\");\n\t      this.matches = function(reverse, pos) {\n\t        if (reverse) {\n\t          query.lastIndex = 0;\n\t          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;\n\t          for (;;) {\n\t            query.lastIndex = cutOff;\n\t            var newMatch = query.exec(line);\n\t            if (!newMatch) break;\n\t            match = newMatch;\n\t            start = match.index;\n\t            cutOff = match.index + (match[0].length || 1);\n\t            if (cutOff == line.length) break;\n\t          }\n\t          var matchLen = (match && match[0].length) || 0;\n\t          if (!matchLen) {\n\t            if (start == 0 && line.length == 0) {match = undefined;}\n\t            else if (start != doc.getLine(pos.line).length) {\n\t              matchLen++;\n\t            }\n\t          }\n\t        } else {\n\t          query.lastIndex = pos.ch;\n\t          var line = doc.getLine(pos.line), match = query.exec(line);\n\t          var matchLen = (match && match[0].length) || 0;\n\t          var start = match && match.index;\n\t          if (start + matchLen != line.length && !matchLen) matchLen = 1;\n\t        }\n\t        if (match && matchLen)\n\t          return {from: Pos(pos.line, start),\n\t                  to: Pos(pos.line, start + matchLen),\n\t                  match: match};\n\t      };\n\t    } else { // String query\n\t      var origQuery = query;\n\t      if (caseFold) query = query.toLowerCase();\n\t      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};\n\t      var target = query.split(\"\\n\");\n\t      // Different methods for single-line and multi-line queries\n\t      if (target.length == 1) {\n\t        if (!query.length) {\n\t          // Empty string would match anything and never progress, so\n\t          // we define it to match nothing instead.\n\t          this.matches = function() {};\n\t        } else {\n\t          this.matches = function(reverse, pos) {\n\t            if (reverse) {\n\t              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);\n\t              var match = line.lastIndexOf(query);\n\t              if (match > -1) {\n\t                match = adjustPos(orig, line, match);\n\t                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n\t              }\n\t             } else {\n\t               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);\n\t               var match = line.indexOf(query);\n\t               if (match > -1) {\n\t                 match = adjustPos(orig, line, match) + pos.ch;\n\t                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n\t               }\n\t            }\n\t          };\n\t        }\n\t      } else {\n\t        var origTarget = origQuery.split(\"\\n\");\n\t        this.matches = function(reverse, pos) {\n\t          var last = target.length - 1;\n\t          if (reverse) {\n\t            if (pos.line - (target.length - 1) < doc.firstLine()) return;\n\t            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;\n\t            var to = Pos(pos.line, origTarget[last].length);\n\t            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)\n\t              if (target[i] != fold(doc.getLine(ln))) return;\n\t            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;\n\t            if (fold(line.slice(cut)) != target[0]) return;\n\t            return {from: Pos(ln, cut), to: to};\n\t          } else {\n\t            if (pos.line + (target.length - 1) > doc.lastLine()) return;\n\t            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;\n\t            if (fold(line.slice(cut)) != target[0]) return;\n\t            var from = Pos(pos.line, cut);\n\t            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)\n\t              if (target[i] != fold(doc.getLine(ln))) return;\n\t            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;\n\t            return {from: from, to: Pos(ln, origTarget[last].length)};\n\t          }\n\t        };\n\t      }\n\t    }\n\t  }\n\t\n\t  SearchCursor.prototype = {\n\t    findNext: function() {return this.find(false);},\n\t    findPrevious: function() {return this.find(true);},\n\t\n\t    find: function(reverse) {\n\t      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n\t      function savePosAndFail(line) {\n\t        var pos = Pos(line, 0);\n\t        self.pos = {from: pos, to: pos};\n\t        self.atOccurrence = false;\n\t        return false;\n\t      }\n\t\n\t      for (;;) {\n\t        if (this.pos = this.matches(reverse, pos)) {\n\t          this.atOccurrence = true;\n\t          return this.pos.match || true;\n\t        }\n\t        if (reverse) {\n\t          if (!pos.line) return savePosAndFail(0);\n\t          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);\n\t        }\n\t        else {\n\t          var maxLine = this.doc.lineCount();\n\t          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);\n\t          pos = Pos(pos.line + 1, 0);\n\t        }\n\t      }\n\t    },\n\t\n\t    from: function() {if (this.atOccurrence) return this.pos.from;},\n\t    to: function() {if (this.atOccurrence) return this.pos.to;},\n\t\n\t    replace: function(newText, origin) {\n\t      if (!this.atOccurrence) return;\n\t      var lines = CodeMirror.splitLines(newText);\n\t      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n\t      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n\t                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n\t    }\n\t  };\n\t\n\t  // Maps a position in a case-folded line back to a position in the original line\n\t  // (compensating for codepoints increasing in number during folding)\n\t  function adjustPos(orig, folded, pos) {\n\t    if (orig.length == folded.length) return pos;\n\t    for (var pos1 = Math.min(pos, orig.length);;) {\n\t      var len1 = orig.slice(0, pos1).toLowerCase().length;\n\t      if (len1 < pos) ++pos1;\n\t      else if (len1 > pos) --pos1;\n\t      else return pos1;\n\t    }\n\t  }\n\t\n\t  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n\t    return new SearchCursor(this.doc, query, pos, caseFold);\n\t  });\n\t  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n\t    return new SearchCursor(this, query, pos, caseFold);\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n\t    var ranges = [];\n\t    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n\t    while (cur.findNext()) {\n\t      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break;\n\t      ranges.push({anchor: cur.from(), head: cur.to()});\n\t    }\n\t    if (ranges.length)\n\t      this.setSelections(ranges, 0);\n\t  });\n\t});\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(13));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n\t    (document.documentMode == null || document.documentMode < 8);\n\t\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\t\n\t  function findMatchingBracket(cm, where, strict, config) {\n\t    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n\t    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n\t    if (!match) return null;\n\t    var dir = match.charAt(1) == \">\" ? 1 : -1;\n\t    if (strict && (dir > 0) != (pos == where.ch)) return null;\n\t    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\t\n\t    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n\t    if (found == null) return null;\n\t    return {from: Pos(where.line, pos), to: found && found.pos,\n\t            match: found && found.ch == match.charAt(0), forward: dir > 0};\n\t  }\n\t\n\t  // bracketRegex is used to specify which type of bracket to scan\n\t  // should be a regexp, e.g. /[[\\]]/\n\t  //\n\t  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n\t  //\n\t  // Returns false when no bracket was found, null when it reached\n\t  // maxScanLines and gave up\n\t  function scanForBracket(cm, where, dir, style, config) {\n\t    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n\t    var maxScanLines = (config && config.maxScanLines) || 1000;\n\t\n\t    var stack = [];\n\t    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n\t    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n\t                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n\t    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n\t      var line = cm.getLine(lineNo);\n\t      if (!line) continue;\n\t      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n\t      if (line.length > maxScanLen) continue;\n\t      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n\t      for (; pos != end; pos += dir) {\n\t        var ch = line.charAt(pos);\n\t        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n\t          var match = matching[ch];\n\t          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n\t          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n\t          else stack.pop();\n\t        }\n\t      }\n\t    }\n\t    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n\t  }\n\t\n\t  function matchBrackets(cm, autoclear, config) {\n\t    // Disable brace matching in long lines, since it'll cause hugely slow updates\n\t    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n\t    var marks = [], ranges = cm.listSelections();\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);\n\t      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n\t        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n\t        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n\t        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n\t          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n\t      }\n\t    }\n\t\n\t    if (marks.length) {\n\t      // Kludge to work around the IE bug from issue #1193, where text\n\t      // input stops going to the textare whever this fires.\n\t      if (ie_lt8 && cm.state.focused) cm.focus();\n\t\n\t      var clear = function() {\n\t        cm.operation(function() {\n\t          for (var i = 0; i < marks.length; i++) marks[i].clear();\n\t        });\n\t      };\n\t      if (autoclear) setTimeout(clear, 800);\n\t      else return clear;\n\t    }\n\t  }\n\t\n\t  var currentlyHighlighted = null;\n\t  function doMatchBrackets(cm) {\n\t    cm.operation(function() {\n\t      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n\t      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n\t    });\n\t  }\n\t\n\t  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n\t    if (old && old != CodeMirror.Init)\n\t      cm.off(\"cursorActivity\", doMatchBrackets);\n\t    if (val) {\n\t      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n\t      cm.on(\"cursorActivity\", doMatchBrackets);\n\t    }\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n\t  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, strict, config){\n\t    return findMatchingBracket(this, pos, strict, config);\n\t  });\n\t  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n\t    return scanForBracket(this, pos, dir, style, config);\n\t  });\n\t});\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** es6-editor.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"http://localhost:8080/lib/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8237b15317773ff973aa\n **/","import 'sass/main.scss';\n\n// Vendor stuff\nimport 'jquery';\n// require('modernizr');\n\nimport 'foundation/js/foundation/foundation';\n//require('foundation/js/foundation/foundation.abide.js');\n// require('foundation/js/foundation/foundation.accordion');\n//require('foundation/js/foundation/foundation.alert.js');\n// require('foundation/js/foundation/foundation.clearing');\n// require('foundation/js/foundation/foundation.dropdown');\n// require('foundation/js/foundation/foundation.equalizer');\nimport 'foundation/js/foundation/foundation.interchange';\n//require('foundation/js/foundation/foundation.joyride.js');\n// require('foundation/js/foundation/foundation.magellan');\n// require('foundation/js/foundation/foundation.offcanvas');\n//require('foundation/js/foundation/foundation.orbit.js');\nimport 'foundation/js/foundation/foundation.reveal';\n//require('foundation/js/foundation/foundation.slider.js');\nimport 'foundation/js/foundation/foundation.tab';\n//require('foundation/js/foundation/foundation.tooltip.js');\n// require('foundation/js/foundation/foundation.topbar');\n\n\nimport 'codemirror/mode/javascript/javascript';\nimport 'codemirror/mode/htmlmixed/htmlmixed';\n\n// Our stuff\nimport BabelREPL from 'babel/repl';\n\n\n// A good case for the weakmap, since we need to keep track of\n// what component holds. Alternatives would be to somehow\n// keep track of these relationships some other way, maybe\n// with some data-id or an array you need to loop through.\nlet weakmap = new WeakMap();\n$('.js-example').each(function(index, el) {\n  let repl = new BabelREPL($(el));\n\n  // Assigning the jquery object won't work. You need to actually\n  // access the index.\n  weakmap.set($(this).find('.tabs')[0], repl);\n});\n\n// Mainly for creating the tabs.\n$(document).foundation();\n\n// Need to keep track of this, so we can refresh the editor since\n// it and tabs don't exactly agree with each other without some help.\n$('.tabs').on('toggled', function (event, tab) {\n  // Need to check if the key exists in the weakmap, since\n  // we have the other tabs on the right to account for\n  if (weakmap.has($(tab).parent()[0])) {\n    weakmap.get($(tab).parent()[0]).refresh();\n  }\n});\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/es6-editor.js\n **/","module.exports = global[\"$\"] = require(\"-!/Users/pechinp/Work/es6-editor/node_modules/expose-loader/index.js?jQuery!/Users/pechinp/Work/es6-editor/bower_components/jquery/dist/jquery.js\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/jquery/dist/jquery.js\n ** module id = 5\n ** module chunks = 0\n **/","module.exports = global[\"jQuery\"] = require(\"-!/Users/pechinp/Work/es6-editor/bower_components/jquery/dist/jquery.js\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/expose-loader?jQuery!./bower_components/jquery/dist/jquery.js\n ** module id = 6\n ** module chunks = 0\n **/","/*!\n * jQuery JavaScript Library v2.1.4\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-04-28T16:01Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Support: Firefox 18+\n// Can't be in strict mode, several libs including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n//\n\nvar arr = [];\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\n\tversion = \"2.1.4\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android<4.1\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\treturn !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the function hasn't returned already, we're confident that\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\treturn true;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\t\t// Support: Android<4.0, iOS<6 (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t// and removal by using an indirect global eval\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE9-11+\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android<4.1\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n});\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\n\t// Support: iOS 8.2 (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.0-pre\n * http://sizzlejs.com/\n *\n * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-16\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\tnodeType = context.nodeType;\n\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\tif ( !seed && documentIsHTML ) {\n\n\t\t// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType !== 1 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, parent,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\tparent = doc.defaultView;\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent !== parent.top ) {\n\t\t// IE11 does not have attachEvent, so all must suffer\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Support tests\n\t---------------------------------------------------------------------- */\n\tdocumentIsHTML = !isXML( doc );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is no seed and only one group\n\tif ( match.length === 1 ) {\n\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t});\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tlen = this.length,\n\t\t\tret = [],\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[0] === \"<\" && selector[ selector.length - 1 ] === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Support: Blackberry 4.6\n\t\t\t\t\t// gEBID returns nodes no longer in the document (#6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.extend({\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar matched = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t}\n});\n\njQuery.fn.extend({\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.unique(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.unique( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend({\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\tjQuery( document ).off( \"ready\" );\n\t\t}\n\t}\n});\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\twindow.removeEventListener( \"load\", completed, false );\n\tjQuery.ready();\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// We once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlen ? fn( elems[0], key ) : emptyGet;\n};\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( owner ) {\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\t/* jshint -W018 */\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\nfunction Data() {\n\t// Support: Android<4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\nData.accepts = jQuery.acceptData;\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android<4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\nvar data_priv = new Data();\n\nvar data_user = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdata_user.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend({\n\thasData: function( elem ) {\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn data_user.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdata_user.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to data_priv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn data_priv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdata_priv.remove( elem, name );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.set( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data,\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each(function() {\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t}\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tdata_user.remove( this, key );\n\t\t});\n\t}\n});\n\n\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t};\n\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Safari<=5.1\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Safari<=5.1, Android<4.2\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<=11+\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n})();\nvar strundefined = typeof undefined;\n\n\n\nsupport.focusinBubbles = \"onfocusin\" in window;\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn't\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome<28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle, false );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\t// Support: Android<4.0\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && e.preventDefault ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// Support: Firefox, Chrome, Safari\n// Create \"bubbling\" focus and blur events\nif ( !support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdata_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdata_priv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdata_priv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n\n\nvar\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE9\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\n// Support: IE9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdata_priv.set(\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( data_priv.hasData( src ) ) {\n\t\tpdataOld = data_priv.access( src );\n\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( data_user.hasData( src ) ) {\n\t\tudataOld = data_user.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdata_user.set( dest, udataCur );\n\t}\n}\n\nfunction getAll( context, tag ) {\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type, key,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\tif ( jQuery.acceptData( elem ) ) {\n\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Discard any remaining `user` data\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t}\n\t}\n});\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each(function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map(function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar arg = arguments[ 0 ];\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\targ = this.parentNode;\n\n\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\tif ( arg ) {\n\t\t\t\targ.replaceChild( elem, this );\n\t\t\t}\n\t\t});\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\n\nvar iframe,\n\telemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar style,\n\t\telem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n\t\t\t// Use of this method is a temporary fix (more like optimization) until something better comes along,\n\t\t\t// since it was removed from specification and supported only in FF\n\t\t\tstyle.display : jQuery.css( elem[ 0 ], \"display\" );\n\n\t// We don't have any data stored on the element,\n\t// so use \"detach\" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = iframe[ 0 ].contentDocument;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tif ( elem.ownerDocument.defaultView.opener ) {\n\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t\t}\n\n\t\treturn window.getComputedStyle( elem, null );\n\t};\n\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE9\n\t// getPropertyValue is only needed for .css('filter') (#12537)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t}\n\n\tif ( computed ) {\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// Support: iOS < 6\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\n(function() {\n\tvar pixelPositionVal, boxSizingReliableVal,\n\t\tdocElem = document.documentElement,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE9-11+\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" +\n\t\t\"position:absolute\";\n\tcontainer.appendChild( div );\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computePixelPositionAndBoxSizingReliable() {\n\t\tdiv.style.cssText =\n\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n\t\t\t\"border:1px;padding:1px;width:4px;position:absolute\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocElem.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div, null );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\tdocElem.removeChild( container );\n\t}\n\n\t// Support: node.js jsdom\n\t// Don't assume that getComputedStyle is a property of the global object\n\tif ( window.getComputedStyle ) {\n\t\tjQuery.extend( support, {\n\t\t\tpixelPosition: function() {\n\n\t\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t\t// No need to check if the test was already performed, though.\n\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t}\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\treliableMarginRight: function() {\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\t\tvar ret,\n\t\t\t\t\tmarginDiv = div.appendChild( document.createElement( \"div\" ) );\n\n\t\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\t\tmarginDiv.style.cssText = div.style.cssText =\n\t\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\t\tdiv.style.width = \"1px\";\n\t\t\t\tdocElem.appendChild( container );\n\n\t\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n\n\t\t\t\tdocElem.removeChild( container );\n\t\t\t\tdiv.removeChild( marginDiv );\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t});\n\t}\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar\n\t// Swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\t\t\thidden = isHidden( elem );\n\n\t\t\tif ( display !== \"none\" || !hidden ) {\n\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.extend({\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\n// Support: Android 2.3\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t}\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur(),\n\t\t\t\t// break the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t} ]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\n\t// Handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// Height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\n\t\t// Test default display if display is currently \"none\"\n\t\tcheckDisplay = display === \"none\" ?\n\t\t\tdata_priv.get( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\t\tstyle.display = \"inline-block\";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always(function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t});\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t// Any non-fx value stops us from restoring the original display value\n\t\t} else {\n\t\t\tdisplay = undefined;\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// Store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t} else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n\t\tstyle.display = display;\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = data_priv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\tclearTimeout( timeout );\n\t\t};\n\t});\n};\n\n\n(function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: iOS<=5.1, Android<=4.2+\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE<=11+\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: Android<=2.3\n\t// Options inside disabled selects are incorrectly marked as disabled\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE<=11+\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n})();\n\n\nvar nodeHook, boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle;\n\t\tif ( !isXML ) {\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ name ];\n\t\t\tattrHandle[ name ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tname.toLowerCase() :\n\t\t\t\tnull;\n\t\t\tattrHandle[ name ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n});\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// Toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n});\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\tjQuery.trim( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute( \"disabled\" ) === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\n// Support: Android 2.3\n// Workaround failure to string-cast null input\njQuery.parseJSON = function( data ) {\n\treturn JSON.parse( data + \"\" );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, tmp;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE9\n\ttry {\n\t\ttmp = new DOMParser();\n\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Document location\n\tajaxLocation = window.location.href,\n\n\t// Segment location into parts\n\tajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax({\n\t\turl: url,\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t});\n};\n\n\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n};\njQuery.expr.filters.visible = function( elem ) {\n\treturn !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function() {\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new XMLHttpRequest();\n\t} catch( e ) {}\n};\n\nvar xhrId = 0,\n\txhrCallbacks = {},\n\txhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE9\n// Open requests must be manually aborted on unload (#5280)\n// See https://support.microsoft.com/kb/2856746 for more info\nif ( window.attachEvent ) {\n\twindow.attachEvent( \"onunload\", function() {\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]();\n\t\t}\n\t});\n}\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n\tvar callback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\txhr.onerror = callback(\"error\");\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = xhrCallbacks[ id ] = callback(\"abort\");\n\n\t\t\t\ttry {\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\tasync: true,\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t}).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[1] ) ];\n\t}\n\n\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = jQuery.trim( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n});\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t}).length;\n};\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend({\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t});\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\telem = this[ 0 ],\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it's not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\t// Support: BlackBerry 5, iOS 3 (original iPhone)\n\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t}\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\n// Support: Safari<7+, Chrome<37+\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t});\n}\n\n\n\n\nvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/jquery/dist/jquery.js\n ** module id = 7\n ** module chunks = 0\n **/","/*\n * Foundation Responsive Library\n * http://foundation.zurb.com\n * Copyright 2015, ZURB\n * Free to use under the MIT license.\n * http://www.opensource.org/licenses/mit-license.php\n*/\n\n(function ($, window, document, undefined) {\n  'use strict';\n\n  var header_helpers = function (class_array) {\n    var head = $('head');\n    head.prepend($.map(class_array, function (class_name) {\n      if (head.has('.' + class_name).length === 0) {\n        return '<meta class=\"' + class_name + '\" />';\n      }\n    }));\n  };\n\n  header_helpers([\n    'foundation-mq-small',\n    'foundation-mq-small-only',\n    'foundation-mq-medium',\n    'foundation-mq-medium-only',\n    'foundation-mq-large',\n    'foundation-mq-large-only',\n    'foundation-mq-xlarge',\n    'foundation-mq-xlarge-only',\n    'foundation-mq-xxlarge',\n    'foundation-data-attribute-namespace']);\n\n  // Enable FastClick if present\n\n  $(function () {\n    if (typeof FastClick !== 'undefined') {\n      // Don't attach to body if undefined\n      if (typeof document.body !== 'undefined') {\n        FastClick.attach(document.body);\n      }\n    }\n  });\n\n  // private Fast Selector wrapper,\n  // returns jQuery object. Only use where\n  // getElementById is not available.\n  var S = function (selector, context) {\n    if (typeof selector === 'string') {\n      if (context) {\n        var cont;\n        if (context.jquery) {\n          cont = context[0];\n          if (!cont) {\n            return context;\n          }\n        } else {\n          cont = context;\n        }\n        return $(cont.querySelectorAll(selector));\n      }\n\n      return $(document.querySelectorAll(selector));\n    }\n\n    return $(selector, context);\n  };\n\n  // Namespace functions.\n\n  var attr_name = function (init) {\n    var arr = [];\n    if (!init) {\n      arr.push('data');\n    }\n    if (this.namespace.length > 0) {\n      arr.push(this.namespace);\n    }\n    arr.push(this.name);\n\n    return arr.join('-');\n  };\n\n  var add_namespace = function (str) {\n    var parts = str.split('-'),\n        i = parts.length,\n        arr = [];\n\n    while (i--) {\n      if (i !== 0) {\n        arr.push(parts[i]);\n      } else {\n        if (this.namespace.length > 0) {\n          arr.push(this.namespace, parts[i]);\n        } else {\n          arr.push(parts[i]);\n        }\n      }\n    }\n\n    return arr.reverse().join('-');\n  };\n\n  // Event binding and data-options updating.\n\n  var bindings = function (method, options) {\n    var self = this,\n        bind = function(){\n          var $this = S(this),\n              should_bind_events = !$this.data(self.attr_name(true) + '-init');\n          $this.data(self.attr_name(true) + '-init', $.extend({}, self.settings, (options || method), self.data_options($this)));\n\n          if (should_bind_events) {\n            self.events(this);\n          }\n        };\n\n    if (S(this.scope).is('[' + this.attr_name() +']')) {\n      bind.call(this.scope);\n    } else {\n      S('[' + this.attr_name() +']', this.scope).each(bind);\n    }\n    // # Patch to fix #5043 to move this *after* the if/else clause in order for Backbone and similar frameworks to have improved control over event binding and data-options updating.\n    if (typeof method === 'string') {\n      return this[method].call(this, options);\n    }\n\n  };\n\n  var single_image_loaded = function (image, callback) {\n    function loaded () {\n      callback(image[0]);\n    }\n\n    function bindLoad () {\n      this.one('load', loaded);\n\n      if (/MSIE (\\d+\\.\\d+);/.test(navigator.userAgent)) {\n        var src = this.attr( 'src' ),\n            param = src.match( /\\?/ ) ? '&' : '?';\n\n        param += 'random=' + (new Date()).getTime();\n        this.attr('src', src + param);\n      }\n    }\n\n    if (!image.attr('src')) {\n      loaded();\n      return;\n    }\n\n    if (image[0].complete || image[0].readyState === 4) {\n      loaded();\n    } else {\n      bindLoad.call(image);\n    }\n  };\n\n  /*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */\n\n  window.matchMedia || (window.matchMedia = function() {\n      \"use strict\";\n\n      // For browsers that support matchMedium api such as IE 9 and webkit\n      var styleMedia = (window.styleMedia || window.media);\n\n      // For those that don't support matchMedium\n      if (!styleMedia) {\n          var style       = document.createElement('style'),\n              script      = document.getElementsByTagName('script')[0],\n              info        = null;\n\n          style.type  = 'text/css';\n          style.id    = 'matchmediajs-test';\n\n          script.parentNode.insertBefore(style, script);\n\n          // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n          info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;\n\n          styleMedia = {\n              matchMedium: function(media) {\n                  var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\n\n                  // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n                  if (style.styleSheet) {\n                      style.styleSheet.cssText = text;\n                  } else {\n                      style.textContent = text;\n                  }\n\n                  // Test if media query is true or false\n                  return info.width === '1px';\n              }\n          };\n      }\n\n      return function(media) {\n          return {\n              matches: styleMedia.matchMedium(media || 'all'),\n              media: media || 'all'\n          };\n      };\n  }());\n\n  /*\n   * jquery.requestAnimationFrame\n   * https://github.com/gnarf37/jquery-requestAnimationFrame\n   * Requires jQuery 1.8+\n   *\n   * Copyright (c) 2012 Corey Frang\n   * Licensed under the MIT license.\n   */\n\n  (function(jQuery) {\n\n\n  // requestAnimationFrame polyfill adapted from Erik Möller\n  // fixes from Paul Irish and Tino Zijdel\n  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n  // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n  var animating,\n      lastTime = 0,\n      vendors = ['webkit', 'moz'],\n      requestAnimationFrame = window.requestAnimationFrame,\n      cancelAnimationFrame = window.cancelAnimationFrame,\n      jqueryFxAvailable = 'undefined' !== typeof jQuery.fx;\n\n  for (; lastTime < vendors.length && !requestAnimationFrame; lastTime++) {\n    requestAnimationFrame = window[ vendors[lastTime] + 'RequestAnimationFrame' ];\n    cancelAnimationFrame = cancelAnimationFrame ||\n      window[ vendors[lastTime] + 'CancelAnimationFrame' ] ||\n      window[ vendors[lastTime] + 'CancelRequestAnimationFrame' ];\n  }\n\n  function raf() {\n    if (animating) {\n      requestAnimationFrame(raf);\n\n      if (jqueryFxAvailable) {\n        jQuery.fx.tick();\n      }\n    }\n  }\n\n  if (requestAnimationFrame) {\n    // use rAF\n    window.requestAnimationFrame = requestAnimationFrame;\n    window.cancelAnimationFrame = cancelAnimationFrame;\n\n    if (jqueryFxAvailable) {\n      jQuery.fx.timer = function (timer) {\n        if (timer() && jQuery.timers.push(timer) && !animating) {\n          animating = true;\n          raf();\n        }\n      };\n\n      jQuery.fx.stop = function () {\n        animating = false;\n      };\n    }\n  } else {\n    // polyfill\n    window.requestAnimationFrame = function (callback) {\n      var currTime = new Date().getTime(),\n        timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n        id = window.setTimeout(function () {\n          callback(currTime + timeToCall);\n        }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n\n    window.cancelAnimationFrame = function (id) {\n      clearTimeout(id);\n    };\n\n  }\n\n  }( $ ));\n\n  function removeQuotes (string) {\n    if (typeof string === 'string' || string instanceof String) {\n      string = string.replace(/^['\\\\/\"]+|(;\\s?})+|['\\\\/\"]+$/g, '');\n    }\n\n    return string;\n  }\n\n  function MediaQuery(selector) {\n    this.selector = selector;\n    this.query = '';\n  }\n\n  MediaQuery.prototype.toString = function () {\n    return this.query || (this.query = S(this.selector).css('font-family').replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, ''));\n  };\n\n  window.Foundation = {\n    name : 'Foundation',\n\n    version : '5.5.3',\n\n    media_queries : {\n      'small'       : new MediaQuery('.foundation-mq-small'),\n      'small-only'  : new MediaQuery('.foundation-mq-small-only'),\n      'medium'      : new MediaQuery('.foundation-mq-medium'),\n      'medium-only' : new MediaQuery('.foundation-mq-medium-only'),\n      'large'       : new MediaQuery('.foundation-mq-large'),\n      'large-only'  : new MediaQuery('.foundation-mq-large-only'),\n      'xlarge'      : new MediaQuery('.foundation-mq-xlarge'),\n      'xlarge-only' : new MediaQuery('.foundation-mq-xlarge-only'),\n      'xxlarge'     : new MediaQuery('.foundation-mq-xxlarge')\n    },\n\n    stylesheet : $('<style></style>').appendTo('head')[0].sheet,\n\n    global : {\n      namespace : undefined\n    },\n\n    init : function (scope, libraries, method, options, response) {\n      var args = [scope, method, options, response],\n          responses = [];\n\n      // check RTL\n      this.rtl = /rtl/i.test(S('html').attr('dir'));\n\n      // set foundation global scope\n      this.scope = scope || this.scope;\n\n      this.set_namespace();\n\n      if (libraries && typeof libraries === 'string' && !/reflow/i.test(libraries)) {\n        if (this.libs.hasOwnProperty(libraries)) {\n          responses.push(this.init_lib(libraries, args));\n        }\n      } else {\n        for (var lib in this.libs) {\n          responses.push(this.init_lib(lib, libraries));\n        }\n      }\n\n      S(window).load(function () {\n        S(window)\n          .trigger('resize.fndtn.clearing')\n          .trigger('resize.fndtn.dropdown')\n          .trigger('resize.fndtn.equalizer')\n          .trigger('resize.fndtn.interchange')\n          .trigger('resize.fndtn.joyride')\n          .trigger('resize.fndtn.magellan')\n          .trigger('resize.fndtn.topbar')\n          .trigger('resize.fndtn.slider');\n      });\n\n      return scope;\n    },\n\n    init_lib : function (lib, args) {\n      if (this.libs.hasOwnProperty(lib)) {\n        this.patch(this.libs[lib]);\n\n        if (args && args.hasOwnProperty(lib)) {\n            if (typeof this.libs[lib].settings !== 'undefined') {\n              $.extend(true, this.libs[lib].settings, args[lib]);\n            } else if (typeof this.libs[lib].defaults !== 'undefined') {\n              $.extend(true, this.libs[lib].defaults, args[lib]);\n            }\n          return this.libs[lib].init.apply(this.libs[lib], [this.scope, args[lib]]);\n        }\n\n        args = args instanceof Array ? args : new Array(args);\n        return this.libs[lib].init.apply(this.libs[lib], args);\n      }\n\n      return function () {};\n    },\n\n    patch : function (lib) {\n      lib.scope = this.scope;\n      lib.namespace = this.global.namespace;\n      lib.rtl = this.rtl;\n      lib['data_options'] = this.utils.data_options;\n      lib['attr_name'] = attr_name;\n      lib['add_namespace'] = add_namespace;\n      lib['bindings'] = bindings;\n      lib['S'] = this.utils.S;\n    },\n\n    inherit : function (scope, methods) {\n      var methods_arr = methods.split(' '),\n          i = methods_arr.length;\n\n      while (i--) {\n        if (this.utils.hasOwnProperty(methods_arr[i])) {\n          scope[methods_arr[i]] = this.utils[methods_arr[i]];\n        }\n      }\n    },\n\n    set_namespace : function () {\n\n      // Description:\n      //    Don't bother reading the namespace out of the meta tag\n      //    if the namespace has been set globally in javascript\n      //\n      // Example:\n      //    Foundation.global.namespace = 'my-namespace';\n      // or make it an empty string:\n      //    Foundation.global.namespace = '';\n      //\n      //\n\n      // If the namespace has not been set (is undefined), try to read it out of the meta element.\n      // Otherwise use the globally defined namespace, even if it's empty ('')\n      var namespace = ( this.global.namespace === undefined ) ? $('.foundation-data-attribute-namespace').css('font-family') : this.global.namespace;\n\n      // Finally, if the namsepace is either undefined or false, set it to an empty string.\n      // Otherwise use the namespace value.\n      this.global.namespace = ( namespace === undefined || /false/i.test(namespace) ) ? '' : namespace;\n    },\n\n    libs : {},\n\n    // methods that can be inherited in libraries\n    utils : {\n\n      // Description:\n      //    Fast Selector wrapper returns jQuery object. Only use where getElementById\n      //    is not available.\n      //\n      // Arguments:\n      //    Selector (String): CSS selector describing the element(s) to be\n      //    returned as a jQuery object.\n      //\n      //    Scope (String): CSS selector describing the area to be searched. Default\n      //    is document.\n      //\n      // Returns:\n      //    Element (jQuery Object): jQuery object containing elements matching the\n      //    selector within the scope.\n      S : S,\n\n      // Description:\n      //    Executes a function a max of once every n milliseconds\n      //\n      // Arguments:\n      //    Func (Function): Function to be throttled.\n      //\n      //    Delay (Integer): Function execution threshold in milliseconds.\n      //\n      // Returns:\n      //    Lazy_function (Function): Function with throttling applied.\n      throttle : function (func, delay) {\n        var timer = null;\n\n        return function () {\n          var context = this, args = arguments;\n\n          if (timer == null) {\n            timer = setTimeout(function () {\n              func.apply(context, args);\n              timer = null;\n            }, delay);\n          }\n        };\n      },\n\n      // Description:\n      //    Executes a function when it stops being invoked for n seconds\n      //    Modified version of _.debounce() http://underscorejs.org\n      //\n      // Arguments:\n      //    Func (Function): Function to be debounced.\n      //\n      //    Delay (Integer): Function execution threshold in milliseconds.\n      //\n      //    Immediate (Bool): Whether the function should be called at the beginning\n      //    of the delay instead of the end. Default is false.\n      //\n      // Returns:\n      //    Lazy_function (Function): Function with debouncing applied.\n      debounce : function (func, delay, immediate) {\n        var timeout, result;\n        return function () {\n          var context = this, args = arguments;\n          var later = function () {\n            timeout = null;\n            if (!immediate) {\n              result = func.apply(context, args);\n            }\n          };\n          var callNow = immediate && !timeout;\n          clearTimeout(timeout);\n          timeout = setTimeout(later, delay);\n          if (callNow) {\n            result = func.apply(context, args);\n          }\n          return result;\n        };\n      },\n\n      // Description:\n      //    Parses data-options attribute\n      //\n      // Arguments:\n      //    El (jQuery Object): Element to be parsed.\n      //\n      // Returns:\n      //    Options (Javascript Object): Contents of the element's data-options\n      //    attribute.\n      data_options : function (el, data_attr_name) {\n        data_attr_name = data_attr_name || 'options';\n        var opts = {}, ii, p, opts_arr,\n            data_options = function (el) {\n              var namespace = Foundation.global.namespace;\n\n              if (namespace.length > 0) {\n                return el.data(namespace + '-' + data_attr_name);\n              }\n\n              return el.data(data_attr_name);\n            };\n\n        var cached_options = data_options(el);\n\n        if (typeof cached_options === 'object') {\n          return cached_options;\n        }\n\n        opts_arr = (cached_options || ':').split(';');\n        ii = opts_arr.length;\n\n        function isNumber (o) {\n          return !isNaN (o - 0) && o !== null && o !== '' && o !== false && o !== true;\n        }\n\n        function trim (str) {\n          if (typeof str === 'string') {\n            return $.trim(str);\n          }\n          return str;\n        }\n\n        while (ii--) {\n          p = opts_arr[ii].split(':');\n          p = [p[0], p.slice(1).join(':')];\n\n          if (/true/i.test(p[1])) {\n            p[1] = true;\n          }\n          if (/false/i.test(p[1])) {\n            p[1] = false;\n          }\n          if (isNumber(p[1])) {\n            if (p[1].indexOf('.') === -1) {\n              p[1] = parseInt(p[1], 10);\n            } else {\n              p[1] = parseFloat(p[1]);\n            }\n          }\n\n          if (p.length === 2 && p[0].length > 0) {\n            opts[trim(p[0])] = trim(p[1]);\n          }\n        }\n\n        return opts;\n      },\n\n      // Description:\n      //    Adds JS-recognizable media queries\n      //\n      // Arguments:\n      //    Media (String): Key string for the media query to be stored as in\n      //    Foundation.media_queries\n      //\n      //    Class (String): Class name for the generated <meta> tag\n      register_media : function (media, media_class) {\n        if (Foundation.media_queries[media] === undefined) {\n          $('head').append('<meta class=\"' + media_class + '\"/>');\n          Foundation.media_queries[media] = removeQuotes($('.' + media_class).css('font-family'));\n        }\n      },\n\n      // Description:\n      //    Add custom CSS within a JS-defined media query\n      //\n      // Arguments:\n      //    Rule (String): CSS rule to be appended to the document.\n      //\n      //    Media (String): Optional media query string for the CSS rule to be\n      //    nested under.\n      add_custom_rule : function (rule, media) {\n        if (media === undefined && Foundation.stylesheet) {\n          Foundation.stylesheet.insertRule(rule, Foundation.stylesheet.cssRules.length);\n        } else {\n          var query = Foundation.media_queries[media];\n\n          if (query !== undefined) {\n            Foundation.stylesheet.insertRule('@media ' +\n              Foundation.media_queries[media] + '{ ' + rule + ' }', Foundation.stylesheet.cssRules.length);\n          }\n        }\n      },\n\n      // Description:\n      //    Performs a callback function when an image is fully loaded\n      //\n      // Arguments:\n      //    Image (jQuery Object): Image(s) to check if loaded.\n      //\n      //    Callback (Function): Function to execute when image is fully loaded.\n      image_loaded : function (images, callback) {\n        var self = this,\n            unloaded = images.length;\n\n        function pictures_has_height(images) {\n          var pictures_number = images.length;\n\n          for (var i = pictures_number - 1; i >= 0; i--) {\n            if(images.attr('height') === undefined) {\n              return false;\n            };\n          };\n\n          return true;\n        }\n\n        if (unloaded === 0 || pictures_has_height(images)) {\n          callback(images);\n        }\n\n        images.each(function () {\n          single_image_loaded(self.S(this), function () {\n            unloaded -= 1;\n            if (unloaded === 0) {\n              callback(images);\n            }\n          });\n        });\n      },\n\n      // Description:\n      //    Returns a random, alphanumeric string\n      //\n      // Arguments:\n      //    Length (Integer): Length of string to be generated. Defaults to random\n      //    integer.\n      //\n      // Returns:\n      //    Rand (String): Pseudo-random, alphanumeric string.\n      random_str : function () {\n        if (!this.fidx) {\n          this.fidx = 0;\n        }\n        this.prefix = this.prefix || [(this.name || 'F'), (+new Date).toString(36)].join('-');\n\n        return this.prefix + (this.fidx++).toString(36);\n      },\n\n      // Description:\n      //    Helper for window.matchMedia\n      //\n      // Arguments:\n      //    mq (String): Media query\n      //\n      // Returns:\n      //    (Boolean): Whether the media query passes or not\n      match : function (mq) {\n        return window.matchMedia(mq).matches;\n      },\n\n      // Description:\n      //    Helpers for checking Foundation default media queries with JS\n      //\n      // Returns:\n      //    (Boolean): Whether the media query passes or not\n\n      is_small_up : function () {\n        return this.match(Foundation.media_queries.small);\n      },\n\n      is_medium_up : function () {\n        return this.match(Foundation.media_queries.medium);\n      },\n\n      is_large_up : function () {\n        return this.match(Foundation.media_queries.large);\n      },\n\n      is_xlarge_up : function () {\n        return this.match(Foundation.media_queries.xlarge);\n      },\n\n      is_xxlarge_up : function () {\n        return this.match(Foundation.media_queries.xxlarge);\n      },\n\n      is_small_only : function () {\n        return !this.is_medium_up() && !this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();\n      },\n\n      is_medium_only : function () {\n        return this.is_medium_up() && !this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();\n      },\n\n      is_large_only : function () {\n        return this.is_medium_up() && this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();\n      },\n\n      is_xlarge_only : function () {\n        return this.is_medium_up() && this.is_large_up() && this.is_xlarge_up() && !this.is_xxlarge_up();\n      },\n\n      is_xxlarge_only : function () {\n        return this.is_medium_up() && this.is_large_up() && this.is_xlarge_up() && this.is_xxlarge_up();\n      }\n    }\n  };\n\n  $.fn.foundation = function () {\n    var args = Array.prototype.slice.call(arguments, 0);\n\n    return this.each(function () {\n      Foundation.init.apply(Foundation, [this].concat(args));\n      return this;\n    });\n  };\n\n}(jQuery, window, window.document));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/foundation/js/foundation/foundation.js\n ** module id = 8\n ** module chunks = 0\n **/",";(function ($, window, document, undefined) {\n  'use strict';\n\n  Foundation.libs.interchange = {\n    name : 'interchange',\n\n    version : '5.5.3',\n\n    cache : {},\n\n    images_loaded : false,\n    nodes_loaded : false,\n\n    settings : {\n      load_attr : 'interchange',\n\n      named_queries : {\n        'default'     : 'only screen',\n        'small'       : Foundation.media_queries['small'],\n        'small-only'  : Foundation.media_queries['small-only'],\n        'medium'      : Foundation.media_queries['medium'],\n        'medium-only' : Foundation.media_queries['medium-only'],\n        'large'       : Foundation.media_queries['large'],\n        'large-only'  : Foundation.media_queries['large-only'],\n        'xlarge'      : Foundation.media_queries['xlarge'],\n        'xlarge-only' : Foundation.media_queries['xlarge-only'],\n        'xxlarge'     : Foundation.media_queries['xxlarge'],\n        'landscape'   : 'only screen and (orientation: landscape)',\n        'portrait'    : 'only screen and (orientation: portrait)',\n        'retina'      : 'only screen and (-webkit-min-device-pixel-ratio: 2),' +\n          'only screen and (min--moz-device-pixel-ratio: 2),' +\n          'only screen and (-o-min-device-pixel-ratio: 2/1),' +\n          'only screen and (min-device-pixel-ratio: 2),' +\n          'only screen and (min-resolution: 192dpi),' +\n          'only screen and (min-resolution: 2dppx)'\n      },\n\n      directives : {\n        replace : function (el, path, trigger) {\n          // The trigger argument, if called within the directive, fires\n          // an event named after the directive on the element, passing\n          // any parameters along to the event that you pass to trigger.\n          //\n          // ex. trigger(), trigger([a, b, c]), or trigger(a, b, c)\n          //\n          // This allows you to bind a callback like so:\n          // $('#interchangeContainer').on('replace', function (e, a, b, c) {\n          //   console.log($(this).html(), a, b, c);\n          // });\n\n          if (el !== null && /IMG/.test(el[0].nodeName)) {\n            var orig_path = $.each(el, function(){this.src = path;});\n            // var orig_path = el[0].src;\n\n            if (new RegExp(path, 'i').test(orig_path)) {\n              return;\n            }\n\n            el.attr(\"src\", path);\n\n            return trigger(el[0].src);\n          }\n          var last_path = el.data(this.data_attr + '-last-path'),\n              self = this;\n\n          if (last_path == path) {\n            return;\n          }\n\n          if (/\\.(gif|jpg|jpeg|tiff|png)([?#].*)?/i.test(path)) {\n            $(el).css('background-image', 'url(' + path + ')');\n            el.data('interchange-last-path', path);\n            return trigger(path);\n          }\n\n          return $.get(path, function (response) {\n            el.html(response);\n            el.data(self.data_attr + '-last-path', path);\n            trigger();\n          });\n\n        }\n      }\n    },\n\n    init : function (scope, method, options) {\n      Foundation.inherit(this, 'throttle random_str');\n\n      this.data_attr = this.set_data_attr();\n      $.extend(true, this.settings, method, options);\n      this.bindings(method, options);\n      this.reflow();\n    },\n\n    get_media_hash : function () {\n        var mediaHash = '';\n        for (var queryName in this.settings.named_queries ) {\n            mediaHash += matchMedia(this.settings.named_queries[queryName]).matches.toString();\n        }\n        return mediaHash;\n    },\n\n    events : function () {\n      var self = this, prevMediaHash;\n\n      $(window)\n        .off('.interchange')\n        .on('resize.fndtn.interchange', self.throttle(function () {\n            var currMediaHash = self.get_media_hash();\n            if (currMediaHash !== prevMediaHash) {\n                self.resize();\n            }\n            prevMediaHash = currMediaHash;\n        }, 50));\n\n      return this;\n    },\n\n    resize : function () {\n      var cache = this.cache;\n\n      if (!this.images_loaded || !this.nodes_loaded) {\n        setTimeout($.proxy(this.resize, this), 50);\n        return;\n      }\n\n      for (var uuid in cache) {\n        if (cache.hasOwnProperty(uuid)) {\n          var passed = this.results(uuid, cache[uuid]);\n          if (passed) {\n            this.settings.directives[passed\n              .scenario[1]].call(this, passed.el, passed.scenario[0], (function (passed) {\n                if (arguments[0] instanceof Array) {\n                  var args = arguments[0];\n                } else {\n                  var args = Array.prototype.slice.call(arguments, 0);\n                }\n\n                return function() {\n                  passed.el.trigger(passed.scenario[1], args);\n                }\n              }(passed)));\n          }\n        }\n      }\n\n    },\n\n    results : function (uuid, scenarios) {\n      var count = scenarios.length;\n\n      if (count > 0) {\n        var el = this.S('[' + this.add_namespace('data-uuid') + '=\"' + uuid + '\"]');\n\n        while (count--) {\n          var mq, rule = scenarios[count][2];\n          if (this.settings.named_queries.hasOwnProperty(rule)) {\n            mq = matchMedia(this.settings.named_queries[rule]);\n          } else {\n            mq = matchMedia(rule);\n          }\n          if (mq.matches) {\n            return {el : el, scenario : scenarios[count]};\n          }\n        }\n      }\n\n      return false;\n    },\n\n    load : function (type, force_update) {\n      if (typeof this['cached_' + type] === 'undefined' || force_update) {\n        this['update_' + type]();\n      }\n\n      return this['cached_' + type];\n    },\n\n    update_images : function () {\n      var images = this.S('img[' + this.data_attr + ']'),\n          count = images.length,\n          i = count,\n          loaded_count = 0,\n          data_attr = this.data_attr;\n\n      this.cache = {};\n      this.cached_images = [];\n      this.images_loaded = (count === 0);\n\n      while (i--) {\n        loaded_count++;\n        if (images[i]) {\n          var str = images[i].getAttribute(data_attr) || '';\n\n          if (str.length > 0) {\n            this.cached_images.push(images[i]);\n          }\n        }\n\n        if (loaded_count === count) {\n          this.images_loaded = true;\n          this.enhance('images');\n        }\n      }\n\n      return this;\n    },\n\n    update_nodes : function () {\n      var nodes = this.S('[' + this.data_attr + ']').not('img'),\n          count = nodes.length,\n          i = count,\n          loaded_count = 0,\n          data_attr = this.data_attr;\n\n      this.cached_nodes = [];\n      this.nodes_loaded = (count === 0);\n\n      while (i--) {\n        loaded_count++;\n        var str = nodes[i].getAttribute(data_attr) || '';\n\n        if (str.length > 0) {\n          this.cached_nodes.push(nodes[i]);\n        }\n\n        if (loaded_count === count) {\n          this.nodes_loaded = true;\n          this.enhance('nodes');\n        }\n      }\n\n      return this;\n    },\n\n    enhance : function (type) {\n      var i = this['cached_' + type].length;\n\n      while (i--) {\n        this.object($(this['cached_' + type][i]));\n      }\n\n      return $(window).trigger('resize.fndtn.interchange');\n    },\n\n    convert_directive : function (directive) {\n\n      var trimmed = this.trim(directive);\n\n      if (trimmed.length > 0) {\n        return trimmed;\n      }\n\n      return 'replace';\n    },\n\n    parse_scenario : function (scenario) {\n      // This logic had to be made more complex since some users were using commas in the url path\n      // So we cannot simply just split on a comma\n\n      var directive_match = scenario[0].match(/(.+),\\s*(\\w+)\\s*$/),\n      // getting the mq has gotten a bit complicated since we started accounting for several use cases\n      // of URLs. For now we'll continue to match these scenarios, but we may consider having these scenarios\n      // as nested objects or arrays in F6.\n      // regex: match everything before close parenthesis for mq\n      media_query         = scenario[1].match(/(.*)\\)/);\n\n      if (directive_match) {\n        var path  = directive_match[1],\n        directive = directive_match[2];\n\n      } else {\n        var cached_split = scenario[0].split(/,\\s*$/),\n        path             = cached_split[0],\n        directive        = '';\n      }\n\n      return [this.trim(path), this.convert_directive(directive), this.trim(media_query[1])];\n    },\n\n    object : function (el) {\n      var raw_arr = this.parse_data_attr(el),\n          scenarios = [],\n          i = raw_arr.length;\n\n      if (i > 0) {\n        while (i--) {\n          // split array between comma delimited content and mq\n          // regex: comma, optional space, open parenthesis\n          var scenario = raw_arr[i].split(/,\\s?\\(/);\n\n          if (scenario.length > 1) {\n            var params = this.parse_scenario(scenario);\n            scenarios.push(params);\n          }\n        }\n      }\n\n      return this.store(el, scenarios);\n    },\n\n    store : function (el, scenarios) {\n      var uuid = this.random_str(),\n          current_uuid = el.data(this.add_namespace('uuid', true));\n\n      if (this.cache[current_uuid]) {\n        return this.cache[current_uuid];\n      }\n\n      el.attr(this.add_namespace('data-uuid'), uuid);\n      return this.cache[uuid] = scenarios;\n    },\n\n    trim : function (str) {\n\n      if (typeof str === 'string') {\n        return $.trim(str);\n      }\n\n      return str;\n    },\n\n    set_data_attr : function (init) {\n      if (init) {\n        if (this.namespace.length > 0) {\n          return this.namespace + '-' + this.settings.load_attr;\n        }\n\n        return this.settings.load_attr;\n      }\n\n      if (this.namespace.length > 0) {\n        return 'data-' + this.namespace + '-' + this.settings.load_attr;\n      }\n\n      return 'data-' + this.settings.load_attr;\n    },\n\n    parse_data_attr : function (el) {\n      var raw = el.attr(this.attr_name()).split(/\\[(.*?)\\]/),\n          i = raw.length,\n          output = [];\n\n      while (i--) {\n        if (raw[i].replace(/[\\W\\d]+/, '').length > 4) {\n          output.push(raw[i]);\n        }\n      }\n\n      return output;\n    },\n\n    reflow : function () {\n      this.load('images', true);\n      this.load('nodes', true);\n    }\n\n  };\n\n}(jQuery, window, window.document));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/foundation/js/foundation/foundation.interchange.js\n ** module id = 9\n ** module chunks = 0\n **/",";(function ($, window, document, undefined) {\n  'use strict';\n\n  var openModals = [];\n\n  Foundation.libs.reveal = {\n    name : 'reveal',\n\n    version : '5.5.3',\n\n    locked : false,\n\n    settings : {\n      animation : 'fadeAndPop',\n      animation_speed : 250,\n      close_on_background_click : true,\n      close_on_esc : true,\n      dismiss_modal_class : 'close-reveal-modal',\n      multiple_opened : false,\n      bg_class : 'reveal-modal-bg',\n      root_element : 'body',\n      open : function(){},\n      opened : function(){},\n      close : function(){},\n      closed : function(){},\n      on_ajax_error: $.noop,\n      bg : $('.reveal-modal-bg'),\n      css : {\n        open : {\n          'opacity' : 0,\n          'visibility' : 'visible',\n          'display' : 'block'\n        },\n        close : {\n          'opacity' : 1,\n          'visibility' : 'hidden',\n          'display' : 'none'\n        }\n      }\n    },\n\n    init : function (scope, method, options) {\n      $.extend(true, this.settings, method, options);\n      this.bindings(method, options);\n    },\n\n    events : function (scope) {\n      var self = this,\n          S = self.S;\n\n      S(this.scope)\n        .off('.reveal')\n        .on('click.fndtn.reveal', '[' + this.add_namespace('data-reveal-id') + ']:not([disabled])', function (e) {\n          e.preventDefault();\n\n          if (!self.locked) {\n            var element = S(this),\n                ajax = element.data(self.data_attr('reveal-ajax')),\n                replaceContentSel = element.data(self.data_attr('reveal-replace-content'));\n\n            self.locked = true;\n\n            if (typeof ajax === 'undefined') {\n              self.open.call(self, element);\n            } else {\n              var url = ajax === true ? element.attr('href') : ajax;\n              self.open.call(self, element, {url : url}, { replaceContentSel : replaceContentSel });\n            }\n          }\n        });\n\n      S(document)\n        .on('click.fndtn.reveal', this.close_targets(), function (e) {\n          e.preventDefault();\n          if (!self.locked) {\n            var settings = S('[' + self.attr_name() + '].open').data(self.attr_name(true) + '-init') || self.settings,\n                bg_clicked = S(e.target)[0] === S('.' + settings.bg_class)[0];\n\n            if (bg_clicked) {\n              if (settings.close_on_background_click) {\n                e.stopPropagation();\n              } else {\n                return;\n              }\n            }\n\n            self.locked = true;\n            self.close.call(self, bg_clicked ? S('[' + self.attr_name() + '].open:not(.toback)') : S(this).closest('[' + self.attr_name() + ']'));\n          }\n        });\n\n      if (S('[' + self.attr_name() + ']', this.scope).length > 0) {\n        S(this.scope)\n          // .off('.reveal')\n          .on('open.fndtn.reveal', this.settings.open)\n          .on('opened.fndtn.reveal', this.settings.opened)\n          .on('opened.fndtn.reveal', this.open_video)\n          .on('close.fndtn.reveal', this.settings.close)\n          .on('closed.fndtn.reveal', this.settings.closed)\n          .on('closed.fndtn.reveal', this.close_video);\n      } else {\n        S(this.scope)\n          // .off('.reveal')\n          .on('open.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.open)\n          .on('opened.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.opened)\n          .on('opened.fndtn.reveal', '[' + self.attr_name() + ']', this.open_video)\n          .on('close.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.close)\n          .on('closed.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.closed)\n          .on('closed.fndtn.reveal', '[' + self.attr_name() + ']', this.close_video);\n      }\n\n      return true;\n    },\n\n    // PATCH #3: turning on key up capture only when a reveal window is open\n    key_up_on : function (scope) {\n      var self = this;\n\n      // PATCH #1: fixing multiple keyup event trigger from single key press\n      self.S('body').off('keyup.fndtn.reveal').on('keyup.fndtn.reveal', function ( event ) {\n        var open_modal = self.S('[' + self.attr_name() + '].open'),\n            settings = open_modal.data(self.attr_name(true) + '-init') || self.settings ;\n        // PATCH #2: making sure that the close event can be called only while unlocked,\n        //           so that multiple keyup.fndtn.reveal events don't prevent clean closing of the reveal window.\n        if ( settings && event.which === 27  && settings.close_on_esc && !self.locked) { // 27 is the keycode for the Escape key\n          self.close.call(self, open_modal);\n        }\n      });\n\n      return true;\n    },\n\n    // PATCH #3: turning on key up capture only when a reveal window is open\n    key_up_off : function (scope) {\n      this.S('body').off('keyup.fndtn.reveal');\n      return true;\n    },\n\n    open : function (target, ajax_settings) {\n      var self = this,\n          modal;\n\n      if (target) {\n        if (typeof target.selector !== 'undefined') {\n          // Find the named node; only use the first one found, since the rest of the code assumes there's only one node\n          modal = self.S('#' + target.data(self.data_attr('reveal-id'))).first();\n        } else {\n          modal = self.S(this.scope);\n\n          ajax_settings = target;\n        }\n      } else {\n        modal = self.S(this.scope);\n      }\n\n      var settings = modal.data(self.attr_name(true) + '-init');\n      settings = settings || this.settings;\n\n\n      if (modal.hasClass('open') && target !== undefined && target.attr('data-reveal-id') == modal.attr('id')) {\n        return self.close(modal);\n      }\n\n      if (!modal.hasClass('open')) {\n        var open_modal = self.S('[' + self.attr_name() + '].open');\n\n        if (typeof modal.data('css-top') === 'undefined') {\n          modal.data('css-top', parseInt(modal.css('top'), 10))\n            .data('offset', this.cache_offset(modal));\n        }\n\n        modal.attr('tabindex','0').attr('aria-hidden','false');\n\n        this.key_up_on(modal);    // PATCH #3: turning on key up capture only when a reveal window is open\n\n        // Prevent namespace event from triggering twice\n        modal.on('open.fndtn.reveal', function(e) {\n          if (e.namespace !== 'fndtn.reveal') return;\n        });\n\n        modal.on('open.fndtn.reveal').trigger('open.fndtn.reveal');\n\n        if (open_modal.length < 1) {\n          this.toggle_bg(modal, true);\n        }\n\n        if (typeof ajax_settings === 'string') {\n          ajax_settings = {\n            url : ajax_settings\n          };\n        }\n\n        var openModal = function() {\n          if(open_modal.length > 0) {\n            if(settings.multiple_opened) {\n              self.to_back(open_modal);\n            } else {\n              self.hide(open_modal, settings.css.close);\n            }\n          }\n\n          // bl: add the open_modal that isn't already in the background to the openModals array\n          if(settings.multiple_opened) {\n            openModals.push(modal);\n          }\n\n          self.show(modal, settings.css.open);\n        };\n\n        if (typeof ajax_settings === 'undefined' || !ajax_settings.url) {\n          openModal();\n        } else {\n          var old_success = typeof ajax_settings.success !== 'undefined' ? ajax_settings.success : null;\n          $.extend(ajax_settings, {\n            success : function (data, textStatus, jqXHR) {\n              if ( $.isFunction(old_success) ) {\n                var result = old_success(data, textStatus, jqXHR);\n                if (typeof result == 'string') {\n                  data = result;\n                }\n              }\n\n              if (typeof options !== 'undefined' && typeof options.replaceContentSel !== 'undefined') {\n                modal.find(options.replaceContentSel).html(data);\n              } else {\n                modal.html(data);\n              }\n\n              self.S(modal).foundation('section', 'reflow');\n              self.S(modal).children().foundation();\n\n              openModal();\n            }\n          });\n\n          // check for if user initalized with error callback\n          if (settings.on_ajax_error !== $.noop) {\n            $.extend(ajax_settings, {\n              error : settings.on_ajax_error\n            });\n          }\n\n          $.ajax(ajax_settings);\n        }\n      }\n      self.S(window).trigger('resize');\n    },\n\n    close : function (modal) {\n      var modal = modal && modal.length ? modal : this.S(this.scope),\n          open_modals = this.S('[' + this.attr_name() + '].open'),\n          settings = modal.data(this.attr_name(true) + '-init') || this.settings,\n          self = this;\n\n      if (open_modals.length > 0) {\n\n        modal.removeAttr('tabindex','0').attr('aria-hidden','true');\n\n        this.locked = true;\n        this.key_up_off(modal);   // PATCH #3: turning on key up capture only when a reveal window is open\n\n        modal.trigger('close.fndtn.reveal');\n\n        if ((settings.multiple_opened && open_modals.length === 1) || !settings.multiple_opened || modal.length > 1) {\n          self.toggle_bg(modal, false);\n          self.to_front(modal);\n        }\n\n        if (settings.multiple_opened) {\n          var isCurrent = modal.is(':not(.toback)');\n          self.hide(modal, settings.css.close, settings);\n          if(isCurrent) {\n            // remove the last modal since it is now closed\n            openModals.pop();\n          } else {\n            // if this isn't the current modal, then find it in the array and remove it\n            openModals = $.grep(openModals, function(elt) {\n              var isThis = elt[0]===modal[0];\n              if(isThis) {\n                // since it's not currently in the front, put it in the front now that it is hidden\n                // so that if it's re-opened, it won't be .toback\n                self.to_front(modal);\n              }\n              return !isThis;\n            });\n          }\n          // finally, show the next modal in the stack, if there is one\n          if(openModals.length>0) {\n            self.to_front(openModals[openModals.length - 1]);\n          }\n        } else {\n          self.hide(open_modals, settings.css.close, settings);\n        }\n      }\n    },\n\n    close_targets : function () {\n      var base = '.' + this.settings.dismiss_modal_class;\n\n      if (this.settings.close_on_background_click) {\n        return base + ', .' + this.settings.bg_class;\n      }\n\n      return base;\n    },\n\n    toggle_bg : function (modal, state) {\n      if (this.S('.' + this.settings.bg_class).length === 0) {\n        this.settings.bg = $('<div />', {'class': this.settings.bg_class})\n          .appendTo('body').hide();\n      }\n\n      var visible = this.settings.bg.filter(':visible').length > 0;\n      if ( state != visible ) {\n        if ( state == undefined ? visible : !state ) {\n          this.hide(this.settings.bg);\n        } else {\n          this.show(this.settings.bg);\n        }\n      }\n    },\n\n    show : function (el, css) {\n      // is modal\n      if (css) {\n        var settings = el.data(this.attr_name(true) + '-init') || this.settings,\n            root_element = settings.root_element,\n            context = this;\n\n        if (el.parent(root_element).length === 0) {\n          var placeholder = el.wrap('<div style=\"display: none;\" />').parent();\n\n          el.on('closed.fndtn.reveal.wrapped', function () {\n            el.detach().appendTo(placeholder);\n            el.unwrap().unbind('closed.fndtn.reveal.wrapped');\n          });\n\n          el.detach().appendTo(root_element);\n        }\n\n        var animData = getAnimationData(settings.animation);\n        if (!animData.animate) {\n          this.locked = false;\n        }\n        if (animData.pop) {\n          css.top = $(window).scrollTop() - el.data('offset') + 'px';\n          var end_css = {\n            top: $(window).scrollTop() + el.data('css-top') + 'px',\n            opacity: 1\n          };\n\n          return setTimeout(function () {\n            return el\n              .css(css)\n              .animate(end_css, settings.animation_speed, 'linear', function () {\n                context.locked = false;\n                el.trigger('opened.fndtn.reveal');\n              })\n              .addClass('open');\n          }, settings.animation_speed / 2);\n        }\n\n        css.top = $(window).scrollTop() + el.data('css-top') + 'px';\n\n        if (animData.fade) {\n          var end_css = {opacity: 1};\n\n          return setTimeout(function () {\n            return el\n              .css(css)\n              .animate(end_css, settings.animation_speed, 'linear', function () {\n                context.locked = false;\n                el.trigger('opened.fndtn.reveal');\n              })\n              .addClass('open');\n          }, settings.animation_speed / 2);\n        }\n\n        return el.css(css).show().css({opacity : 1}).addClass('open').trigger('opened.fndtn.reveal');\n      }\n\n      var settings = this.settings;\n\n      // should we animate the background?\n      if (getAnimationData(settings.animation).fade) {\n        return el.fadeIn(settings.animation_speed / 2);\n      }\n\n      this.locked = false;\n\n      return el.show();\n    },\n\n    to_back : function(el) {\n      el.addClass('toback');\n    },\n\n    to_front : function(el) {\n      el.removeClass('toback');\n    },\n\n    hide : function (el, css) {\n      // is modal\n      if (css) {\n        var settings = el.data(this.attr_name(true) + '-init'),\n            context = this;\n        settings = settings || this.settings;\n\n        var animData = getAnimationData(settings.animation);\n        if (!animData.animate) {\n          this.locked = false;\n        }\n        if (animData.pop) {\n          var end_css = {\n            top: - $(window).scrollTop() - el.data('offset') + 'px',\n            opacity: 0\n          };\n\n          return setTimeout(function () {\n            return el\n              .animate(end_css, settings.animation_speed, 'linear', function () {\n                context.locked = false;\n                el.css(css).trigger('closed.fndtn.reveal');\n              })\n              .removeClass('open');\n          }, settings.animation_speed / 2);\n        }\n\n        if (animData.fade) {\n          var end_css = {opacity : 0};\n\n          return setTimeout(function () {\n            return el\n              .animate(end_css, settings.animation_speed, 'linear', function () {\n                context.locked = false;\n                el.css(css).trigger('closed.fndtn.reveal');\n              })\n              .removeClass('open');\n          }, settings.animation_speed / 2);\n        }\n\n        return el.hide().css(css).removeClass('open').trigger('closed.fndtn.reveal');\n      }\n\n      var settings = this.settings;\n\n      // should we animate the background?\n      if (getAnimationData(settings.animation).fade) {\n        return el.fadeOut(settings.animation_speed / 2);\n      }\n\n      return el.hide();\n    },\n\n    close_video : function (e) {\n      var video = $('.flex-video', e.target),\n          iframe = $('iframe', video);\n\n      if (iframe.length > 0) {\n        iframe.attr('data-src', iframe[0].src);\n        iframe.attr('src', iframe.attr('src'));\n        video.hide();\n      }\n    },\n\n    open_video : function (e) {\n      var video = $('.flex-video', e.target),\n          iframe = video.find('iframe');\n\n      if (iframe.length > 0) {\n        var data_src = iframe.attr('data-src');\n        if (typeof data_src === 'string') {\n          iframe[0].src = iframe.attr('data-src');\n        } else {\n          var src = iframe[0].src;\n          iframe[0].src = undefined;\n          iframe[0].src = src;\n        }\n        video.show();\n      }\n    },\n\n    data_attr : function (str) {\n      if (this.namespace.length > 0) {\n        return this.namespace + '-' + str;\n      }\n\n      return str;\n    },\n\n    cache_offset : function (modal) {\n      var offset = modal.show().height() + parseInt(modal.css('top'), 10) + modal.scrollY;\n\n      modal.hide();\n\n      return offset;\n    },\n\n    off : function () {\n      $(this.scope).off('.fndtn.reveal');\n    },\n\n    reflow : function () {}\n  };\n\n  /*\n   * getAnimationData('popAndFade') // {animate: true,  pop: true,  fade: true}\n   * getAnimationData('fade')       // {animate: true,  pop: false, fade: true}\n   * getAnimationData('pop')        // {animate: true,  pop: true,  fade: false}\n   * getAnimationData('foo')        // {animate: false, pop: false, fade: false}\n   * getAnimationData(null)         // {animate: false, pop: false, fade: false}\n   */\n  function getAnimationData(str) {\n    var fade = /fade/i.test(str);\n    var pop = /pop/i.test(str);\n    return {\n      animate : fade || pop,\n      pop : pop,\n      fade : fade\n    };\n  }\n}(jQuery, window, window.document));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/foundation/js/foundation/foundation.reveal.js\n ** module id = 10\n ** module chunks = 0\n **/",";(function ($, window, document, undefined) {\n  'use strict';\n\n  Foundation.libs.tab = {\n    name : 'tab',\n\n    version : '5.5.3',\n\n    settings : {\n      active_class : 'active',\n      callback : function () {},\n      deep_linking : false,\n      scroll_to_content : true,\n      is_hover : false\n    },\n\n    default_tab_hashes : [],\n\n    init : function (scope, method, options) {\n      var self = this,\n          S = this.S;\n\n  \t  // Store the default active tabs which will be referenced when the\n  \t  // location hash is absent, as in the case of navigating the tabs and\n  \t  // returning to the first viewing via the browser Back button.\n  \t  S('[' + this.attr_name() + '] > .active > a', this.scope).each(function () {\n  \t    self.default_tab_hashes.push(this.hash);\n  \t  });\n\n      this.bindings(method, options);\n      this.handle_location_hash_change();\n    },\n\n    events : function () {\n      var self = this,\n          S = this.S;\n\n      var usual_tab_behavior =  function (e, target) {\n        var settings = S(target).closest('[' + self.attr_name() + ']').data(self.attr_name(true) + '-init');\n        if (!settings.is_hover || Modernizr.touch) {\n          // if user did not pressed tab key, prevent default action\n          var keyCode = e.keyCode || e.which;\n          if (keyCode !== 9) { \n            e.preventDefault();\n            e.stopPropagation();\n          }\n          self.toggle_active_tab(S(target).parent());\n          \n        }\n      };\n\n      S(this.scope)\n        .off('.tab')\n        // Key event: focus/tab key\n        .on('keydown.fndtn.tab', '[' + this.attr_name() + '] > * > a', function(e) {\n          var keyCode = e.keyCode || e.which;\n          // if user pressed tab key\n          if (keyCode === 13 || keyCode === 32) { // enter or space\n            var el = this;\n            usual_tab_behavior(e, el);\n          } \n        })\n        // Click event: tab title\n        .on('click.fndtn.tab', '[' + this.attr_name() + '] > * > a', function(e) {\n          var el = this;\n          usual_tab_behavior(e, el);\n        })\n        // Hover event: tab title\n        .on('mouseenter.fndtn.tab', '[' + this.attr_name() + '] > * > a', function (e) {\n          var settings = S(this).closest('[' + self.attr_name() + ']').data(self.attr_name(true) + '-init');\n          if (settings.is_hover) {\n            self.toggle_active_tab(S(this).parent());\n          }\n        });\n\n      // Location hash change event\n      S(window).on('hashchange.fndtn.tab', function (e) {\n        e.preventDefault();\n        self.handle_location_hash_change();\n      });\n    },\n\n    handle_location_hash_change : function () {\n\n      var self = this,\n          S = this.S;\n\n      S('[' + this.attr_name() + ']', this.scope).each(function () {\n        var settings = S(this).data(self.attr_name(true) + '-init');\n        if (settings.deep_linking) {\n          // Match the location hash to a label\n          var hash;\n          if (settings.scroll_to_content) {\n            hash = self.scope.location.hash;\n          } else {\n            // prefix the hash to prevent anchor scrolling\n            hash = self.scope.location.hash.replace('fndtn-', '');\n          }\n          if (hash != '') {\n            // Check whether the location hash references a tab content div or\n            // another element on the page (inside or outside the tab content div)\n            var hash_element = S(hash);\n            if (hash_element.hasClass('content') && hash_element.parent().hasClass('tabs-content')) {\n              // Tab content div\n              self.toggle_active_tab($('[' + self.attr_name() + '] > * > a[href=' + hash + ']').parent());\n            } else {\n              // Not the tab content div. If inside the tab content, find the\n              // containing tab and toggle it as active.\n              var hash_tab_container_id = hash_element.closest('.content').attr('id');\n              if (hash_tab_container_id != undefined) {\n                self.toggle_active_tab($('[' + self.attr_name() + '] > * > a[href=#' + hash_tab_container_id + ']').parent(), hash);\n              }\n            }\n          } else {\n            // Reference the default tab hashes which were initialized in the init function\n            for (var ind = 0; ind < self.default_tab_hashes.length; ind++) {\n              self.toggle_active_tab($('[' + self.attr_name() + '] > * > a[href=' + self.default_tab_hashes[ind] + ']').parent());\n            }\n          }\n        }\n       });\n     },\n\n    toggle_active_tab : function (tab, location_hash) {\n      var self = this,\n          S = self.S,\n          tabs = tab.closest('[' + this.attr_name() + ']'),\n          tab_link = tab.find('a'),\n          anchor = tab.children('a').first(),\n          target_hash = '#' + anchor.attr('href').split('#')[1],\n          target = S(target_hash),\n          siblings = tab.siblings(),\n          settings = tabs.data(this.attr_name(true) + '-init'),\n          interpret_keyup_action = function (e) {\n            // Light modification of Heydon Pickering's Practical ARIA Examples: http://heydonworks.com/practical_aria_examples/js/a11y.js\n\n            // define current, previous and next (possible) tabs\n\n            var $original = $(this);\n            var $prev = $(this).parents('li').prev().children('[role=\"tab\"]');\n            var $next = $(this).parents('li').next().children('[role=\"tab\"]');\n            var $target;\n\n            // find the direction (prev or next)\n\n            switch (e.keyCode) {\n              case 37:\n                $target = $prev;\n                break;\n              case 39:\n                $target = $next;\n                break;\n              default:\n                $target = false\n                  break;\n            }\n\n            if ($target.length) {\n              $original.attr({\n                'tabindex' : '-1',\n                'aria-selected' : null\n              });\n              $target.attr({\n                'tabindex' : '0',\n                'aria-selected' : true\n              }).focus();\n            }\n\n            // Hide panels\n\n            $('[role=\"tabpanel\"]')\n              .attr('aria-hidden', 'true');\n\n            // Show panel which corresponds to target\n\n            $('#' + $(document.activeElement).attr('href').substring(1))\n              .attr('aria-hidden', null);\n\n          },\n          go_to_hash = function(hash) {\n            // This function allows correct behaviour of the browser's back button when deep linking is enabled. Without it\n            // the user would get continually redirected to the default hash.\n            var default_hash = settings.scroll_to_content ? self.default_tab_hashes[0] : 'fndtn-' + self.default_tab_hashes[0].replace('#', '');\n\n            if (hash !== default_hash || window.location.hash) {\n              window.location.hash = hash;\n            }\n          };\n\n      // allow usage of data-tab-content attribute instead of href\n      if (anchor.data('tab-content')) {\n        target_hash = '#' + anchor.data('tab-content').split('#')[1];\n        target = S(target_hash);\n      }\n\n      if (settings.deep_linking) {\n\n        if (settings.scroll_to_content) {\n\n          // retain current hash to scroll to content\n          go_to_hash(location_hash || target_hash);\n\n          if (location_hash == undefined || location_hash == target_hash) {\n            tab.parent()[0].scrollIntoView();\n          } else {\n            S(target_hash)[0].scrollIntoView();\n          }\n        } else {\n          // prefix the hashes so that the browser doesn't scroll down\n          if (location_hash != undefined) {\n            go_to_hash('fndtn-' + location_hash.replace('#', ''));\n          } else {\n            go_to_hash('fndtn-' + target_hash.replace('#', ''));\n          }\n        }\n      }\n\n      // WARNING: The activation and deactivation of the tab content must\n      // occur after the deep linking in order to properly refresh the browser\n      // window (notably in Chrome).\n      // Clean up multiple attr instances to done once\n      tab.addClass(settings.active_class).triggerHandler('opened');\n      tab_link.attr({'aria-selected' : 'true',  tabindex : 0});\n      siblings.removeClass(settings.active_class)\n      siblings.find('a').attr({'aria-selected' : 'false'/*,  tabindex : -1*/});\n      target.siblings().removeClass(settings.active_class).attr({'aria-hidden' : 'true'/*,  tabindex : -1*/});\n      target.addClass(settings.active_class).attr('aria-hidden', 'false').removeAttr('tabindex');\n      settings.callback(tab);\n      target.triggerHandler('toggled', [target]);\n      tabs.triggerHandler('toggled', [tab]);\n\n      tab_link.off('keydown').on('keydown', interpret_keyup_action );\n    },\n\n    data_attr : function (str) {\n      if (this.namespace.length > 0) {\n        return this.namespace + '-' + str;\n      }\n\n      return str;\n    },\n\n    off : function () {},\n\n    reflow : function () {}\n  };\n}(jQuery, window, window.document));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/foundation/js/foundation/foundation.tab.js\n ** module id = 11\n ** module chunks = 0\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// TODO actually recognize syntax of TypeScript constructs\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    var jsKeywords = {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": kw(\"new\"), \"delete\": C, \"throw\": C, \"debugger\": C,\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"async\": kw(\"async\"), \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"await\": C, \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"variable-3\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"interface\"),\n        \"extends\": kw(\"extends\"),\n        \"constructor\": kw(\"constructor\"),\n\n        // scope modifiers\n        \"public\": kw(\"public\"),\n        \"private\": kw(\"private\"),\n        \"protected\": kw(\"protected\"),\n        \"static\": kw(\"static\"),\n\n        // types\n        \"string\": type, \"number\": type, \"boolean\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/o/i)) {\n      stream.eatWhile(/[0-7]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/b/i)) {\n      stream.eatWhile(/[01]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (state.lastType == \"operator\" || state.lastType == \"keyword c\" ||\n                 state.lastType == \"sof\" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyu])(?![gimyu]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n                     ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) break;\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/]/.test(ch)) {\n        return;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"async\") return cont(expression);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"keyword c\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, comprehension, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (type == \"[\") {\n      return cont(expression, expect(\"]\"), afterprop);\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(what, proceed);\n      }\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (isTS && type == \":\") return cont(typedef);\n  }\n  function maybedefault(_, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function typedef(type) {\n    if (type == \"variable\") {cx.marked = \"variable-3\"; return cont();}\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, statement, popcontext);\n  }\n  function funarg(type) {\n    if (type == \"spread\") return cont(funarg);\n    return pass(pattern, maybetype, maybedefault);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"extends\") return cont(expression, classNameAfter);\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      if (value == \"static\") {\n        cx.marked = \"keyword\";\n        return cont(classBody);\n      }\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(classGetterSetter, functiondef, classBody);\n      return cont(functiondef, classBody);\n    }\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \";\") return cont(classBody);\n    if (type == \"}\") return cont();\n  }\n  function classGetterSetter(type) {\n    if (type != \"variable\") return pass();\n    cx.marked = \"property\";\n    return cont();\n  }\n  function afterExport(_type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    return pass(statement);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    return pass(importSpec, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(expressionNoComma, maybeArrayComprehension);\n  }\n  function maybeArrayComprehension(type) {\n    if (type == \"for\") return pass(comprehension, expect(\"]\"));\n    if (type == \",\") return cont(commasep(maybeexpressionNoComma, \"]\"));\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function comprehension(type) {\n    if (type == \"for\") return cont(forspec, comprehension);\n    if (type == \"if\") return cont(expression, comprehension);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/javascript/javascript.js\n ** module id = 12\n ** module chunks = 0\n **/","module.exports = global[\"CodeMirror\"] = require(\"-!/Users/pechinp/Work/es6-editor/node_modules/codemirror/lib/codemirror.js\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/lib/codemirror.js\n ** module id = 13\n ** module chunks = 0\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    module.exports = mod();\n  else if (typeof define == \"function\" && define.amd) // AMD\n    return define([], mod);\n  else // Plain browser env\n    this.CodeMirror = mod();\n})(function() {\n  \"use strict\";\n\n  // BROWSER SNIFFING\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n  var webkit = /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) presto_version = Number(presto_version[1]);\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // EDITOR CONSTRUCTOR\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n    setGuttersForLineNumbers(options);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n    if (options.autofocus && !mobile) display.input.focus();\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    var cm = this;\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || cm.hasFocus())\n      setTimeout(bind(onFocus, this), 20);\n    else\n      onBlur(this);\n\n    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n      optionHandlers[opt](this, options[opt], Init);\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) options.finishInit(this);\n    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      display.lineDiv.style.textRendering = \"auto\";\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\n    if (place) {\n      if (place.appendChild) place.appendChild(d.wrapper);\n      else place(d.wrapper);\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    input.init(d);\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line)) return 0;\n\n      var widgetsHeight = 0;\n      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n      }\n\n      if (wrapping)\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return widgetsHeight + th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n    updateGutterSpace(cm);\n  }\n\n  function updateGutterSpace(cm) {\n    var width = cm.display.gutters.offsetWidth;\n    cm.display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find(0, true);\n      len -= cur.text.length - found.from.ch;\n      cur = found.to.line;\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    };\n  }\n\n  function NativeScrollbars(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function() {\n      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n    });\n    on(horiz, \"scroll\", function() {\n      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n    });\n\n    this.checkedOverlay = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n  }\n\n  NativeScrollbars.prototype = copyObj({\n    update: function(measure) {\n      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n      var sWidth = measure.nativeBarWidth;\n\n      if (needsV) {\n        this.vert.style.display = \"block\";\n        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n        // A bug in IE8 can cause this value to be negative, so guard it.\n        this.vert.firstChild.style.height =\n          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n      } else {\n        this.vert.style.display = \"\";\n        this.vert.firstChild.style.height = \"0\";\n      }\n\n      if (needsH) {\n        this.horiz.style.display = \"block\";\n        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n        this.horiz.style.left = measure.barLeft + \"px\";\n        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n        this.horiz.firstChild.style.width =\n          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n      } else {\n        this.horiz.style.display = \"\";\n        this.horiz.firstChild.style.width = \"0\";\n      }\n\n      if (!this.checkedOverlay && measure.clientHeight > 0) {\n        if (sWidth == 0) this.overlayHack();\n        this.checkedOverlay = true;\n      }\n\n      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n    },\n    setScrollLeft: function(pos) {\n      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n    },\n    setScrollTop: function(pos) {\n      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n    },\n    overlayHack: function() {\n      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n      this.horiz.style.minHeight = this.vert.style.minWidth = w;\n      var self = this;\n      var barMouseDown = function(e) {\n        if (e_target(e) != self.vert && e_target(e) != self.horiz)\n          operation(self.cm, onMouseDown)(e);\n      };\n      on(this.vert, \"mousedown\", barMouseDown);\n      on(this.horiz, \"mousedown\", barMouseDown);\n    },\n    clear: function() {\n      var parent = this.horiz.parentNode;\n      parent.removeChild(this.horiz);\n      parent.removeChild(this.vert);\n    }\n  }, NativeScrollbars.prototype);\n\n  function NullScrollbars() {}\n\n  NullScrollbars.prototype = copyObj({\n    update: function() { return {bottom: 0, right: 0}; },\n    setScrollLeft: function() {},\n    setScrollTop: function() {},\n    clear: function() {}\n  }, NullScrollbars.prototype);\n\n  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n    }\n\n    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function() {\n        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function(pos, axis) {\n      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n      else setScrollTop(cm, pos);\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n  }\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) measure = measureForScrollbars(cm);\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        updateHeightsInViewport(cm);\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else d.gutterFiller.style.display = \"\";\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)};\n  }\n\n  // LINE NUMBERS\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n      if (cm.options.fixedGutter && view[i].gutter)\n        view[i].gutter.style.left = left;\n      var align = view[i].alignable;\n      if (align) for (var j = 0; j < align.length; j++)\n        align[j].style.left = left;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + \"px\";\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm);\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  }\n\n  // DISPLAY DRAWING\n\n  function DisplayUpdate(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  }\n\n  DisplayUpdate.prototype.signal = function(emitter, type) {\n    if (hasHandler(emitter, type))\n      this.events.push(arguments);\n  };\n  DisplayUpdate.prototype.finish = function() {\n    for (var i = 0; i < this.events.length; i++)\n      signal.apply(null, this.events[i]);\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      return false;\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      return false;\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var focused = activeElt();\n    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true;\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          break;\n      }\n      if (!updateDisplayIfNeeded(cm, update)) break;\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    var total = measure.docHeight + cm.display.barHeight;\n    cm.display.heightForcer.style.top = total + \"px\";\n    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + \"px\";\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], height;\n      if (cur.hidden) continue;\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n      }\n      var diff = cur.line.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n          updateWidgetHeight(cur.rest[j]);\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n      line.widgets[i].height = line.widgets[i].node.offsetHeight;\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[cm.options.gutters[i]] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        node.style.display = \"none\";\n      else\n        node.parentNode.removeChild(node);\n      return next;\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) {\n      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) cur = rm(cur);\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) cur = rm(cur);\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") updateLineText(cm, lineView);\n      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n      else if (type == \"class\") updateLineClasses(lineView);\n      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n    }\n    return lineView.node;\n  }\n\n  function updateLineBackground(lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) cls += \" CodeMirror-linebackground\";\n    if (lineView.background) {\n      if (cls) lineView.background.className = cls;\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built;\n    }\n    return buildLineContent(cm, lineView);\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) lineView.node = built.pre;\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(lineView) {\n    updateLineBackground(lineView);\n    if (lineView.line.wrapClass)\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n    else if (lineView.node != lineView.text)\n      lineView.node.className = \"\";\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        gutterWrap.className += \" \" + lineView.line.gutterClass;\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n              + cm.display.lineNumInnerWidth + \"px\"));\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n      }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) lineView.alignable = null;\n    for (var node = lineView.node.firstChild, next; node; node = next) {\n      var next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        lineView.node.removeChild(node);\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) lineView.bgClass = built.bgClass;\n    if (built.textClass) lineView.textClass = built.textClass;\n\n    updateLineClasses(lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node;\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) return;\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n      (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n    }\n  }\n\n  // POSITION OBJECT\n\n  // A Pos instance represents a position within the text.\n  var Pos = CodeMirror.Pos = function(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  };\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\n  function copyPos(x) {return Pos(x.line, x.ch);}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\n  // INPUT HANDLING\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.doc.cantEdit;\n  }\n\n  // This will be set to an array of strings when copying, so that,\n  // when pasting, we know what kind of selections the copied text\n  // was made out of.\n  var lastCopied = null;\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) sel = doc.sel;\n\n    var paste = cm.state.pasteIncoming || origin == \"paste\";\n    var textLines = doc.splitLines(inserted), multiPaste = null;\n    // When pasing N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.length; i++)\n            multiPaste.push(doc.splitLines(lastCopied[i]));\n        }\n      } else if (textLines.length == sel.ranges.length) {\n        multiPaste = map(textLines, function(l) { return [l]; });\n      }\n    }\n\n    // Normal behavior is to insert the new text into every selection\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          from = Pos(from.line, from.ch - deleted);\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n      }\n      var updateInput = cm.curOp.updateInput;\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      triggerElectric(cm, inserted);\n\n    ensureCursorVisible(cm);\n    cm.curOp.updateInput = updateInput;\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\n    if (pasted) {\n      e.preventDefault();\n      if (!isReadOnly(cm) && !cm.options.disableInput)\n        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n      return true;\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break;\n          }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          indented = indentLine(cm, range.head.line, \"smart\");\n      }\n      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges};\n  }\n\n  function disableBrowserMagic(field) {\n    field.setAttribute(\"autocorrect\", \"off\");\n    field.setAttribute(\"autocapitalize\", \"off\");\n    field.setAttribute(\"spellcheck\", \"false\");\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  function TextareaInput(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Tracks when input.reset has punted to just putting a short\n    // string into the textarea instead of the full selection.\n    this.inaccurateSelection = false;\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) te.style.width = \"1000px\";\n    else te.setAttribute(\"wrap\", \"off\");\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) te.style.border = \"1px solid black\";\n    disableBrowserMagic(te);\n    return div;\n  }\n\n  TextareaInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = this.cm;\n\n      // Wraps and hides input textarea\n      var div = this.wrapper = hiddenTextarea();\n      // The semihidden textarea that is focused when the editor is\n      // focused, and receives input.\n      var te = this.textarea = div.firstChild;\n      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n      if (ios) te.style.width = \"0px\";\n\n      on(te, \"input\", function() {\n        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n        input.poll();\n      });\n\n      on(te, \"paste\", function(e) {\n        if (handlePaste(e, cm)) return true;\n\n        cm.state.pasteIncoming = true;\n        input.fastPoll();\n      });\n\n      function prepareCopyCut(e) {\n        if (cm.somethingSelected()) {\n          lastCopied = cm.getSelections();\n          if (input.inaccurateSelection) {\n            input.prevInput = \"\";\n            input.inaccurateSelection = false;\n            te.value = lastCopied.join(\"\\n\");\n            selectInput(te);\n          }\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = ranges.text;\n          if (e.type == \"cut\") {\n            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n          } else {\n            input.prevInput = \"\";\n            te.value = ranges.text.join(\"\\n\");\n            selectInput(te);\n          }\n        }\n        if (e.type == \"cut\") cm.state.cutIncoming = true;\n      }\n      on(te, \"cut\", prepareCopyCut);\n      on(te, \"copy\", prepareCopyCut);\n\n      on(display.scroller, \"paste\", function(e) {\n        if (eventInWidget(display, e)) return;\n        cm.state.pasteIncoming = true;\n        input.focus();\n      });\n\n      // Prevent normal selection in the editor (we handle our own)\n      on(display.lineSpace, \"selectstart\", function(e) {\n        if (!eventInWidget(display, e)) e_preventDefault(e);\n      });\n\n      on(te, \"compositionstart\", function() {\n        var start = cm.getCursor(\"from\");\n        if (input.composing) input.composing.range.clear()\n        input.composing = {\n          start: start,\n          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n        };\n      });\n      on(te, \"compositionend\", function() {\n        if (input.composing) {\n          input.poll();\n          input.composing.range.clear();\n          input.composing = null;\n        }\n      });\n    },\n\n    prepareSelection: function() {\n      // Redraw the selection and/or cursor\n      var cm = this.cm, display = cm.display, doc = cm.doc;\n      var result = prepareSelection(cm);\n\n      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n      if (cm.options.moveInputWithCursor) {\n        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                            headPos.top + lineOff.top - wrapOff.top));\n        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                             headPos.left + lineOff.left - wrapOff.left));\n      }\n\n      return result;\n    },\n\n    showSelection: function(drawn) {\n      var cm = this.cm, display = cm.display;\n      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n      if (drawn.teTop != null) {\n        this.wrapper.style.top = drawn.teTop + \"px\";\n        this.wrapper.style.left = drawn.teLeft + \"px\";\n      }\n    },\n\n    // Reset the input to correspond to the selection (or to be empty,\n    // when not typing and nothing is selected)\n    reset: function(typing) {\n      if (this.contextMenuPending) return;\n      var minimal, selected, cm = this.cm, doc = cm.doc;\n      if (cm.somethingSelected()) {\n        this.prevInput = \"\";\n        var range = doc.sel.primary();\n        minimal = hasCopyEvent &&\n          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n        var content = minimal ? \"-\" : selected || cm.getSelection();\n        this.textarea.value = content;\n        if (cm.state.focused) selectInput(this.textarea);\n        if (ie && ie_version >= 9) this.hasSelection = content;\n      } else if (!typing) {\n        this.prevInput = this.textarea.value = \"\";\n        if (ie && ie_version >= 9) this.hasSelection = null;\n      }\n      this.inaccurateSelection = minimal;\n    },\n\n    getField: function() { return this.textarea; },\n\n    supportsTouch: function() { return false; },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n        try { this.textarea.focus(); }\n        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n      }\n    },\n\n    blur: function() { this.textarea.blur(); },\n\n    resetPosition: function() {\n      this.wrapper.style.top = this.wrapper.style.left = 0;\n    },\n\n    receivedFocus: function() { this.slowPoll(); },\n\n    // Poll for input changes, using the normal rate of polling. This\n    // runs as long as the editor is focused.\n    slowPoll: function() {\n      var input = this;\n      if (input.pollingFast) return;\n      input.polling.set(this.cm.options.pollInterval, function() {\n        input.poll();\n        if (input.cm.state.focused) input.slowPoll();\n      });\n    },\n\n    // When an event has just come in that is likely to add or change\n    // something in the input textarea, we poll faster, to ensure that\n    // the change appears on the screen quickly.\n    fastPoll: function() {\n      var missed = false, input = this;\n      input.pollingFast = true;\n      function p() {\n        var changed = input.poll();\n        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n        else {input.pollingFast = false; input.slowPoll();}\n      }\n      input.polling.set(20, p);\n    },\n\n    // Read input from the textarea, and update the document to match.\n    // When something is selected, it is present in the textarea, and\n    // selected (unless it is huge, in which case a placeholder is\n    // used). When nothing is selected, the cursor sits after previously\n    // seen text (can be empty), which is stored in prevInput (we must\n    // not reset the textarea when typing, because that breaks IME).\n    poll: function() {\n      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n      // Since this is called a *lot*, try to bail out as cheaply as\n      // possible when it is clear that nothing happened. hasSelection\n      // will be the case when there is a lot of text in the textarea,\n      // in which case reading its value would be expensive.\n      if (this.contextMenuPending || !cm.state.focused ||\n          (hasSelection(input) && !prevInput && !this.composing) ||\n          isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)\n        return false;\n\n      var text = input.value;\n      // If nothing changed, bail.\n      if (text == prevInput && !cm.somethingSelected()) return false;\n      // Work around nonsensical selection resetting in IE9/10, and\n      // inexplicable appearance of private area unicode characters on\n      // some key combos in Mac (#2689).\n      if (ie && ie_version >= 9 && this.hasSelection === text ||\n          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n        cm.display.input.reset();\n        return false;\n      }\n\n      if (cm.doc.sel == cm.display.selForContextMenu) {\n        var first = text.charCodeAt(0);\n        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n      }\n      // Find the part of the input that is actually new\n      var same = 0, l = Math.min(prevInput.length, text.length);\n      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\n      var self = this;\n      runInOp(cm, function() {\n        applyTextInput(cm, text.slice(same), prevInput.length - same,\n                       null, self.composing ? \"*compose\" : null);\n\n        // Don't leave long text in the textarea, since it makes further polling slow\n        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n        else self.prevInput = text;\n\n        if (self.composing) {\n          self.composing.range.clear();\n          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n                                             {className: \"CodeMirror-composing\"});\n        }\n      });\n      return true;\n    },\n\n    ensurePolled: function() {\n      if (this.pollingFast && this.poll()) this.pollingFast = false;\n    },\n\n    onKeyPress: function() {\n      if (ie && ie_version >= 9) this.hasSelection = null;\n      this.fastPoll();\n    },\n\n    onContextMenu: function(e) {\n      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n      if (!pos || presto) return; // Opera is difficult.\n\n      // Reset the current text selection only if the click is done outside of the selection\n      // and 'resetSelectionOnContextMenu' option is true.\n      var reset = cm.options.resetSelectionOnContextMenu;\n      if (reset && cm.doc.sel.contains(pos) == -1)\n        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\n      var oldCSS = te.style.cssText;\n      input.wrapper.style.position = \"absolute\";\n      te.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: \" +\n        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n      display.input.focus();\n      if (webkit) window.scrollTo(null, oldScrollY);\n      display.input.reset();\n      // Adds \"Select all\" to context menu in FF\n      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n      input.contextMenuPending = true;\n      display.selForContextMenu = cm.doc.sel;\n      clearTimeout(display.detectingSelectAll);\n\n      // Select-all will be greyed out if there's nothing to select, so\n      // this adds a zero-width space so that we can later check whether\n      // it got selected.\n      function prepareSelectAllHack() {\n        if (te.selectionStart != null) {\n          var selected = cm.somethingSelected();\n          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n          te.value = \"\\u21da\"; // Used to catch context-menu undo\n          te.value = extval;\n          input.prevInput = selected ? \"\" : \"\\u200b\";\n          te.selectionStart = 1; te.selectionEnd = extval.length;\n          // Re-set this, in case some other handler touched the\n          // selection in the meantime.\n          display.selForContextMenu = cm.doc.sel;\n        }\n      }\n      function rehide() {\n        input.contextMenuPending = false;\n        input.wrapper.style.position = \"relative\";\n        te.style.cssText = oldCSS;\n        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\n        // Try to detect the user choosing select-all\n        if (te.selectionStart != null) {\n          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n          var i = 0, poll = function() {\n            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n              operation(cm, commands.selectAll)(cm);\n            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n            else display.input.reset();\n          };\n          display.detectingSelectAll = setTimeout(poll, 200);\n        }\n      }\n\n      if (ie && ie_version >= 9) prepareSelectAllHack();\n      if (captureRightClick) {\n        e_stop(e);\n        var mouseup = function() {\n          off(window, \"mouseup\", mouseup);\n          setTimeout(rehide, 20);\n        };\n        on(window, \"mouseup\", mouseup);\n      } else {\n        setTimeout(rehide, 50);\n      }\n    },\n\n    readOnlyChanged: function(val) {\n      if (!val) this.reset();\n    },\n\n    setUneditable: nothing,\n\n    needsContentAttribute: false\n  }, TextareaInput.prototype);\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  function ContentEditableInput(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.gracePeriod = false;\n  }\n\n  ContentEditableInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = input.cm;\n      var div = input.div = display.lineDiv;\n      disableBrowserMagic(div);\n\n      on(div, \"paste\", function(e) { handlePaste(e, cm); })\n\n      on(div, \"compositionstart\", function(e) {\n        var data = e.data;\n        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n        if (!data) return;\n        var prim = cm.doc.sel.primary();\n        var line = cm.getLine(prim.head.line);\n        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n        if (found > -1 && found <= prim.head.ch)\n          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n                                                Pos(prim.head.line, found + data.length));\n      });\n      on(div, \"compositionupdate\", function(e) {\n        input.composing.data = e.data;\n      });\n      on(div, \"compositionend\", function(e) {\n        var ours = input.composing;\n        if (!ours) return;\n        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n          ours.data = e.data;\n        // Need a small delay to prevent other code (input event,\n        // selection polling) from doing damage when fired right after\n        // compositionend.\n        setTimeout(function() {\n          if (!ours.handled)\n            input.applyComposition(ours);\n          if (input.composing == ours)\n            input.composing = null;\n        }, 50);\n      });\n\n      on(div, \"touchstart\", function() {\n        input.forceCompositionEnd();\n      });\n\n      on(div, \"input\", function() {\n        if (input.composing) return;\n        if (isReadOnly(cm) || !input.pollContent())\n          runInOp(input.cm, function() {regChange(cm);});\n      });\n\n      function onCopyCut(e) {\n        if (cm.somethingSelected()) {\n          lastCopied = cm.getSelections();\n          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = ranges.text;\n          if (e.type == \"cut\") {\n            cm.operation(function() {\n              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n              cm.replaceSelection(\"\", null, \"cut\");\n            });\n          }\n        }\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        if (e.clipboardData && !ios) {\n          e.preventDefault();\n          e.clipboardData.clearData();\n          e.clipboardData.setData(\"text/plain\", lastCopied.join(\"\\n\"));\n        } else {\n          // Old-fashioned briefly-focus-a-textarea hack\n          var kludge = hiddenTextarea(), te = kludge.firstChild;\n          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n          te.value = lastCopied.join(\"\\n\");\n          var hadFocus = document.activeElement;\n          selectInput(te);\n          setTimeout(function() {\n            cm.display.lineSpace.removeChild(kludge);\n            hadFocus.focus();\n          }, 50);\n        }\n      }\n      on(div, \"copy\", onCopyCut);\n      on(div, \"cut\", onCopyCut);\n    },\n\n    prepareSelection: function() {\n      var result = prepareSelection(this.cm, false);\n      result.focus = this.cm.state.focused;\n      return result;\n    },\n\n    showSelection: function(info) {\n      if (!info || !this.cm.display.view.length) return;\n      if (info.focus) this.showPrimarySelection();\n      this.showMultipleSelections(info);\n    },\n\n    showPrimarySelection: function() {\n      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n        return;\n\n      var start = posToDOM(this.cm, prim.from());\n      var end = posToDOM(this.cm, prim.to());\n      if (!start && !end) return;\n\n      var view = this.cm.display.view;\n      var old = sel.rangeCount && sel.getRangeAt(0);\n      if (!start) {\n        start = {node: view[0].measure.map[2], offset: 0};\n      } else if (!end) { // FIXME dangerously hacky\n        var measure = view[view.length - 1].measure;\n        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n      }\n\n      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n      if (rng) {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n        if (old && sel.anchorNode == null) sel.addRange(old);\n        else if (gecko) this.startGracePeriod();\n      }\n      this.rememberSelection();\n    },\n\n    startGracePeriod: function() {\n      var input = this;\n      clearTimeout(this.gracePeriod);\n      this.gracePeriod = setTimeout(function() {\n        input.gracePeriod = false;\n        if (input.selectionChanged())\n          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n      }, 20);\n    },\n\n    showMultipleSelections: function(info) {\n      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n    },\n\n    rememberSelection: function() {\n      var sel = window.getSelection();\n      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n    },\n\n    selectionInEditor: function() {\n      var sel = window.getSelection();\n      if (!sel.rangeCount) return false;\n      var node = sel.getRangeAt(0).commonAncestorContainer;\n      return contains(this.div, node);\n    },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n    },\n    blur: function() { this.div.blur(); },\n    getField: function() { return this.div; },\n\n    supportsTouch: function() { return true; },\n\n    receivedFocus: function() {\n      var input = this;\n      if (this.selectionInEditor())\n        this.pollSelection();\n      else\n        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\n      function poll() {\n        if (input.cm.state.focused) {\n          input.pollSelection();\n          input.polling.set(input.cm.options.pollInterval, poll);\n        }\n      }\n      this.polling.set(this.cm.options.pollInterval, poll);\n    },\n\n    selectionChanged: function() {\n      var sel = window.getSelection();\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n    },\n\n    pollSelection: function() {\n      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n        var sel = window.getSelection(), cm = this.cm;\n        this.rememberSelection();\n        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n        if (anchor && head) runInOp(cm, function() {\n          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n        });\n      }\n    },\n\n    pollContent: function() {\n      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n      var from = sel.from(), to = sel.to();\n      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\n      var fromIndex;\n      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n        var fromLine = lineNo(display.view[0].line);\n        var fromNode = display.view[0].node;\n      } else {\n        var fromLine = lineNo(display.view[fromIndex].line);\n        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n      }\n      var toIndex = findViewIndex(cm, to.line);\n      if (toIndex == display.view.length - 1) {\n        var toLine = display.viewTo - 1;\n        var toNode = display.lineDiv.lastChild;\n      } else {\n        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n        var toNode = display.view[toIndex + 1].node.previousSibling;\n      }\n\n      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n      while (newText.length > 1 && oldText.length > 1) {\n        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n        else break;\n      }\n\n      var cutFront = 0, cutEnd = 0;\n      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n        ++cutFront;\n      var newBot = lst(newText), oldBot = lst(oldText);\n      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n      while (cutEnd < maxCutEnd &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n        ++cutEnd;\n\n      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n      newText[0] = newText[0].slice(cutFront);\n\n      var chFrom = Pos(fromLine, cutFront);\n      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n        return true;\n      }\n    },\n\n    ensurePolled: function() {\n      this.forceCompositionEnd();\n    },\n    reset: function() {\n      this.forceCompositionEnd();\n    },\n    forceCompositionEnd: function() {\n      if (!this.composing || this.composing.handled) return;\n      this.applyComposition(this.composing);\n      this.composing.handled = true;\n      this.div.blur();\n      this.div.focus();\n    },\n    applyComposition: function(composing) {\n      if (isReadOnly(this.cm))\n        operation(this.cm, regChange)(this.cm)\n      else if (composing.data && composing.data != composing.startData)\n        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n    },\n\n    setUneditable: function(node) {\n      node.contentEditable = \"false\"\n    },\n\n    onKeyPress: function(e) {\n      e.preventDefault();\n      if (!isReadOnly(this.cm))\n        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n    },\n\n    readOnlyChanged: function(val) {\n      this.div.contentEditable = String(val != \"nocursor\")\n    },\n\n    onContextMenu: nothing,\n    resetPosition: nothing,\n\n    needsContentAttribute: true\n  }, ContentEditableInput.prototype);\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) return null;\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result;\n  }\n\n  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        return locateNodeInLineView(lineView, node, offset);\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad);\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) offset = textNode.nodeValue.length;\n    }\n    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n            return Pos(line, ch);\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) return badPos(found, bad);\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        return badPos(Pos(found.line, found.ch - dist), bad);\n      else\n        dist += after.textContent.length;\n    }\n    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        return badPos(Pos(found.line, found.ch + dist), bad);\n      else\n        dist += after.textContent.length;\n    }\n  }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText != null) {\n          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n          text += cmText;\n          return;\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find()))\n            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n          return;\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n        for (var i = 0; i < node.childNodes.length; i++)\n          walk(node.childNodes[i]);\n        if (/^(pre|div|p)$/i.test(node.nodeName))\n          closing = true;\n      } else if (node.nodeType == 3) {\n        var val = node.nodeValue;\n        if (!val) return;\n        if (closing) {\n          text += lineSep;\n          closing = false;\n        }\n        text += val;\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) break;\n      from = from.nextSibling;\n    }\n    return text;\n  }\n\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // SELECTION / CURSOR\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  function Selection(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  }\n\n  Selection.prototype = {\n    primary: function() { return this.ranges[this.primIndex]; },\n    equals: function(other) {\n      if (other == this) return true;\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var here = this.ranges[i], there = other.ranges[i];\n        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n      }\n      return true;\n    },\n    deepCopy: function() {\n      for (var out = [], i = 0; i < this.ranges.length; i++)\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n      return new Selection(out, this.primIndex);\n    },\n    somethingSelected: function() {\n      for (var i = 0; i < this.ranges.length; i++)\n        if (!this.ranges[i].empty()) return true;\n      return false;\n    },\n    contains: function(pos, end) {\n      if (!end) end = pos;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var range = this.ranges[i];\n        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n          return i;\n      }\n      return -1;\n    }\n  };\n\n  function Range(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  }\n\n  Range.prototype = {\n    from: function() { return minPos(this.anchor, this.head); },\n    to: function() { return maxPos(this.anchor, this.head); },\n    empty: function() {\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n    }\n  };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(ranges, primIndex) {\n    var prim = ranges[primIndex];\n    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      if (cmp(prev.to(), cur.from()) >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) --primIndex;\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex);\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0);\n  }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n  function clipPosArray(doc, array) {\n    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n    return out;\n  }\n\n  // SELECTION UPDATES\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(doc, range, head, other) {\n    if (doc.cm && doc.cm.display.shift || doc.extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head);\n    } else {\n      return new Range(other || head, head);\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options) {\n    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n    var newSel = normalizeSelection(out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head));\n      }\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n    else return sel;\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      sel = filterSelectionChange(doc, sel);\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      ensureCursorVisible(doc.cm);\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) return;\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) out = sel.ranges.slice(0, i);\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(out, sel.primIndex) : sel;\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, bias, mayClear) {\n    var flipped = false, curPos = pos;\n    var dir = bias || 1;\n    doc.cantEdit = false;\n    search: for (;;) {\n      var line = getLine(doc, curPos.line);\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i], m = sp.marker;\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear) {\n              signal(m, \"beforeCursorEnter\");\n              if (m.explicitlyCleared) {\n                if (!line.markedSpans) break;\n                else {--i; continue;}\n              }\n            }\n            if (!m.atomic) continue;\n            var newPos = m.find(dir < 0 ? -1 : 1);\n            if (cmp(newPos, curPos) == 0) {\n              newPos.ch += dir;\n              if (newPos.ch < 0) {\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n                else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n                else newPos = null;\n              }\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\n                  doc.cantEdit = true;\n                  return Pos(doc.first, 0);\n                }\n                flipped = true; newPos = pos; dir = -dir;\n              }\n            }\n            curPos = newPos;\n            continue search;\n          }\n        }\n      }\n      return curPos;\n    }\n  }\n\n  // SELECTION DRAWING\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (primary === false && i == doc.sel.primIndex) continue;\n      var range = doc.sel.ranges[i];\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        drawSelectionCursor(cm, range.head, curFragment);\n      if (!collapsed)\n        drawSelectionRange(cm, range, selFragment);\n    }\n    return result;\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n                               \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, \"left\"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, \"right\");\n          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = leftSide;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = leftSide;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = rightSide;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < leftSide + 1) left = leftSide;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n    else if (cm.options.cursorBlinkRate < 0)\n      display.cursorDiv.style.visibility = \"hidden\";\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.viewTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changedLines = [];\n\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n      if (doc.frontier >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) line.styleClasses = newCls;\n        else if (oldCls) line.styleClasses = null;\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) changedLines.push(doc.frontier);\n        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changedLines.length) runInOp(cm, function() {\n      for (var i = 0; i < changedLines.length; i++)\n        regLineChange(cm, changedLines[i], \"text\");\n    });\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingH(display) {\n    if (display.cachedPaddingH) return display.cachedPaddingH;\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n    return data;\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineView.rest[i] == line)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineNo(lineView.rest[i]) > lineN)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view;\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      return cm.display.view[findViewIndex(cm, lineN)];\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      return ext;\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      view = updateExternalMeasurement(cm, line);\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    };\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) ch = -1;\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        prepared.rect = prepared.view.text.getBoundingClientRect();\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) prepared.cache[key] = found;\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom};\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      var mStart = map[i], mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) collapse = \"right\";\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          collapse = bias;\n        if (bias == \"left\" && start == 0)\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          }\n        if (bias == \"right\" && start == mEnd - mStart)\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          }\n        break;\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n          rect = node.parentNode.getBoundingClientRect();\n        } else if (ie && cm.options.lineWrapping) {\n          var rects = range(node, start, end).getClientRects();\n          if (rects.length)\n            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n          else\n            rect = nullRect;\n        } else {\n          rect = range(node, start, end).getBoundingClientRect() || nullRect;\n        }\n        if (rect.left || rect.right || start == 0) break;\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) collapse = bias = \"right\";\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n      else\n        rect = node.getBoundingClientRect();\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n      else\n        rect = nullRect;\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    for (var i = 0; i < heights.length - 1; i++)\n      if (mid < heights[i]) break;\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) result.bogus = true;\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result;\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      return rect;\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n        lineView.measure.caches[i] = {};\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      clearLineMeasurementCacheFor(cm.display.view[i]);\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0, pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find(0, true);\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineN = lineNo(lineObj = mergedPos.to.line);\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var operationGroup = null;\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: null,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    if (operationGroup) {\n      operationGroup.ops.push(cm.curOp);\n    } else {\n      cm.curOp.ownsGroup = operationGroup = {\n        ops: [cm.curOp],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        callbacks[i].call(null);\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n      }\n    } while (i < callbacks.length);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp, group = op.ownsGroup;\n    if (!group) return;\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      for (var i = 0; i < group.ops.length; i++)\n        group.ops[i].cm.curOp = null;\n      endOperations(group);\n    }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_finish(ops[i]);\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) findMaxLine(cm);\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      op.preparedSelection = display.input.prepareSelection();\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n      cm.display.maxLineChanged = false;\n    }\n\n    if (op.preparedSelection)\n      cm.display.input.showSelection(op.preparedSelection);\n    if (op.updatedDisplay)\n      setDocumentHeight(cm, op.barMeasure);\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      updateScrollbars(cm, op.barMeasure);\n\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      cm.display.input.reset(op.typing);\n    if (op.focus && op.focus == activeElt()) ensureFocus(op.cm);\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      display.wheelStartX = display.wheelStartY = null;\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n      display.scrollbars.setScrollTop(doc.scrollTop);\n      display.scroller.scrollTop = doc.scrollTop;\n    }\n    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));\n      display.scrollbars.setScrollLeft(doc.scrollLeft);\n      display.scroller.scrollLeft = doc.scrollLeft;\n      alignHorizontally(cm);\n    }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\n    if (display.wrapper.offsetHeight)\n      doc.scrollTop = cm.display.scroller.scrollTop;\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      signal(cm, \"changes\", cm, op.changeObjs);\n    if (op.update)\n      op.update.finish();\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) return f();\n    startOperation(cm);\n    try { return f(); }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) return f.apply(cm, arguments);\n      startOperation(cm);\n      try { return f.apply(cm, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) return f.apply(this, arguments);\n      startOperation(this);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(this); }\n    };\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) return f.apply(this, arguments);\n      startOperation(cm);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n\n  // VIEW TRACKING\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array;\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    if (!lendiff) lendiff = 0;\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      display.updateLineNumbers = from;\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        resetView(cm);\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut = viewCuttingPoint(cm, from, from, -1);\n      if (cut) {\n        display.view = display.view.slice(0, cut.index);\n        display.viewTo = cut.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        ext.lineN += lendiff;\n      else if (from < ext.lineN + ext.size)\n        display.externalMeasured = null;\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      display.externalMeasured = null;\n\n    if (line < display.viewFrom || line >= display.viewTo) return;\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) return;\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) arr.push(type);\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) return null;\n    n -= cm.display.viewFrom;\n    if (n < 0) return null;\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) return i;\n    }\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      return {index: index, lineN: newN};\n    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n      n += view[i].size;\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) return null;\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN};\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n      else if (display.viewFrom < from)\n        display.view = display.view.slice(findViewIndex(cm, from));\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n      else if (display.viewTo > to)\n        display.view = display.view.slice(0, findViewIndex(cm, to));\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n    }\n    return dirty;\n  }\n\n  // EVENT HANDLERS\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      }));\n    else\n      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    };\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) return false;\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1;\n    }\n    function farAway(touch, other) {\n      if (other.left == null) return true;\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20;\n    }\n    on(d.scroller, \"touchstart\", function(e) {\n      if (!isMouseLikeTouchEvent(e)) {\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function() {\n      if (d.activeTouch) d.activeTouch.moved = true;\n    });\n    on(d.scroller, \"touchend\", function(e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          range = new Range(pos, pos);\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          range = cm.findWordAt(pos);\n        else // Triple tap\n          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function(e){onDragStart(cm, e);},\n      drop: operation(cm, onDrop),\n      leave: function() {clearDragCursor(cm);}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", bind(onFocus, cm));\n    on(inp, \"blur\", bind(onBlur, cm));\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != CodeMirror.Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n      return;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  // MOUSE EVENTS\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        return true;\n    }\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null; }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords;\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (display.activeTouch && display.input.supportsTouch() || signalDOMEvent(cm, e)) return;\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n    window.focus();\n\n    switch (e_button(e)) {\n    case 1:\n      // #3261: make sure, that we're not starting a second selection\n      if (cm.state.selectingText)\n        cm.state.selectingText(e);\n      else if (start)\n        leftButtonDown(cm, e, start);\n      else if (e_target(e) == display.scroller)\n        e_preventDefault(e);\n      break;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(function() {display.input.focus();}, 20);\n      e_preventDefault(e);\n      break;\n    case 3:\n      if (captureRightClick) onContextMenu(cm, e);\n      else delayBlurEvent(cm);\n      break;\n    }\n  }\n\n  var lastClick, lastDoubleClick;\n  function leftButtonDown(cm, e, start) {\n    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n    else cm.curOp.focus = activeElt();\n\n    var now = +new Date, type;\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n      type = \"triple\";\n    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n      type = \"double\";\n      lastDoubleClick = {time: now, pos: start};\n    } else {\n      type = \"single\";\n      lastClick = {time: now, pos: start};\n    }\n\n    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&\n        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n      leftButtonStartDrag(cm, e, start, modifier);\n    else\n      leftButtonSelect(cm, e, start, type, modifier);\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, e, start, modifier) {\n    var display = cm.display, startTime = +new Date;\n    var dragEnd = operation(cm, function(e2) {\n      if (webkit) display.scroller.draggable = false;\n      cm.state.draggingText = false;\n      off(document, \"mouseup\", dragEnd);\n      off(display.scroller, \"drop\", dragEnd);\n      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n        e_preventDefault(e2);\n        if (!modifier && +new Date - 200 < startTime)\n          extendSelection(cm.doc, start);\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if (webkit || ie && ie_version == 9)\n          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n        else\n          display.input.focus();\n      }\n    });\n    // Let the drag handler handle this.\n    if (webkit) display.scroller.draggable = true;\n    cm.state.draggingText = dragEnd;\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) display.scroller.dragDrop();\n    on(document, \"mouseup\", dragEnd);\n    on(display.scroller, \"drop\", dragEnd);\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, e, start, type, addNew) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(e);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (addNew && !e.shiftKey) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        ourRange = ranges[ourIndex];\n      else\n        ourRange = new Range(start, start);\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (e.altKey) {\n      type = \"rect\";\n      if (!addNew) ourRange = new Range(start, start);\n      start = posFromMouse(cm, e, true, true);\n      ourIndex = -1;\n    } else if (type == \"double\") {\n      var word = cm.findWordAt(start);\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n      else\n        ourRange = word;\n    } else if (type == \"triple\") {\n      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n      else\n        ourRange = line;\n    } else {\n      ourRange = extendRange(doc, ourRange, start);\n    }\n\n    if (!addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) return;\n      lastPos = pos;\n\n      if (type == \"rect\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n          else if (text.length > leftPos)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n        }\n        if (!ranges.length) ranges.push(new Range(start, start));\n        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var anchor = oldRange.anchor, head = pos;\n        if (type != \"single\") {\n          if (type == \"double\")\n            var range = cm.findWordAt(pos);\n          else\n            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n          if (cmp(range.anchor, anchor) > 0) {\n            head = range.head;\n            anchor = minPos(oldRange.from(), range.anchor);\n          } else {\n            head = range.anchor;\n            anchor = maxPos(oldRange.to(), range.head);\n          }\n        }\n        var ranges = startSel.ranges.slice(0);\n        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, type == \"rect\");\n      if (!cur) return;\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      e_preventDefault(e);\n      display.input.focus();\n      off(document, \"mousemove\", move);\n      off(document, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function(e) {\n      if (!e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(document, \"mousemove\", move);\n    on(document, \"mouseup\", up);\n  }\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent, signalfn) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signalfn(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true, signalLater);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n          return;\n\n        var reader = new FileReader;\n        reader.onload = operation(cm, function() {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n          text[i] = content;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function() {cm.display.input.focus();}, 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n        if (text) {\n          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))\n            var selected = cm.listSelections();\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) for (var i = 0; i < selected.length; ++i)\n            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n          cm.replaceSelection(text, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) img.parentNode.removeChild(img);\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) return;\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // SCROLL EVENTS\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplaySimple(cm, {top: val});\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (gecko) updateDisplaySimple(cm);\n    startWorker(cm, 100);\n  }\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  var wheelEventDelta = function(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n    return {x: dx, y: dy};\n  };\n  CodeMirror.wheelEventPixels = function(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta;\n  };\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer;\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // KEY EVENTS\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n      if (dropShift) cm.display.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) return result;\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm);\n  }\n\n  var stopSeq = new Delayed;\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) return \"handled\";\n      stopSeq.set(50, function() {\n        if (cm.state.keySeq == seq) {\n          cm.state.keySeq = null;\n          cm.display.input.reset();\n        }\n      });\n      name = seq + \" \" + name;\n    }\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      cm.state.keySeq = name;\n    if (result == \"handled\")\n      signalLater(cm, \"keyHandled\", cm, name, e);\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    if (seq && !result && /\\'$/.test(name)) {\n      e_preventDefault(e);\n      return true;\n    }\n    return !!result;\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) return false;\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n          || dispatchKey(cm, name, e, function(b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 return doHandleBinding(cm, b);\n             });\n    } else {\n      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n                       function(b) { return doHandleBinding(cm, b, true); });\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) return;\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection(\"\", null, \"cut\");\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      showCrossHair(cm);\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) this.doc.sel.shift = false;\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    cm.display.input.onKeyPress(e);\n  }\n\n  // FOCUS/BLUR EVENTS\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function() {\n      if (cm.state.delayingBlurEvent) {\n        cm.state.delayingBlurEvent = false;\n        onBlur(cm);\n      }\n    }, 100);\n  }\n\n  function onFocus(cm) {\n    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\n    if (cm.options.readOnly == \"nocursor\") return;\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.delayingBlurEvent) return;\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n    cm.display.input.onContextMenu(e);\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n    return gutterEvent(cm, e, \"gutterContextMenu\", false, signal);\n  }\n\n  // UPDATING\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) return pos;\n    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n    return Pos(line, ch);\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(out, doc.sel.primIndex);\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n    else\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex);\n  }\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    for (var i = 0; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        break;\n    }\n    if (i == source.length) return;\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return;\n        }\n        selAfter = event;\n      }\n      else break;\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return;\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) return;\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n                       Pos(range.head.line + distance, range.head.ch));\n    }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        regLineChange(doc.cm, l, \"gutter\");\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n    else updateDoc(doc, change, spans);\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      signalCursorActivity(cm);\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      regChange(cm);\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      regLineChange(cm, from.line, \"text\");\n    else\n      regChange(cm, from.line, to.line + 1, lendiff);\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == \"string\") code = doc.splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, coords) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n                           coords.left + \"px; width: 2px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) break;\n    }\n    return coords;\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (y2 - y1 > screen) y2 = y1 + screen;\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = x2 - x1 > screenw;\n    if (tooWide) x2 = x1 + screenw;\n    if (x1 < 10)\n      result.scrollLeft = 0;\n    else if (x1 < screenleft)\n      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n    else if (x2 > screenw + screenleft - 3)\n      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n    return result;\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollPos(cm, left, top) {\n    if (left != null || top != null) resolveScrollToPos(cm);\n    if (left != null)\n      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n    if (top != null)\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor(), from = cur, to = cur;\n    if (!cm.options.lineWrapping) {\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n      to = Pos(cur.line, cur.ch + 1);\n    }\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n                                    Math.min(from.top, to.top) - range.margin,\n                                    Math.max(from.right, to.right),\n                                    Math.max(from.bottom, to.bottom) + range.margin);\n      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n    }\n  }\n\n  // API UTILITIES\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) how = \"add\";\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) how = \"prev\";\n      else state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) line.stateAfter = null;\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true;\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i = 0; i < doc.sel.ranges.length; i++) {\n        var range = doc.sel.ranges[i];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i, new Range(pos, pos));\n          break;\n        }\n      }\n    }\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n    return line;\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break;\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function() {\n      for (var i = kill.length - 1; i >= 0; i--)\n        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n      ensureCursorVisible(cm);\n    });\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    var possible = true;\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return (possible = false);\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == \"char\") moveOnce();\n    else if (unit == \"column\") moveOnce(true);\n    else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) type = \"s\";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n    if (!possible) result.hitSide = true;\n    return result;\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  // EDITOR METHODS\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || maps[i].name == map) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n        else dir = dir ? \"add\" : \"subtract\";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: methodOp(function(how) {\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (!range.empty()) {\n          var from = range.from(), to = range.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            indentLine(this, j, how);\n          var newRanges = this.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n        } else if (range.head.line > end) {\n          indentLine(this, range.head.line, how, true);\n          end = range.head.line;\n          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise);\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true);\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) type = styles[2];\n      else for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else { type = styles[mid * 2 + 2]; break; }\n      }\n      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return found;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range = this.doc.sel.primary();\n      if (start == null) pos = range.head;\n      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n      else pos = start ? range.from() : range.to();\n      return cursorCoords(this, pos, mode || \"page\");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) line = this.doc.first;\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: methodOp(function(line, gutterID, value) {\n      return changeLine(this.doc, line, \"gutter\", function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: methodOp(function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regLineChange(cm, i, \"gutter\");\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    lineInfo: function(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd].call(null, this);\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var cm = this;\n      cm.extendSelectionsBy(function(range) {\n        if (cm.display.shift || cm.doc.extend || range.empty())\n          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n        else\n          return dir < 0 ? range.from() : range.to();\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        doc.replaceSelection(\"\", null, \"+delete\");\n      else\n        deleteNearSelection(this, function(range) {\n          var other = findPosH(doc, range.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n        });\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, \"div\");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var cm = this, doc = this.doc, goals = [];\n      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function(range) {\n        if (collapse)\n          return dir < 0 ? range.from() : range.to();\n        var headPos = cursorCoords(cm, range.head, \"div\");\n        if (range.goalColumn != null) headPos.left = range.goalColumn;\n        goals.push(headPos.left);\n        var pos = findPosV(cm, headPos, dir, unit);\n        if (unit == \"page\" && range == doc.sel.primary())\n          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n        return pos;\n      }, sel_move);\n      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n        doc.sel.ranges[i].goalColumn = goals[i];\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function(ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n        while (start > 0 && check(line.charAt(start - 1))) --start;\n        while (end < line.length && check(line.charAt(end))) ++end;\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n      else\n        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n\n    scrollTo: methodOp(function(x, y) {\n      if (x != null || y != null) resolveScrollToPos(this);\n      if (x != null) this.curOp.scrollLeft = x;\n      if (y != null) this.curOp.scrollTop = y;\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n    },\n\n    scrollIntoView: methodOp(function(range, margin) {\n      if (range == null) {\n        range = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) margin = this.options.cursorScrollMargin;\n      } else if (typeof range == \"number\") {\n        range = {from: Pos(range, 0), to: null};\n      } else if (range.from == null) {\n        range = {from: range, to: null};\n      }\n      if (!range.to) range.to = range.from;\n      range.margin = margin || 0;\n\n      if (range.from.line != null) {\n        resolveScrollToPos(this);\n        this.curOp.scrollToPos = range;\n      } else {\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n                                      Math.min(range.from.top, range.to.top) - range.margin,\n                                      Math.max(range.from.right, range.to.right),\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var cm = this;\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n      if (width != null) cm.display.wrapper.style.width = interpret(width);\n      if (height != null) cm.display.wrapper.style.height = interpret(height);\n      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n      var lineNo = cm.display.viewFrom;\n      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n        ++lineNo;\n      });\n      cm.curOp.forceUpdate = true;\n      signal(cm, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        estimateLineHeights(this);\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input.getField();},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n  // Functions to run when options are changed.\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  // Passed to option handlers when there is no old value.\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option(\"mode\", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function(cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) return;\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function(line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) break;\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n  });\n  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != CodeMirror.Init) cm.refresh();\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n  }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function(cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != CodeMirror.Init && getKeyMap(old);\n    if (prev && prev.detach) prev.detach(cm, next);\n    if (next.attach) next.attach(cm, prev || null);\n  });\n  option(\"extraKeys\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n  option(\"scrollbarStyle\", \"native\", function(cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n\n  option(\"readOnly\", false, function(cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n    }\n    cm.display.input.readOnlyChanged(val)\n  });\n  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function(cm, val) {\n    if (!val) cm.display.input.resetPosition();\n  });\n\n  option(\"tabindex\", null, function(cm, val) {\n    cm.display.input.getField().tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2)\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") found = {name: found};\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode(\"application/xml\");\n    }\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because nested\n  // modes need to do this for their inner modes.\n\n  var copyState = CodeMirror.copyState = function(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  };\n\n  var startState = CodeMirror.startState = function(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  };\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n    singleSelection: function(cm) {\n      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n    },\n    killLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        if (range.empty()) {\n          var len = getLine(cm.doc, range.head.line).text.length;\n          if (range.head.ch == len && range.head.line < cm.lastLine())\n            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n          else\n            return {from: range.head, to: Pos(range.head.line, len)};\n        } else {\n          return {from: range.from(), to: range.to()};\n        }\n      });\n    },\n    deleteLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0),\n                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n      });\n    },\n    delLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0), to: range.from()};\n      });\n    },\n    delWrappedLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n        return {from: leftPos, to: range.from()};\n      });\n    },\n    delWrappedLineRight: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n        return {from: range.from(), to: rightPos };\n      });\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    undoSelection: function(cm) {cm.undoSelection();},\n    redoSelection: function(cm) {cm.redoSelection();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n                            {origin: \"+move\", bias: 1});\n    },\n    goLineStartSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        return lineStartSmart(cm, range.head);\n      }, {origin: \"+move\", bias: 1});\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n                            {origin: \"+move\", bias: -1});\n    },\n    goLineRight: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeft: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: 0, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeftSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n        return pos;\n      }, sel_move);\n    },\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n    insertSoftTab: function(cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(new Array(tabSize - col % tabSize + 1).join(\" \"));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.execCommand(\"insertTab\");\n    },\n    transposeChars: function(cm) {\n      runInOp(cm, function() {\n        var ranges = cm.listSelections(), newSel = [];\n        for (var i = 0; i < ranges.length; i++) {\n          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n          if (line) {\n            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n            if (cur.ch > 0) {\n              cur = new Pos(cur.line, cur.ch + 1);\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n            } else if (cur.line > cm.doc.first) {\n              var prev = getLine(cm.doc, cur.line - 1).text;\n              if (prev)\n                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                                prev.charAt(prev.length - 1),\n                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n            }\n          }\n          newSel.push(new Range(cur, cur));\n        }\n        cm.setSelections(newSel);\n      });\n    },\n    newlineAndIndent: function(cm) {\n      runInOp(cm, function() {\n        var len = cm.listSelections().length;\n        for (var i = 0; i < len; i++) {\n          var range = cm.listSelections()[i];\n          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n          cm.indentLine(range.from().line + 1, null, true);\n        }\n        ensureCursorVisible(cm);\n      });\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    fallthrough: \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n      else if (/^a(lt)?$/i.test(mod)) alt = true;\n      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n      else if (/^s(hift)$/i.test(mod)) shift = true;\n      else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) name = \"Alt-\" + name;\n    if (ctrl) name = \"Ctrl-\" + name;\n    if (cmd) name = \"Cmd-\" + name;\n    if (shift) name = \"Shift-\" + name;\n    return name;\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  CodeMirror.normalizeKeyMap = function(keymap) {\n    var copy = {};\n    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n      if (value == \"...\") { delete keymap[keyname]; continue; }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val, name;\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) copy[name] = val;\n        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n      }\n      delete keymap[keyname];\n    }\n    for (var prop in copy) keymap[prop] = copy[prop];\n    return keymap;\n  };\n\n  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        return lookupKey(key, map.fallthrough, handle, context);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) return result;\n      }\n    }\n  };\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  };\n\n  // Look up the name of a key as indicated by an event object.\n  var keyName = CodeMirror.keyName = function(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n    var base = keyNames[event.keyCode], name = base;\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n    return name;\n  };\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val;\n  }\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      options.tabindex = textarea.tabIndex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function(cm) {\n      cm.save = save;\n      cm.getTextArea = function() { return textarea; };\n      cm.toTextArea = function() {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (typeof textarea.form.submit == \"function\")\n            textarea.form.submit = realSubmit;\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  var nextMarkerId = 0;\n\n  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n  eventMixin(TextMarker);\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) signalLater(this, \"clear\", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n      else if (cm) {\n        if (span.to != null) max = lineNo(line);\n        if (span.from != null) min = lineNo(line);\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm.doc);\n    }\n    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n    if (withOp) endOperation(cm);\n    if (this.parent) this.parent.clear();\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function(side, lineObj) {\n    if (side == null && this.type == \"bookmark\") side = 1;\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) return from;\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) return to;\n      }\n    }\n    return from && {from: from, to: to};\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) return;\n    runInOp(cm, function() {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          updateLineHeight(line, line.height + dHeight);\n      }\n    });\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) copyObj(options, marker, false);\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        updateMaxLine = true;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n      if (marker.atomic) reCheckSelection(cm.doc);\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      markers[i].parent = this;\n  };\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, \"clear\");\n  };\n  SharedTextMarker.prototype.find = function(side, lineObj) {\n    return this.primary.find(side, lineObj);\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.widgetNode = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n                         function(m) { return m.parent; });\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], linked = [marker.primary.doc];;\n      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    }\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    }\n    return nw;\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    }\n    return nw;\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) return null;\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          newParts.push({from: p.from, to: m.from});\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\n          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\n        return true;\n    }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = merged.find(-1, true).line;\n    return line;\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      (lines || (lines = [])).push(line);\n    }\n    return lines;\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) return lineN;\n    return lineNo(vis);\n  }\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) return lineN;\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) return lineN;\n    while (merged = collapsedSpanAtEnd(line))\n      line = merged.find(1, true).line;\n    return lineNo(line) + 1;\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.widgetNode) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  // LINE WIDGETS\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.doc = doc;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      addToScrollPos(cm, null, diff);\n  }\n\n  LineWidget.prototype.clear = function() {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) line.widgets = null;\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) runInOp(cm, function() {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n  };\n  LineWidget.prototype.changed = function() {\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(line, line.height + diff);\n    if (cm) runInOp(cm, function() {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n    });\n  };\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    var cm = widget.doc.cm;\n    if (!cm) return 0;\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n      if (widget.noHScroll)\n        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.offsetHeight;\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(doc, handle, \"widget\", function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n        cm.curOp.forceUpdate = true;\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        output[prop] = lineClass[2];\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        output[prop] += \" \" + lineClass[2];\n    }\n    return type;\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) return mode.blankLine(state);\n    if (!mode.innerMode) return;\n    var inner = CodeMirror.innerMode(mode, state);\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) return style;\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n  }\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    function getObj(copy) {\n      return {start: stream.start, end: stream.pos,\n              string: stream.current(),\n              type: style || null,\n              state: copy ? copyState(doc.mode, state) : state};\n    }\n\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n    if (asArray) tokens = [];\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, state);\n      if (asArray) tokens.push(getObj(true));\n    }\n    return asArray ? tokens : getObj();\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 50000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, lineClasses, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"cm-overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n          }\n        }\n      }, lineClasses);\n    }\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var state = getStateBefore(cm, lineNo(line));\n      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n      line.stateAfter = state;\n      line.styles = result.styles;\n      if (result.classes) line.styleClasses = result.classes;\n      else if (line.styleClasses) line.styleClasses = null;\n      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n    }\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") callBlankLine(mode, state);\n    while (!stream.eol()) {\n      readToken(mode, stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) return null;\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        if (line.styleClasses.textClass)\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit && /\\bcm-tab\\b/.test(builder.content.lastChild.className))\n      builder.content.className = \"cm-tab-wrap-hack\";\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token;\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n    if (!text) return;\n    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) mustWrap = true;\n      builder.pos += text.length;\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt.setAttribute(\"role\", \"presentation\");\n          txt.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt);\n        builder.pos++;\n      }\n    }\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (title) token.title = title;\n      return builder.content.appendChild(token);\n    }\n    builder.content.appendChild(content);\n  }\n\n  function splitSpaces(old) {\n    var out = \" \";\n    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n    out += \" \";\n    return out;\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function(builder, text, style, startStyle, endStyle, title, css) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        for (var i = 0; i < order.length; i++) {\n          var part = order[i];\n          if (part.to > start && part.from <= start) break;\n        }\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        widget = builder.content.appendChild(document.createElement(\"span\"));\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [];\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.css) css = m.css;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return;\n          if (collapsed.to == pos) collapsed = false;\n        }\n        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      for (var i = start, result = []; i < end; ++i)\n        result.push(new Line(text[i], spansFor(i), estimateHeight));\n      return result;\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added = linesFor(1, text.length - 1);\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added = linesFor(1, text.length - 1);\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, height = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n    },\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n\n    if (typeof text == \"string\") text = this.splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      setSelection(this, simpleSelection(top));\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") line = getLine(this, line);\n      return visualLine(line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") pos = range.head;\n      else if (start == \"anchor\") pos = range.anchor;\n      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n      else pos = range.from();\n      return pos;\n    },\n    listSelections: function() { return this.sel.ranges; },\n    somethingSelected: function() {return this.sel.somethingSelected();},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads, options));\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      extendSelections(this, map(this.sel.ranges, f), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) return;\n      for (var i = 0, out = []; i < ranges.length; i++)\n        out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head));\n      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n      setSelection(this, normalizeSelection(out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) return lines;\n      else return lines.join(lineSep || this.lineSeparator());\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n        parts[i] = sel;\n      }\n      return parts;\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        dup[i] = code;\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i = changes.length - 1; i >= 0; i--)\n        makeChange(this, changes[i]);\n      if (newSel) setSelectionReplaceHistory(this, newSel);\n      else if (this.cm) ensureCursorVisible(this.cm);\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend;},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n      return {undo: done, redo: undone};\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;\n        else if (classTest(cls).test(line[prop])) return false;\n        else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function(line) {\n        var spans = line.markedSpans;\n        if (spans) for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(lineNo == from.line && from.ch > span.to ||\n                span.from == null && lineNo != from.line||\n                lineNo == to.line && span.from > to.ch) &&\n              (!filter || filter(span.marker)))\n            found.push(span.marker.parent || span.marker);\n        }\n        ++lineNo;\n      });\n      return found;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;},\n\n    splitLines: function(str) {\n      if (this.lineSep) return str.split(this.lineSep);\n      return splitLinesAuto(str);\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error(\"This document is already in use.\");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) findMaxLine(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n    for (var chunk = doc; !chunk.lines;) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0; i < chunk.children.length; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) array.pop();\n      else break;\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done);\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done);\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done);\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, ore are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        pushSelectionToHistory(doc.sel, hist.done);\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) hist.done.shift();\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) signal(doc, \"historyAdded\");\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      hist.done[hist.done.length - 1] = sel;\n    else\n      pushSelectionToHistory(sel, hist.done);\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      clearSelectionEvents(hist.undone);\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      dest.push(sel);\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue;\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue;\n      }\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT UTILITIES\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  };\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  };\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var on = CodeMirror.on = function(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent(\"on\" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  };\n\n  var noHandlers = []\n  function getHandlers(emitter, type, copy) {\n    var arr = emitter._handlers && emitter._handlers[type]\n    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n    else return arr || noHandlers\n  }\n\n  var off = CodeMirror.off = function(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent(\"on\" + type, f);\n    else {\n      var handlers = getHandlers(emitter, type, false)\n      for (var i = 0; i < handlers.length; ++i)\n        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n    }\n  };\n\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type, true)\n    if (!handlers.length) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n  };\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type, false)\n    if (!arr.length) return;\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      list.push(bnd(arr[i]));\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) return;\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n      set.push(arr[i]);\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype.set = function(ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        return n + (end - i);\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  };\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) nextTab = string.length;\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        return pos + Math.min(skipped, goal - col);\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) return pos;\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n  else if (ie) // Suppress mysterious IE10 errors\n    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      if (array[i] == elt) return i;\n    return -1;\n  }\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n    return out;\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) copyObj(props, inst);\n    return inst;\n  };\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) target = {};\n    for (var prop in obj)\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        target[prop] = obj[prop];\n    return target;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  };\n  function isWordChar(ch, helper) {\n    if (!helper) return isWordCharBasic(ch);\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n    return helper.test(ch);\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  var range;\n  if (document.createRange) range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r;\n  };\n  else range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r; }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r;\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  var contains = CodeMirror.contains = function(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      child = child.parentNode;\n    if (parent.contains)\n      return parent.contains(child);\n    do {\n      if (child.nodeType == 11) child = child.host;\n      if (child == parent) return true;\n    } while (child = child.parentNode);\n  };\n\n  function activeElt() {\n    var activeElement = document.activeElement;\n    while (activeElement && activeElement.root && activeElement.root.activeElement)\n      activeElement = activeElement.root.activeElement;\n    return activeElement;\n  }\n  // Older versions of IE throws unspecified error when touching\n  // document.activeElement in some cases (during loading, in iframe)\n  if (ie && ie_version < 11) activeElt = function() {\n    try { return document.activeElement; }\n    catch(e) { return document.body; }\n  };\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n  var rmClass = CodeMirror.rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n  var addClass = CodeMirror.addClass = function(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n  };\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n    return b;\n  }\n\n  // WINDOW-WIDE EVENTS\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.body.getElementsByClassName) return;\n    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) f(cm);\n    }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) return;\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100);\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function() {\n      forEachCodeMirror(onBlur);\n    });\n  }\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node;\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) return badBidiRects;\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    return badBidiRects = (r1.right - r0.right < 3);\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\";\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) return badZoomedRects;\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n  }\n\n  // KEY NAMES\n\n  var keyNames = CodeMirror.keyNames = {\n    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, \"ltr\");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line = getLine(cm.doc, lineN);\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      lineN = null;\n    }\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS);\n    }\n    return start;\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is needed in order to move 'visually' through bi-directional\n  // text -- i.e., pressing left should make the cursor go left, even\n  // when in RTL text. The tricky part is the 'jumps', where RTL and\n  // LTR text touch each other. This often requires the cursor offset\n  // to move more than one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n    function charType(code) {\n      if (code <= 0xf7) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n      else if (code == 0x200c) return \"b\";\n      else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = \"L\";\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n        else if (type == \",\" && prev == types[i+1] &&\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";\n        else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == \"L\";\n          var after = (end < len ? types[end] : outerType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push(new BidiSpan(0, start, i));\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n      if (order[0].level == 2)\n        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n      if (order[0].level != lst(order).level)\n        order.push(new BidiSpan(order[0].level, len, len));\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = \"5.8.0\";\n\n  return CodeMirror;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/lib/codemirror.js\n ** module id = 14\n ** module chunks = 0\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../javascript/javascript\"), require(\"../css/css\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../javascript/javascript\", \"../css/css\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaultTags = {\n    script: [\n      [\"lang\", /(javascript|babel)/i, \"javascript\"],\n      [\"type\", /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^$/i, \"javascript\"],\n      [\"type\", /./, \"text/plain\"],\n      [null, null, \"javascript\"]\n    ],\n    style:  [\n      [\"lang\", /^css$/i, \"css\"],\n      [\"type\", /^(text\\/)?(x-)?(stylesheet|css)$/i, \"css\"],\n      [\"type\", /./, \"text/plain\"],\n      [null, null, \"css\"]\n    ]\n  };\n\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current(), close = cur.search(pat);\n    if (close > -1) {\n      stream.backUp(cur.length - close);\n    } else if (cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n    return style;\n  }\n\n  var attrRegexpCache = {};\n  function getAttrRegexp(attr) {\n    var regexp = attrRegexpCache[attr];\n    if (regexp) return regexp;\n    return attrRegexpCache[attr] = new RegExp(\"\\\\s+\" + attr + \"\\\\s*=\\\\s*('|\\\")?([^'\\\"]+)('|\\\")?\\\\s*\");\n  }\n\n  function getAttrValue(stream, attr) {\n    var pos = stream.pos, match;\n    while (pos >= 0 && stream.string.charAt(pos) !== \"<\") pos--;\n    if (pos < 0) return pos;\n    if (match = stream.string.slice(pos, stream.pos).match(getAttrRegexp(attr)))\n      return match[2];\n    return \"\";\n  }\n\n  function getTagRegexp(tagName, anchored) {\n    return new RegExp((anchored ? \"^\" : \"\") + \"<\\/\\s*\" + tagName + \"\\s*>\", \"i\");\n  }\n\n  function addTags(from, to) {\n    for (var tag in from) {\n      var dest = to[tag] || (to[tag] = []);\n      var source = from[tag];\n      for (var i = source.length - 1; i >= 0; i--)\n        dest.unshift(source[i])\n    }\n  }\n\n  function findMatchingMode(tagInfo, stream) {\n    for (var i = 0; i < tagInfo.length; i++) {\n      var spec = tagInfo[i];\n      if (!spec[0] || spec[1].test(getAttrValue(stream, spec[0]))) return spec[2];\n    }\n  }\n\n  CodeMirror.defineMode(\"htmlmixed\", function (config, parserConfig) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: \"xml\",\n      htmlMode: true,\n      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,\n      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag\n    });\n\n    var tags = {};\n    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;\n    addTags(defaultTags, tags);\n    if (configTags) addTags(configTags, tags);\n    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)\n      tags.script.unshift([\"type\", configScript[i].matches, configScript[i].mode])\n\n    function html(stream, state) {\n      var tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase();\n      var tagInfo = tagName && tags.hasOwnProperty(tagName) && tags[tagName];\n\n      var style = htmlMode.token(stream, state.htmlState), modeSpec;\n\n      if (tagInfo && /\\btag\\b/.test(style) && stream.current() === \">\" &&\n          (modeSpec = findMatchingMode(tagInfo, stream))) {\n        var mode = CodeMirror.getMode(config, modeSpec);\n        var endTagA = getTagRegexp(tagName, true), endTag = getTagRegexp(tagName, false);\n        state.token = function (stream, state) {\n          if (stream.match(endTagA, false)) {\n            state.token = html;\n            state.localState = state.localMode = null;\n            return null;\n          }\n          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));\n        };\n        state.localMode = mode;\n        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, \"\"));\n      }\n      return style;\n    };\n\n    return {\n      startState: function () {\n        var state = htmlMode.startState();\n        return {token: html, localMode: null, localState: null, htmlState: state};\n      },\n\n      copyState: function (state) {\n        var local;\n        if (state.localState) {\n          local = CodeMirror.copyState(state.localMode, state.localState);\n        }\n        return {token: state.token, localMode: state.localMode, localState: local,\n                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n      },\n\n      token: function (stream, state) {\n        return state.token(stream, state);\n      },\n\n      indent: function (state, textAfter) {\n        if (!state.localMode || /^\\s*<\\//.test(textAfter))\n          return htmlMode.indent(state.htmlState, textAfter);\n        else if (state.localMode.indent)\n          return state.localMode.indent(state.localState, textAfter);\n        else\n          return CodeMirror.Pass;\n      },\n\n      innerMode: function (state) {\n        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n      }\n    };\n  }, \"xml\", \"javascript\", \"css\");\n\n  CodeMirror.defineMIME(\"text/html\", \"htmlmixed\");\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/htmlmixed/htmlmixed.js\n ** module id = 15\n ** module chunks = 0\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"xml\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;\n  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag;\n  if (multilineTagIndentPastTag == null) multilineTagIndentPastTag = true;\n\n  var Kludges = parserConfig.htmlMode ? {\n    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                      'track': true, 'wbr': true, 'menuitem': true},\n    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                       'th': true, 'tr': true},\n    contextGrabbers: {\n      'dd': {'dd': true, 'dt': true},\n      'dt': {'dd': true, 'dt': true},\n      'li': {'li': true},\n      'option': {'option': true, 'optgroup': true},\n      'optgroup': {'optgroup': true},\n      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n      'rp': {'rp': true, 'rt': true},\n      'rt': {'rp': true, 'rt': true},\n      'tbody': {'tbody': true, 'tfoot': true},\n      'td': {'td': true, 'th': true},\n      'tfoot': {'tbody': true},\n      'th': {'td': true, 'th': true},\n      'thead': {'tbody': true, 'tfoot': true},\n      'tr': {'tr': true}\n    },\n    doNotIndent: {\"pre\": true},\n    allowUnquoted: true,\n    allowMissing: true,\n    caseFold: true\n  } : {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false,\n    caseFold: false\n  };\n  var alignCDATA = parserConfig.alignCDATA;\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (Kludges.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if (state.context && state.context.tagName == tagName) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          Kludges.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!Kludges.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && Kludges.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: inText,\n              state: baseState,\n              indented: 0,\n              tagName: null, tagStart: null,\n              context: null};\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (multilineTagIndentPastTag)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * multilineTagIndentFactor;\n      }\n      if (alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (Kludges.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = Kludges.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: parserConfig.htmlMode ? \"html\" : \"xml\",\n    helperType: parserConfig.htmlMode ? \"html\" : \"xml\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/xml/xml.js\n ** module id = 16\n ** module chunks = 0\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"css\", function(config, parserConfig) {\n  var provided = parserConfig;\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode(\"text/css\");\n  parserConfig.inline = provided.inline;\n\n  var indentUnit = config.indentUnit,\n      tokenHooks = parserConfig.tokenHooks,\n      documentTypes = parserConfig.documentTypes || {},\n      mediaTypes = parserConfig.mediaTypes || {},\n      mediaFeatures = parserConfig.mediaFeatures || {},\n      mediaValueKeywords = parserConfig.mediaValueKeywords || {},\n      propertyKeywords = parserConfig.propertyKeywords || {},\n      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},\n      fontProperties = parserConfig.fontProperties || {},\n      counterDescriptors = parserConfig.counterDescriptors || {},\n      colorKeywords = parserConfig.colorKeywords || {},\n      valueKeywords = parserConfig.valueKeywords || {},\n      allowNested = parserConfig.allowNested,\n      supportsAtComponent = parserConfig.supportsAtComponent === true;\n\n  var type, override;\n  function ret(style, tp) { type = tp; return style; }\n\n  // Tokenizers\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (tokenHooks[ch]) {\n      var result = tokenHooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == \"@\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"def\", stream.current());\n    } else if (ch == \"=\" || (ch == \"~\" || ch == \"|\") && stream.eat(\"=\")) {\n      return ret(null, \"compare\");\n    } else if (ch == \"\\\"\" || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \"#\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"atom\", \"hash\");\n    } else if (ch == \"!\") {\n      stream.match(/^\\s*\\w*/);\n      return ret(\"keyword\", \"important\");\n    } else if (/\\d/.test(ch) || ch == \".\" && stream.eat(/\\d/)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret(\"number\", \"unit\");\n    } else if (ch === \"-\") {\n      if (/[\\d.]/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret(\"number\", \"unit\");\n      } else if (stream.match(/^-[\\w\\\\\\-]+/)) {\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ret(\"variable-2\", \"variable-definition\");\n        return ret(\"variable-2\", \"variable\");\n      } else if (stream.match(/^\\w+-/)) {\n        return ret(\"meta\", \"meta\");\n      }\n    } else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, \"select-op\");\n    } else if (ch == \".\" && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n      return ret(\"qualifier\", \"qualifier\");\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    } else if ((ch == \"u\" && stream.match(/rl(-prefix)?\\(/)) ||\n               (ch == \"d\" && stream.match(\"omain(\")) ||\n               (ch == \"r\" && stream.match(\"egexp(\"))) {\n      stream.backUp(1);\n      state.tokenize = tokenParenthesized;\n      return ret(\"property\", \"word\");\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"property\", \"word\");\n    } else {\n      return ret(null, null);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          if (quote == \")\") stream.backUp(1);\n          break;\n        }\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      if (ch == quote || !escaped && quote != \")\") state.tokenize = null;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenParenthesized(stream, state) {\n    stream.next(); // Must be '('\n    if (!stream.match(/\\s*[\\\"\\')]/, false))\n      state.tokenize = tokenString(\")\");\n    else\n      state.tokenize = null;\n    return ret(null, \"(\");\n  }\n\n  // Context management\n\n  function Context(type, indent, prev) {\n    this.type = type;\n    this.indent = indent;\n    this.prev = prev;\n  }\n\n  function pushContext(state, stream, type, indent) {\n    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\n    return type;\n  }\n\n  function popContext(state) {\n    if (state.context.prev)\n      state.context = state.context.prev;\n    return state.context.type;\n  }\n\n  function pass(type, stream, state) {\n    return states[state.context.type](type, stream, state);\n  }\n  function popAndPass(type, stream, state, n) {\n    for (var i = n || 1; i > 0; i--)\n      state.context = state.context.prev;\n    return pass(type, stream, state);\n  }\n\n  // Parser\n\n  function wordAsValue(stream) {\n    var word = stream.current().toLowerCase();\n    if (valueKeywords.hasOwnProperty(word))\n      override = \"atom\";\n    else if (colorKeywords.hasOwnProperty(word))\n      override = \"keyword\";\n    else\n      override = \"variable\";\n  }\n\n  var states = {};\n\n  states.top = function(type, stream, state) {\n    if (type == \"{\") {\n      return pushContext(state, stream, \"block\");\n    } else if (type == \"}\" && state.context.prev) {\n      return popContext(state);\n    } else if (supportsAtComponent && /@component/.test(type)) {\n      return pushContext(state, stream, \"atComponentBlock\");\n    } else if (/^@(-moz-)?document$/.test(type)) {\n      return pushContext(state, stream, \"documentTypes\");\n    } else if (/^@(media|supports|(-moz-)?document|import)$/.test(type)) {\n      return pushContext(state, stream, \"atBlock\");\n    } else if (/^@(font-face|counter-style)/.test(type)) {\n      state.stateArg = type;\n      return \"restricted_atBlock_before\";\n    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {\n      return \"keyframes\";\n    } else if (type && type.charAt(0) == \"@\") {\n      return pushContext(state, stream, \"at\");\n    } else if (type == \"hash\") {\n      override = \"builtin\";\n    } else if (type == \"word\") {\n      override = \"tag\";\n    } else if (type == \"variable-definition\") {\n      return \"maybeprop\";\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    } else if (type == \":\") {\n      return \"pseudo\";\n    } else if (allowNested && type == \"(\") {\n      return pushContext(state, stream, \"parens\");\n    }\n    return state.context.type;\n  };\n\n  states.block = function(type, stream, state) {\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (propertyKeywords.hasOwnProperty(word)) {\n        override = \"property\";\n        return \"maybeprop\";\n      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {\n        override = \"string-2\";\n        return \"maybeprop\";\n      } else if (allowNested) {\n        override = stream.match(/^\\s*:(?:\\s|$)/, false) ? \"property\" : \"tag\";\n        return \"block\";\n      } else {\n        override += \" error\";\n        return \"maybeprop\";\n      }\n    } else if (type == \"meta\") {\n      return \"block\";\n    } else if (!allowNested && (type == \"hash\" || type == \"qualifier\")) {\n      override = \"error\";\n      return \"block\";\n    } else {\n      return states.top(type, stream, state);\n    }\n  };\n\n  states.maybeprop = function(type, stream, state) {\n    if (type == \":\") return pushContext(state, stream, \"prop\");\n    return pass(type, stream, state);\n  };\n\n  states.prop = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" && allowNested) return pushContext(state, stream, \"propBlock\");\n    if (type == \"}\" || type == \"{\") return popAndPass(type, stream, state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n\n    if (type == \"hash\" && !/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {\n      override += \" error\";\n    } else if (type == \"word\") {\n      wordAsValue(stream);\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    }\n    return \"prop\";\n  };\n\n  states.propBlock = function(type, _stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"word\") { override = \"property\"; return \"maybeprop\"; }\n    return state.context.type;\n  };\n\n  states.parens = function(type, stream, state) {\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \")\") return popContext(state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n    if (type == \"word\") wordAsValue(stream);\n    return \"parens\";\n  };\n\n  states.pseudo = function(type, stream, state) {\n    if (type == \"word\") {\n      override = \"variable-3\";\n      return state.context.type;\n    }\n    return pass(type, stream, state);\n  };\n\n  states.documentTypes = function(type, stream, state) {\n    if (type == \"word\" && documentTypes.hasOwnProperty(stream.current())) {\n      override = \"tag\";\n      return state.context.type;\n    } else {\n      return states.atBlock(type, stream, state);\n    }\n  };\n\n  states.atBlock = function(type, stream, state) {\n    if (type == \"(\") return pushContext(state, stream, \"atBlock_parens\");\n    if (type == \"}\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"{\") return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\");\n\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (word == \"only\" || word == \"not\" || word == \"and\" || word == \"or\")\n        override = \"keyword\";\n      else if (mediaTypes.hasOwnProperty(word))\n        override = \"attribute\";\n      else if (mediaFeatures.hasOwnProperty(word))\n        override = \"property\";\n      else if (mediaValueKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else if (propertyKeywords.hasOwnProperty(word))\n        override = \"property\";\n      else if (nonStandardPropertyKeywords.hasOwnProperty(word))\n        override = \"string-2\";\n      else if (valueKeywords.hasOwnProperty(word))\n        override = \"atom\";\n      else if (colorKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else\n        override = \"error\";\n    }\n    return state.context.type;\n  };\n\n  states.atComponentBlock = function(type, stream, state) {\n    if (type == \"}\")\n      return popAndPass(type, stream, state);\n    if (type == \"{\")\n      return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\", false);\n    if (type == \"word\")\n      override = \"error\";\n    return state.context.type;\n  };\n\n  states.atBlock_parens = function(type, stream, state) {\n    if (type == \")\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state, 2);\n    return states.atBlock(type, stream, state);\n  };\n\n  states.restricted_atBlock_before = function(type, stream, state) {\n    if (type == \"{\")\n      return pushContext(state, stream, \"restricted_atBlock\");\n    if (type == \"word\" && state.stateArg == \"@counter-style\") {\n      override = \"variable\";\n      return \"restricted_atBlock_before\";\n    }\n    return pass(type, stream, state);\n  };\n\n  states.restricted_atBlock = function(type, stream, state) {\n    if (type == \"}\") {\n      state.stateArg = null;\n      return popContext(state);\n    }\n    if (type == \"word\") {\n      if ((state.stateArg == \"@font-face\" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||\n          (state.stateArg == \"@counter-style\" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))\n        override = \"error\";\n      else\n        override = \"property\";\n      return \"maybeprop\";\n    }\n    return \"restricted_atBlock\";\n  };\n\n  states.keyframes = function(type, stream, state) {\n    if (type == \"word\") { override = \"variable\"; return \"keyframes\"; }\n    if (type == \"{\") return pushContext(state, stream, \"top\");\n    return pass(type, stream, state);\n  };\n\n  states.at = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"tag\";\n    else if (type == \"hash\") override = \"builtin\";\n    return \"at\";\n  };\n\n  states.interpolation = function(type, stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"{\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"variable\";\n    else if (type != \"variable\" && type != \"(\" && type != \")\") override = \"error\";\n    return \"interpolation\";\n  };\n\n  return {\n    startState: function(base) {\n      return {tokenize: null,\n              state: parserConfig.inline ? \"block\" : \"top\",\n              stateArg: null,\n              context: new Context(parserConfig.inline ? \"block\" : \"top\", base || 0, null)};\n    },\n\n    token: function(stream, state) {\n      if (!state.tokenize && stream.eatSpace()) return null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style && typeof style == \"object\") {\n        type = style[1];\n        style = style[0];\n      }\n      override = style;\n      state.state = states[state.state](type, stream, state);\n      return override;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n      var indent = cx.indent;\n      if (cx.type == \"prop\" && (ch == \"}\" || ch == \")\")) cx = cx.prev;\n      if (cx.prev) {\n        if (ch == \"}\" && (cx.type == \"block\" || cx.type == \"top\" ||\n                          cx.type == \"interpolation\" || cx.type == \"restricted_atBlock\")) {\n          // Resume indentation from parent context.\n          cx = cx.prev;\n          indent = cx.indent;\n        } else if (ch == \")\" && (cx.type == \"parens\" || cx.type == \"atBlock_parens\") ||\n            ch == \"{\" && (cx.type == \"at\" || cx.type == \"atBlock\")) {\n          // Dedent relative to current context.\n          indent = Math.max(0, cx.indent - indentUnit);\n          cx = cx.prev;\n        }\n      }\n      return indent;\n    },\n\n    electricChars: \"}\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    fold: \"brace\"\n  };\n});\n\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i]] = true;\n    }\n    return keys;\n  }\n\n  var documentTypes_ = [\n    \"domain\", \"regexp\", \"url\", \"url-prefix\"\n  ], documentTypes = keySet(documentTypes_);\n\n  var mediaTypes_ = [\n    \"all\", \"aural\", \"braille\", \"handheld\", \"print\", \"projection\", \"screen\",\n    \"tty\", \"tv\", \"embossed\"\n  ], mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = [\n    \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\",\n    \"device-width\", \"min-device-width\", \"max-device-width\", \"device-height\",\n    \"min-device-height\", \"max-device-height\", \"aspect-ratio\",\n    \"min-aspect-ratio\", \"max-aspect-ratio\", \"device-aspect-ratio\",\n    \"min-device-aspect-ratio\", \"max-device-aspect-ratio\", \"color\", \"min-color\",\n    \"max-color\", \"color-index\", \"min-color-index\", \"max-color-index\",\n    \"monochrome\", \"min-monochrome\", \"max-monochrome\", \"resolution\",\n    \"min-resolution\", \"max-resolution\", \"scan\", \"grid\", \"orientation\",\n    \"device-pixel-ratio\", \"min-device-pixel-ratio\", \"max-device-pixel-ratio\",\n    \"pointer\", \"any-pointer\", \"hover\", \"any-hover\"\n  ], mediaFeatures = keySet(mediaFeatures_);\n\n  var mediaValueKeywords_ = [\n    \"landscape\", \"portrait\", \"none\", \"coarse\", \"fine\", \"on-demand\", \"hover\",\n    \"interlace\", \"progressive\"\n  ], mediaValueKeywords = keySet(mediaValueKeywords_);\n\n  var propertyKeywords_ = [\n    \"align-content\", \"align-items\", \"align-self\", \"alignment-adjust\",\n    \"alignment-baseline\", \"anchor-point\", \"animation\", \"animation-delay\",\n    \"animation-direction\", \"animation-duration\", \"animation-fill-mode\",\n    \"animation-iteration-count\", \"animation-name\", \"animation-play-state\",\n    \"animation-timing-function\", \"appearance\", \"azimuth\", \"backface-visibility\",\n    \"background\", \"background-attachment\", \"background-clip\", \"background-color\",\n    \"background-image\", \"background-origin\", \"background-position\",\n    \"background-repeat\", \"background-size\", \"baseline-shift\", \"binding\",\n    \"bleed\", \"bookmark-label\", \"bookmark-level\", \"bookmark-state\",\n    \"bookmark-target\", \"border\", \"border-bottom\", \"border-bottom-color\",\n    \"border-bottom-left-radius\", \"border-bottom-right-radius\",\n    \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\",\n    \"border-color\", \"border-image\", \"border-image-outset\",\n    \"border-image-repeat\", \"border-image-slice\", \"border-image-source\",\n    \"border-image-width\", \"border-left\", \"border-left-color\",\n    \"border-left-style\", \"border-left-width\", \"border-radius\", \"border-right\",\n    \"border-right-color\", \"border-right-style\", \"border-right-width\",\n    \"border-spacing\", \"border-style\", \"border-top\", \"border-top-color\",\n    \"border-top-left-radius\", \"border-top-right-radius\", \"border-top-style\",\n    \"border-top-width\", \"border-width\", \"bottom\", \"box-decoration-break\",\n    \"box-shadow\", \"box-sizing\", \"break-after\", \"break-before\", \"break-inside\",\n    \"caption-side\", \"clear\", \"clip\", \"color\", \"color-profile\", \"column-count\",\n    \"column-fill\", \"column-gap\", \"column-rule\", \"column-rule-color\",\n    \"column-rule-style\", \"column-rule-width\", \"column-span\", \"column-width\",\n    \"columns\", \"content\", \"counter-increment\", \"counter-reset\", \"crop\", \"cue\",\n    \"cue-after\", \"cue-before\", \"cursor\", \"direction\", \"display\",\n    \"dominant-baseline\", \"drop-initial-after-adjust\",\n    \"drop-initial-after-align\", \"drop-initial-before-adjust\",\n    \"drop-initial-before-align\", \"drop-initial-size\", \"drop-initial-value\",\n    \"elevation\", \"empty-cells\", \"fit\", \"fit-position\", \"flex\", \"flex-basis\",\n    \"flex-direction\", \"flex-flow\", \"flex-grow\", \"flex-shrink\", \"flex-wrap\",\n    \"float\", \"float-offset\", \"flow-from\", \"flow-into\", \"font\", \"font-feature-settings\",\n    \"font-family\", \"font-kerning\", \"font-language-override\", \"font-size\", \"font-size-adjust\",\n    \"font-stretch\", \"font-style\", \"font-synthesis\", \"font-variant\",\n    \"font-variant-alternates\", \"font-variant-caps\", \"font-variant-east-asian\",\n    \"font-variant-ligatures\", \"font-variant-numeric\", \"font-variant-position\",\n    \"font-weight\", \"grid\", \"grid-area\", \"grid-auto-columns\", \"grid-auto-flow\",\n    \"grid-auto-position\", \"grid-auto-rows\", \"grid-column\", \"grid-column-end\",\n    \"grid-column-start\", \"grid-row\", \"grid-row-end\", \"grid-row-start\",\n    \"grid-template\", \"grid-template-areas\", \"grid-template-columns\",\n    \"grid-template-rows\", \"hanging-punctuation\", \"height\", \"hyphens\",\n    \"icon\", \"image-orientation\", \"image-rendering\", \"image-resolution\",\n    \"inline-box-align\", \"justify-content\", \"left\", \"letter-spacing\",\n    \"line-break\", \"line-height\", \"line-stacking\", \"line-stacking-ruby\",\n    \"line-stacking-shift\", \"line-stacking-strategy\", \"list-style\",\n    \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\",\n    \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\",\n    \"marker-offset\", \"marks\", \"marquee-direction\", \"marquee-loop\",\n    \"marquee-play-count\", \"marquee-speed\", \"marquee-style\", \"max-height\",\n    \"max-width\", \"min-height\", \"min-width\", \"move-to\", \"nav-down\", \"nav-index\",\n    \"nav-left\", \"nav-right\", \"nav-up\", \"object-fit\", \"object-position\",\n    \"opacity\", \"order\", \"orphans\", \"outline\",\n    \"outline-color\", \"outline-offset\", \"outline-style\", \"outline-width\",\n    \"overflow\", \"overflow-style\", \"overflow-wrap\", \"overflow-x\", \"overflow-y\",\n    \"padding\", \"padding-bottom\", \"padding-left\", \"padding-right\", \"padding-top\",\n    \"page\", \"page-break-after\", \"page-break-before\", \"page-break-inside\",\n    \"page-policy\", \"pause\", \"pause-after\", \"pause-before\", \"perspective\",\n    \"perspective-origin\", \"pitch\", \"pitch-range\", \"play-during\", \"position\",\n    \"presentation-level\", \"punctuation-trim\", \"quotes\", \"region-break-after\",\n    \"region-break-before\", \"region-break-inside\", \"region-fragment\",\n    \"rendering-intent\", \"resize\", \"rest\", \"rest-after\", \"rest-before\", \"richness\",\n    \"right\", \"rotation\", \"rotation-point\", \"ruby-align\", \"ruby-overhang\",\n    \"ruby-position\", \"ruby-span\", \"shape-image-threshold\", \"shape-inside\", \"shape-margin\",\n    \"shape-outside\", \"size\", \"speak\", \"speak-as\", \"speak-header\",\n    \"speak-numeral\", \"speak-punctuation\", \"speech-rate\", \"stress\", \"string-set\",\n    \"tab-size\", \"table-layout\", \"target\", \"target-name\", \"target-new\",\n    \"target-position\", \"text-align\", \"text-align-last\", \"text-decoration\",\n    \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-skip\",\n    \"text-decoration-style\", \"text-emphasis\", \"text-emphasis-color\",\n    \"text-emphasis-position\", \"text-emphasis-style\", \"text-height\",\n    \"text-indent\", \"text-justify\", \"text-outline\", \"text-overflow\", \"text-shadow\",\n    \"text-size-adjust\", \"text-space-collapse\", \"text-transform\", \"text-underline-position\",\n    \"text-wrap\", \"top\", \"transform\", \"transform-origin\", \"transform-style\",\n    \"transition\", \"transition-delay\", \"transition-duration\",\n    \"transition-property\", \"transition-timing-function\", \"unicode-bidi\",\n    \"vertical-align\", \"visibility\", \"voice-balance\", \"voice-duration\",\n    \"voice-family\", \"voice-pitch\", \"voice-range\", \"voice-rate\", \"voice-stress\",\n    \"voice-volume\", \"volume\", \"white-space\", \"widows\", \"width\", \"word-break\",\n    \"word-spacing\", \"word-wrap\", \"z-index\",\n    // SVG-specific\n    \"clip-path\", \"clip-rule\", \"mask\", \"enable-background\", \"filter\", \"flood-color\",\n    \"flood-opacity\", \"lighting-color\", \"stop-color\", \"stop-opacity\", \"pointer-events\",\n    \"color-interpolation\", \"color-interpolation-filters\",\n    \"color-rendering\", \"fill\", \"fill-opacity\", \"fill-rule\", \"image-rendering\",\n    \"marker\", \"marker-end\", \"marker-mid\", \"marker-start\", \"shape-rendering\", \"stroke\",\n    \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\",\n    \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"text-rendering\",\n    \"baseline-shift\", \"dominant-baseline\", \"glyph-orientation-horizontal\",\n    \"glyph-orientation-vertical\", \"text-anchor\", \"writing-mode\"\n  ], propertyKeywords = keySet(propertyKeywords_);\n\n  var nonStandardPropertyKeywords_ = [\n    \"scrollbar-arrow-color\", \"scrollbar-base-color\", \"scrollbar-dark-shadow-color\",\n    \"scrollbar-face-color\", \"scrollbar-highlight-color\", \"scrollbar-shadow-color\",\n    \"scrollbar-3d-light-color\", \"scrollbar-track-color\", \"shape-inside\",\n    \"searchfield-cancel-button\", \"searchfield-decoration\", \"searchfield-results-button\",\n    \"searchfield-results-decoration\", \"zoom\"\n  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\n\n  var fontProperties_ = [\n    \"font-family\", \"src\", \"unicode-range\", \"font-variant\", \"font-feature-settings\",\n    \"font-stretch\", \"font-weight\", \"font-style\"\n  ], fontProperties = keySet(fontProperties_);\n\n  var counterDescriptors_ = [\n    \"additive-symbols\", \"fallback\", \"negative\", \"pad\", \"prefix\", \"range\",\n    \"speak-as\", \"suffix\", \"symbols\", \"system\"\n  ], counterDescriptors = keySet(counterDescriptors_);\n\n  var colorKeywords_ = [\n    \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\n    \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\n    \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\",\n    \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\",\n    \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\",\n    \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\",\n    \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\",\n    \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\",\n    \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\",\n    \"gold\", \"goldenrod\", \"gray\", \"grey\", \"green\", \"greenyellow\", \"honeydew\",\n    \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\n    \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\",\n    \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightpink\",\n    \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\",\n    \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\",\n    \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\",\n    \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n    \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\",\n    \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\",\n    \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\",\n    \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\",\n    \"purple\", \"rebeccapurple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\",\n    \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\n    \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\",\n    \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\",\n    \"whitesmoke\", \"yellow\", \"yellowgreen\"\n  ], colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = [\n    \"above\", \"absolute\", \"activeborder\", \"additive\", \"activecaption\", \"afar\",\n    \"after-white-space\", \"ahead\", \"alias\", \"all\", \"all-scroll\", \"alphabetic\", \"alternate\",\n    \"always\", \"amharic\", \"amharic-abegede\", \"antialiased\", \"appworkspace\",\n    \"arabic-indic\", \"armenian\", \"asterisks\", \"attr\", \"auto\", \"avoid\", \"avoid-column\", \"avoid-page\",\n    \"avoid-region\", \"background\", \"backwards\", \"baseline\", \"below\", \"bidi-override\", \"binary\",\n    \"bengali\", \"blink\", \"block\", \"block-axis\", \"bold\", \"bolder\", \"border\", \"border-box\",\n    \"both\", \"bottom\", \"break\", \"break-all\", \"break-word\", \"bullets\", \"button\", \"button-bevel\",\n    \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\", \"calc\", \"cambodian\",\n    \"capitalize\", \"caps-lock-indicator\", \"caption\", \"captiontext\", \"caret\",\n    \"cell\", \"center\", \"checkbox\", \"circle\", \"cjk-decimal\", \"cjk-earthly-branch\",\n    \"cjk-heavenly-stem\", \"cjk-ideographic\", \"clear\", \"clip\", \"close-quote\",\n    \"col-resize\", \"collapse\", \"column\", \"column-reverse\", \"compact\", \"condensed\", \"contain\", \"content\",\n    \"content-box\", \"context-menu\", \"continuous\", \"copy\", \"counter\", \"counters\", \"cover\", \"crop\",\n    \"cross\", \"crosshair\", \"currentcolor\", \"cursive\", \"cyclic\", \"dashed\", \"decimal\",\n    \"decimal-leading-zero\", \"default\", \"default-button\", \"destination-atop\",\n    \"destination-in\", \"destination-out\", \"destination-over\", \"devanagari\",\n    \"disc\", \"discard\", \"disclosure-closed\", \"disclosure-open\", \"document\",\n    \"dot-dash\", \"dot-dot-dash\",\n    \"dotted\", \"double\", \"down\", \"e-resize\", \"ease\", \"ease-in\", \"ease-in-out\", \"ease-out\",\n    \"element\", \"ellipse\", \"ellipsis\", \"embed\", \"end\", \"ethiopic\", \"ethiopic-abegede\",\n    \"ethiopic-abegede-am-et\", \"ethiopic-abegede-gez\", \"ethiopic-abegede-ti-er\",\n    \"ethiopic-abegede-ti-et\", \"ethiopic-halehame-aa-er\",\n    \"ethiopic-halehame-aa-et\", \"ethiopic-halehame-am-et\",\n    \"ethiopic-halehame-gez\", \"ethiopic-halehame-om-et\",\n    \"ethiopic-halehame-sid-et\", \"ethiopic-halehame-so-et\",\n    \"ethiopic-halehame-ti-er\", \"ethiopic-halehame-ti-et\", \"ethiopic-halehame-tig\",\n    \"ethiopic-numeric\", \"ew-resize\", \"expanded\", \"extends\", \"extra-condensed\",\n    \"extra-expanded\", \"fantasy\", \"fast\", \"fill\", \"fixed\", \"flat\", \"flex\", \"flex-end\", \"flex-start\", \"footnotes\",\n    \"forwards\", \"from\", \"geometricPrecision\", \"georgian\", \"graytext\", \"groove\",\n    \"gujarati\", \"gurmukhi\", \"hand\", \"hangul\", \"hangul-consonant\", \"hebrew\",\n    \"help\", \"hidden\", \"hide\", \"higher\", \"highlight\", \"highlighttext\",\n    \"hiragana\", \"hiragana-iroha\", \"horizontal\", \"hsl\", \"hsla\", \"icon\", \"ignore\",\n    \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\", \"infinite\",\n    \"infobackground\", \"infotext\", \"inherit\", \"initial\", \"inline\", \"inline-axis\",\n    \"inline-block\", \"inline-flex\", \"inline-table\", \"inset\", \"inside\", \"intrinsic\", \"invert\",\n    \"italic\", \"japanese-formal\", \"japanese-informal\", \"justify\", \"kannada\",\n    \"katakana\", \"katakana-iroha\", \"keep-all\", \"khmer\",\n    \"korean-hangul-formal\", \"korean-hanja-formal\", \"korean-hanja-informal\",\n    \"landscape\", \"lao\", \"large\", \"larger\", \"left\", \"level\", \"lighter\",\n    \"line-through\", \"linear\", \"linear-gradient\", \"lines\", \"list-item\", \"listbox\", \"listitem\",\n    \"local\", \"logical\", \"loud\", \"lower\", \"lower-alpha\", \"lower-armenian\",\n    \"lower-greek\", \"lower-hexadecimal\", \"lower-latin\", \"lower-norwegian\",\n    \"lower-roman\", \"lowercase\", \"ltr\", \"malayalam\", \"match\", \"matrix\", \"matrix3d\",\n    \"media-controls-background\", \"media-current-time-display\",\n    \"media-fullscreen-button\", \"media-mute-button\", \"media-play-button\",\n    \"media-return-to-realtime-button\", \"media-rewind-button\",\n    \"media-seek-back-button\", \"media-seek-forward-button\", \"media-slider\",\n    \"media-sliderthumb\", \"media-time-remaining-display\", \"media-volume-slider\",\n    \"media-volume-slider-container\", \"media-volume-sliderthumb\", \"medium\",\n    \"menu\", \"menulist\", \"menulist-button\", \"menulist-text\",\n    \"menulist-textfield\", \"menutext\", \"message-box\", \"middle\", \"min-intrinsic\",\n    \"mix\", \"mongolian\", \"monospace\", \"move\", \"multiple\", \"myanmar\", \"n-resize\",\n    \"narrower\", \"ne-resize\", \"nesw-resize\", \"no-close-quote\", \"no-drop\",\n    \"no-open-quote\", \"no-repeat\", \"none\", \"normal\", \"not-allowed\", \"nowrap\",\n    \"ns-resize\", \"numbers\", \"numeric\", \"nw-resize\", \"nwse-resize\", \"oblique\", \"octal\", \"open-quote\",\n    \"optimizeLegibility\", \"optimizeSpeed\", \"oriya\", \"oromo\", \"outset\",\n    \"outside\", \"outside-shape\", \"overlay\", \"overline\", \"padding\", \"padding-box\",\n    \"painted\", \"page\", \"paused\", \"persian\", \"perspective\", \"plus-darker\", \"plus-lighter\",\n    \"pointer\", \"polygon\", \"portrait\", \"pre\", \"pre-line\", \"pre-wrap\", \"preserve-3d\",\n    \"progress\", \"push-button\", \"radial-gradient\", \"radio\", \"read-only\",\n    \"read-write\", \"read-write-plaintext-only\", \"rectangle\", \"region\",\n    \"relative\", \"repeat\", \"repeating-linear-gradient\",\n    \"repeating-radial-gradient\", \"repeat-x\", \"repeat-y\", \"reset\", \"reverse\",\n    \"rgb\", \"rgba\", \"ridge\", \"right\", \"rotate\", \"rotate3d\", \"rotateX\", \"rotateY\",\n    \"rotateZ\", \"round\", \"row\", \"row-resize\", \"row-reverse\", \"rtl\", \"run-in\", \"running\",\n    \"s-resize\", \"sans-serif\", \"scale\", \"scale3d\", \"scaleX\", \"scaleY\", \"scaleZ\",\n    \"scroll\", \"scrollbar\", \"se-resize\", \"searchfield\",\n    \"searchfield-cancel-button\", \"searchfield-decoration\",\n    \"searchfield-results-button\", \"searchfield-results-decoration\",\n    \"semi-condensed\", \"semi-expanded\", \"separate\", \"serif\", \"show\", \"sidama\",\n    \"simp-chinese-formal\", \"simp-chinese-informal\", \"single\",\n    \"skew\", \"skewX\", \"skewY\", \"skip-white-space\", \"slide\", \"slider-horizontal\",\n    \"slider-vertical\", \"sliderthumb-horizontal\", \"sliderthumb-vertical\", \"slow\",\n    \"small\", \"small-caps\", \"small-caption\", \"smaller\", \"solid\", \"somali\",\n    \"source-atop\", \"source-in\", \"source-out\", \"source-over\", \"space\", \"space-around\", \"space-between\", \"spell-out\", \"square\",\n    \"square-button\", \"start\", \"static\", \"status-bar\", \"stretch\", \"stroke\", \"sub\",\n    \"subpixel-antialiased\", \"super\", \"sw-resize\", \"symbolic\", \"symbols\", \"table\",\n    \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\",\n    \"table-footer-group\", \"table-header-group\", \"table-row\", \"table-row-group\",\n    \"tamil\",\n    \"telugu\", \"text\", \"text-bottom\", \"text-top\", \"textarea\", \"textfield\", \"thai\",\n    \"thick\", \"thin\", \"threeddarkshadow\", \"threedface\", \"threedhighlight\",\n    \"threedlightshadow\", \"threedshadow\", \"tibetan\", \"tigre\", \"tigrinya-er\",\n    \"tigrinya-er-abegede\", \"tigrinya-et\", \"tigrinya-et-abegede\", \"to\", \"top\",\n    \"trad-chinese-formal\", \"trad-chinese-informal\",\n    \"translate\", \"translate3d\", \"translateX\", \"translateY\", \"translateZ\",\n    \"transparent\", \"ultra-condensed\", \"ultra-expanded\", \"underline\", \"up\",\n    \"upper-alpha\", \"upper-armenian\", \"upper-greek\", \"upper-hexadecimal\",\n    \"upper-latin\", \"upper-norwegian\", \"upper-roman\", \"uppercase\", \"urdu\", \"url\",\n    \"var\", \"vertical\", \"vertical-text\", \"visible\", \"visibleFill\", \"visiblePainted\",\n    \"visibleStroke\", \"visual\", \"w-resize\", \"wait\", \"wave\", \"wider\",\n    \"window\", \"windowframe\", \"windowtext\", \"words\", \"wrap\", \"wrap-reverse\", \"x-large\", \"x-small\", \"xor\",\n    \"xx-large\", \"xx-small\"\n  ], valueKeywords = keySet(valueKeywords_);\n\n  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)\n    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)\n    .concat(valueKeywords_);\n  CodeMirror.registerHelper(\"hintWords\", \"css\", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == \"/\") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return [\"comment\", \"comment\"];\n  }\n\n  CodeMirror.defineMIME(\"text/css\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-scss\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \":\": function(stream) {\n        if (stream.match(/\\s*\\{/))\n          return [null, \"{\"];\n        return false;\n      },\n      \"$\": function(stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"#\": function(stream) {\n        if (!stream.eat(\"{\")) return false;\n        return [null, \"interpolation\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"scss\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-less\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \"@\": function(stream) {\n        if (stream.eat(\"{\")) return [null, \"interpolation\"];\n        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"&\": function() {\n        return [\"atom\", \"atom\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"less\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-gss\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    supportsAtComponent: true,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\",\n    helperType: \"gss\"\n  });\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/mode/css/css.js\n ** module id = 17\n ** module chunks = 0\n **/","/* jshint evil: true */\n\n/**\n* Code inspired and taken from https://babeljs.io/scripts/repl.js.\n*/\n// import 'script!babel-polyfill/dist/polyfill';\n// import babel from 'script!babel-core/browser';\n\n// import $ from 'jquery';\nimport _ from 'underscore';\n\nimport CodeMirror from 'codemirror/lib/codemirror';\nimport 'codemirror/addon/comment/comment';\nimport 'codemirror/keymap/sublime';\n\n// babel is provided in an external script tag\nexport default class BabelREPL {\n  constructor($context) {\n    this.$context = $context;\n\n    this.$consoleReporter = this.$context.find('.js-console');\n    this.$output = $context.find('.js-output');\n    this.$toggleFullScreen = $context.find('.js-toggle-fs');\n\n    // Create the CodeMirror editors which give us nice things\n    // like line number, key maps, and syntax highlighting.\n    this.editorCompiled = CodeMirror.fromTextArea($context.find('.js-demo-compiled')[0], {\n      mode: \"javascript\",\n      lineNumbers: true,\n      matchBrackets: true,\n      tabSize: 2,\n      readOnly: true,\n      theme: 'seti',\n      keyMap: 'sublime'\n    });\n\n    this.editor = CodeMirror.fromTextArea($context.find('.js-demo-text')[0], {\n      mode: \"javascript\",\n      lineNumbers: true,\n      matchBrackets: true,\n      tabSize: 2,\n      theme: 'seti',\n      keyMap: 'sublime'\n    });\n\n    // Compile what's already in there.\n    this.compile(this.editor.getValue());\n\n    // Attach to change event so we can recompile each time something\n    // changes.\n    this.editor.on('change', _.debounce(this.handleCodeChange, 500).bind(this));\n\n    this.$toggleFullScreen.click(() => {\n      $context.toggleClass('is-full');\n\n      if ($context.hasClass('is-full')) {\n        this.$toggleFullScreen.text('Exit Full Screen');\n      } else {\n        this.$toggleFullScreen.text('Full Screen');\n      }\n\n      this.editor.refresh();\n      this.editorCompiled.refresh();\n    });\n  }\n\n  // The following methods are taken from Babel's REPL\n  // code, though many of them have been modified to\n  // fit our needs.\n  refresh() {\n    // console.log('refresh');\n    this.editor.refresh();\n    this.editorCompiled.refresh();\n  }\n\n  handleCodeChange(instance, changeObj) {\n    this.compile(instance.getValue());\n  }\n\n  clear() {\n    this.editorCompiled.setValue('');\n    this.$output.empty();\n    this.$consoleReporter.empty();\n  }\n\n  compile(code) {\n    let transformed;\n\n    // Clear our output and console each time we recompile.\n    this.clear();\n\n    try {\n      // console.log('code', code);\n      transformed = babel.transform(code, {});\n      //console.log('past transform');\n      this.editorCompiled.setValue(transformed.code);\n      //console.log('past setValue');\n      this.evaluate(transformed.code);\n      //console.log('past evaluate');\n    } catch (err) {\n      // console.log('ERROR thrown', transformed.code);\n      // don't throw it.. just output it\n      this.$output.text(err.message);\n      this.$consoleReporter.text(err.message);\n    }\n  }\n\n  evaluate(code) {\n    if (typeof this.capturingConsole === 'undefined') {\n      // extend console\n      this.capturingConsole = Object.create(console);\n    }\n    let capturingConsole = this.capturingConsole;\n\n    let $consoleReporter = this.$consoleReporter;\n    let buffer = [];\n    let error;\n    let done = false;\n\n    function flush() {\n      //console.log('buffer', buffer);\n      $consoleReporter.text(buffer.join('\\n'));\n    }\n\n    function write(data) {\n      buffer.push(data);\n      if (done) {\n        flush();\n      }\n    }\n\n    capturingConsole.clear = function() {\n      buffer = [];\n      flush();\n    };\n\n    capturingConsole.error = function() {\n      error = true;\n      capturingConsole.log.apply(capturingConsole, arguments);\n    };\n\n    capturingConsole.log =\n    capturingConsole.info =\n    capturingConsole.debug = function() {\n      if (this !== capturingConsole) { return; }\n\n      let args = Array.prototype.slice.call(arguments);\n      Function.prototype.apply.call(console.log, console, args);\n\n      let logs = args.reduce(function(logs, log) {\n        console.log('log', log);\n        if (typeof log === 'string') {\n          // console.log('string');\n          logs.push(log);\n        } else if (typeof log === 'symbol') {\n          logs.push(String(log));\n        } else if (log instanceof Function) {\n          // console.log('function');\n          logs.push(log.toString());\n        } else {\n          // console.log('log', log);\n          // We need to account for DOM elements.\n          if (typeof log !== 'undefined' &&\n            typeof log.outerHTML !== 'undefined') {\n            logs.push(log.outerHTML);\n          } else {\n            try {\n              log = JSON.stringify(log);\n            } catch(e) {\n\n            }\n            logs.push(String(log));\n          }\n        }\n\n        return logs;\n      }, []);\n\n      // console.log('logs', logs);\n      write(logs.join('\\n'));\n    };\n\n    try {\n      // So this is actually running the code we obtained\n      // and setting the console used as the capturingConsole\n      // we created. It's cool because it gives us control\n      // over what to replace in our block of our code.\n      // (function(console, $$, code) {}(capturingConsole, this.$output));\n      new Function('console', '$$', 'require', code)(capturingConsole, this.$output, this.myRequire);\n    } catch (err) {\n      error = err;\n      buffer.push(err.message);\n    }\n\n    done = true;\n    flush();\n\n    if (error) {\n      throw error;\n    }\n  }\n\n  myRequire(id) {\n    return {\n      a: function() {\n        return 'i am a';\n      },\n      b: function() {\n        return 'i am beaver';\n      }\n    };\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/babel/repl.js\n **/","//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result — either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/underscore/underscore.js\n ** module id = 19\n ** module chunks = 0\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var noOptions = {};\n  var nonWS = /[^\\s\\u00a0]/;\n  var Pos = CodeMirror.Pos;\n\n  function firstNonWS(str) {\n    var found = str.search(nonWS);\n    return found == -1 ? 0 : found;\n  }\n\n  CodeMirror.commands.toggleComment = function(cm) {\n    cm.toggleComment();\n  };\n\n  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n    if (!options) options = noOptions;\n    var cm = this;\n    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      if (from.line >= minLine) continue;\n      if (to.line >= minLine) to = Pos(minLine, 0);\n      minLine = from.line;\n      if (mode == null) {\n        if (cm.uncomment(from, to, options)) mode = \"un\";\n        else { cm.lineComment(from, to, options); mode = \"line\"; }\n      } else if (mode == \"un\") {\n        cm.uncomment(from, to, options);\n      } else {\n        cm.lineComment(from, to, options);\n      }\n    }\n  });\n\n  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = self.getModeAt(from);\n    var commentString = options.lineComment || mode.lineComment;\n    if (!commentString) {\n      if (options.blockCommentStart || mode.blockCommentStart) {\n        options.fullLines = true;\n        self.blockComment(from, to, options);\n      }\n      return;\n    }\n    var firstLine = self.getLine(from.line);\n    if (firstLine == null) return;\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n    var pad = options.padding == null ? \" \" : options.padding;\n    var blankLines = options.commentBlankLines || from.line == to.line;\n\n    self.operation(function() {\n      if (options.indent) {\n        var baseString = null;\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i);\n          var whitespace = line.slice(0, firstNonWS(line));\n          if (baseString == null || baseString.length > whitespace.length) {\n            baseString = whitespace;\n          }\n        }\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i), cut = baseString.length;\n          if (!blankLines && !nonWS.test(line)) continue;\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n        }\n      } else {\n        for (var i = from.line; i < end; ++i) {\n          if (blankLines || nonWS.test(self.getLine(i)))\n            self.replaceRange(commentString + pad, Pos(i, 0));\n        }\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = self.getModeAt(from);\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) {\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n        self.lineComment(from, to, options);\n      return;\n    }\n\n    var end = Math.min(to.line, self.lastLine());\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\n    var pad = options.padding == null ? \" \" : options.padding;\n    if (from.line > end) return;\n\n    self.operation(function() {\n      if (options.fullLines != false) {\n        var lastLineHasText = nonWS.test(self.getLine(end));\n        self.replaceRange(pad + endString, Pos(end));\n        self.replaceRange(startString + pad, Pos(from.line, 0));\n        var lead = options.blockCommentLead || mode.blockCommentLead;\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n          if (i != end || lastLineHasText)\n            self.replaceRange(lead + pad, Pos(i, 0));\n      } else {\n        self.replaceRange(endString, to);\n        self.replaceRange(startString, from);\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = self.getModeAt(from);\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\n    // Try finding line comments\n    var lineString = options.lineComment || mode.lineComment, lines = [];\n    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n    lineComment: {\n      if (!lineString) break lineComment;\n      for (var i = start; i <= end; ++i) {\n        var line = self.getLine(i);\n        var found = line.indexOf(lineString);\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n        if (found == -1 && (i != end || i == start) && nonWS.test(line)) break lineComment;\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n        lines.push(line);\n      }\n      self.operation(function() {\n        for (var i = start; i <= end; ++i) {\n          var line = lines[i - start];\n          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n          if (pos < 0) continue;\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n          didSomething = true;\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n        }\n      });\n      if (didSomething) return true;\n    }\n\n    // Try block comments\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) return false;\n    var lead = options.blockCommentLead || mode.blockCommentLead;\n    var startLine = self.getLine(start), endLine = end == start ? startLine : self.getLine(end);\n    var open = startLine.indexOf(startString), close = endLine.lastIndexOf(endString);\n    if (close == -1 && start != end) {\n      endLine = self.getLine(--end);\n      close = endLine.lastIndexOf(endString);\n    }\n    if (open == -1 || close == -1 ||\n        !/comment/.test(self.getTokenTypeAt(Pos(start, open + 1))) ||\n        !/comment/.test(self.getTokenTypeAt(Pos(end, close + 1))))\n      return false;\n\n    // Avoid killing block comments completely outside the selection.\n    // Positions of the last startString before the start of the selection, and the first endString after it.\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n    // Positions of the first endString after the end of the selection, and the last startString before it.\n    firstEnd = endLine.indexOf(endString, to.ch);\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\n    self.operation(function() {\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n                        Pos(end, close + endString.length));\n      var openEnd = open + startString.length;\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n      if (lead) for (var i = start + 1; i <= end; ++i) {\n        var line = self.getLine(i), found = line.indexOf(lead);\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n        var foundEnd = found + lead.length;\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n      }\n    });\n    return true;\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/addon/comment/comment.js\n ** module id = 20\n ** module chunks = 0\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var map = CodeMirror.keyMap.sublime = {fallthrough: \"default\"};\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  var mac = CodeMirror.keyMap[\"default\"] == CodeMirror.keyMap.macDefault;\n  var ctrl = mac ? \"Cmd-\" : \"Ctrl-\";\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type;\n    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { type = \"w\"; continue; }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  cmds[map[\"Alt-Left\"] = \"goSubwordLeft\"] = function(cm) { moveSubword(cm, -1); };\n  cmds[map[\"Alt-Right\"] = \"goSubwordRight\"] = function(cm) { moveSubword(cm, 1); };\n\n  var scrollLineCombo = mac ? \"Ctrl-Alt-\" : \"Ctrl-\";\n\n  cmds[map[scrollLineCombo + \"Up\"] = \"scrollLineUp\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds[map[scrollLineCombo + \"Down\"] = \"scrollLineDown\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"L\"] = \"splitSelectionByLine\"] = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  map[\"Shift-Tab\"] = \"indentLess\";\n\n  cmds[map[\"Esc\"] = \"singleSelectionTop\"] = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds[map[ctrl + \"L\"] = \"selectLine\"] = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  map[\"Shift-\" + ctrl + \"K\"] = \"deleteLine\";\n\n  function insertLine(cm, above) {\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n  }\n\n  cmds[map[ctrl + \"Enter\"] = \"insertLineAfter\"] = function(cm) { insertLine(cm, false); };\n\n  cmds[map[\"Shift-\" + ctrl + \"Enter\"] = \"insertLineBefore\"] = function(cm) { insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds[map[ctrl + \"D\"] = \"selectNextOccurrence\"] = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      if (cur.findNext()) {\n        cm.addSelection(cur.from(), cur.to());\n      } else {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        if (cur.findNext())\n          cm.addSelection(cur.from(), cur.to());\n      }\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var pos = cm.getCursor(), opening = cm.scanForBracket(pos, -1);\n    if (!opening) return;\n    for (;;) {\n      var closing = cm.scanForBracket(pos, 1);\n      if (!closing) return;\n      if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n        cm.setSelection(Pos(opening.pos.line, opening.pos.ch + 1), closing.pos, false);\n        return true;\n      }\n      pos = Pos(closing.pos.line, closing.pos.ch + 1);\n    }\n  }\n\n  cmds[map[\"Shift-\" + ctrl + \"Space\"] = \"selectScope\"] = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds[map[\"Shift-\" + ctrl + \"M\"] = \"selectBetweenBrackets\"] = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  cmds[map[ctrl + \"M\"] = \"goToBracket\"] = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1);\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1);\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  var swapLineCombo = mac ? \"Cmd-Ctrl-\" : \"Shift-Ctrl-\";\n\n  cmds[map[swapLineCombo + \"Up\"] = \"swapLineUp\"] = function(cm) {\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[swapLineCombo + \"Down\"] = \"swapLineDown\"] = function(cm) {\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  map[ctrl + \"/\"] = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds[map[ctrl + \"J\"] = \"joinLines\"] = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"D\"] = \"duplicateLine\"] = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  map[ctrl + \"T\"] = \"transposeChars\";\n\n  function sortLines(cm, caseSensitive) {\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = range[++i].to().line;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort();\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -1 : a == b ? 0 : 1;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: end});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds[map[\"F9\"] = \"sortLines\"] = function(cm) { sortLines(cm, true); };\n  cmds[map[ctrl + \"F9\"] = \"sortLinesInsensitive\"] = function(cm) { sortLines(cm, false); };\n\n  cmds[map[\"F2\"] = \"nextBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds[map[\"Shift-F2\"] = \"prevBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds[map[ctrl + \"F2\"] = \"toggleBookmark\"] = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"F2\"] = \"clearBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds[map[\"Alt-F2\"] = \"selectBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  map[\"Alt-Q\"] = \"wrapLines\";\n\n  var cK = ctrl + \"K \";\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  map[cK + ctrl + \"Backspace\"] = \"delLineLeft\";\n\n  cmds[map[\"Backspace\"] = \"smartBackspace\"] = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    var cursor = cm.getCursor();\n    var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n    var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n    var indentUnit = cm.getOption(\"indentUnit\");\n\n    if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n      var prevIndent = new Pos(cursor.line,\n        CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n      // If no smart delete is happening (due to tab sizing) just do a regular delete\n      if (prevIndent.ch == cursor.ch) return CodeMirror.Pass;\n\n      return cm.replaceRange(\"\", prevIndent, cursor, \"+delete\");\n    } else {\n      return CodeMirror.Pass;\n    }\n  };\n\n  cmds[map[cK + ctrl + \"K\"] = \"delLineRight\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[cK + ctrl + \"U\"] = \"upcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds[map[cK + ctrl + \"L\"] = \"downcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds[map[cK + ctrl + \"Space\"] = \"setSublimeMark\"] = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds[map[cK + ctrl + \"A\"] = \"selectToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds[map[cK + ctrl + \"W\"] = \"deleteToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds[map[cK + ctrl + \"X\"] = \"swapWithSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds[map[cK + ctrl + \"Y\"] = \"sublimeYank\"] = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  map[cK + ctrl + \"G\"] = \"clearBookmarks\";\n  cmds[map[cK + ctrl + \"C\"] = \"showInCenter\"] = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  cmds[map[\"Shift-Alt-Up\"] = \"selectLinesUpward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line > cm.firstLine())\n          cm.addSelection(Pos(range.head.line - 1, range.head.ch));\n      }\n    });\n  };\n  cmds[map[\"Shift-Alt-Down\"] = \"selectLinesDownward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line < cm.lastLine())\n          cm.addSelection(Pos(range.head.line + 1, range.head.ch));\n      }\n    });\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds[map[ctrl + \"F3\"] = \"findUnder\"] = function(cm) { findAndGoTo(cm, true); };\n  cmds[map[\"Shift-\" + ctrl + \"F3\"] = \"findUnderPrevious\"] = function(cm) { findAndGoTo(cm,false); };\n  cmds[map[\"Alt-F3\"] = \"findAllUnder\"] = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n  map[\"Shift-\" + ctrl + \"[\"] = \"fold\";\n  map[\"Shift-\" + ctrl + \"]\"] = \"unfold\";\n  map[cK + ctrl + \"0\"] = map[cK + ctrl + \"j\"] = \"unfoldAll\";\n\n  map[ctrl + \"I\"] = \"findIncremental\";\n  map[\"Shift-\" + ctrl + \"I\"] = \"findIncrementalReverse\";\n  map[ctrl + \"H\"] = \"replace\";\n  map[\"F3\"] = \"findNext\";\n  map[\"Shift-F3\"] = \"findPrev\";\n\n  CodeMirror.normalizeKeyMap(map);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/keymap/sublime.js\n ** module id = 21\n ** module chunks = 0\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var Pos = CodeMirror.Pos;\n\n  function SearchCursor(doc, query, pos, caseFold) {\n    this.atOccurrence = false; this.doc = doc;\n    if (caseFold == null && typeof query == \"string\") caseFold = false;\n\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n    this.pos = {from: pos, to: pos};\n\n    // The matches method is filled in based on the type of query.\n    // It takes a position and a direction, and returns an object\n    // describing the next occurrence of the query, or null if no\n    // more matches were found.\n    if (typeof query != \"string\") { // Regexp match\n      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? \"ig\" : \"g\");\n      this.matches = function(reverse, pos) {\n        if (reverse) {\n          query.lastIndex = 0;\n          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;\n          for (;;) {\n            query.lastIndex = cutOff;\n            var newMatch = query.exec(line);\n            if (!newMatch) break;\n            match = newMatch;\n            start = match.index;\n            cutOff = match.index + (match[0].length || 1);\n            if (cutOff == line.length) break;\n          }\n          var matchLen = (match && match[0].length) || 0;\n          if (!matchLen) {\n            if (start == 0 && line.length == 0) {match = undefined;}\n            else if (start != doc.getLine(pos.line).length) {\n              matchLen++;\n            }\n          }\n        } else {\n          query.lastIndex = pos.ch;\n          var line = doc.getLine(pos.line), match = query.exec(line);\n          var matchLen = (match && match[0].length) || 0;\n          var start = match && match.index;\n          if (start + matchLen != line.length && !matchLen) matchLen = 1;\n        }\n        if (match && matchLen)\n          return {from: Pos(pos.line, start),\n                  to: Pos(pos.line, start + matchLen),\n                  match: match};\n      };\n    } else { // String query\n      var origQuery = query;\n      if (caseFold) query = query.toLowerCase();\n      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};\n      var target = query.split(\"\\n\");\n      // Different methods for single-line and multi-line queries\n      if (target.length == 1) {\n        if (!query.length) {\n          // Empty string would match anything and never progress, so\n          // we define it to match nothing instead.\n          this.matches = function() {};\n        } else {\n          this.matches = function(reverse, pos) {\n            if (reverse) {\n              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);\n              var match = line.lastIndexOf(query);\n              if (match > -1) {\n                match = adjustPos(orig, line, match);\n                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n              }\n             } else {\n               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);\n               var match = line.indexOf(query);\n               if (match > -1) {\n                 match = adjustPos(orig, line, match) + pos.ch;\n                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n               }\n            }\n          };\n        }\n      } else {\n        var origTarget = origQuery.split(\"\\n\");\n        this.matches = function(reverse, pos) {\n          var last = target.length - 1;\n          if (reverse) {\n            if (pos.line - (target.length - 1) < doc.firstLine()) return;\n            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;\n            var to = Pos(pos.line, origTarget[last].length);\n            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)\n              if (target[i] != fold(doc.getLine(ln))) return;\n            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;\n            if (fold(line.slice(cut)) != target[0]) return;\n            return {from: Pos(ln, cut), to: to};\n          } else {\n            if (pos.line + (target.length - 1) > doc.lastLine()) return;\n            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;\n            if (fold(line.slice(cut)) != target[0]) return;\n            var from = Pos(pos.line, cut);\n            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)\n              if (target[i] != fold(doc.getLine(ln))) return;\n            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;\n            return {from: from, to: Pos(ln, origTarget[last].length)};\n          }\n        };\n      }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false);},\n    findPrevious: function() {return this.find(true);},\n\n    find: function(reverse) {\n      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n      function savePosAndFail(line) {\n        var pos = Pos(line, 0);\n        self.pos = {from: pos, to: pos};\n        self.atOccurrence = false;\n        return false;\n      }\n\n      for (;;) {\n        if (this.pos = this.matches(reverse, pos)) {\n          this.atOccurrence = true;\n          return this.pos.match || true;\n        }\n        if (reverse) {\n          if (!pos.line) return savePosAndFail(0);\n          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);\n        }\n        else {\n          var maxLine = this.doc.lineCount();\n          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);\n          pos = Pos(pos.line + 1, 0);\n        }\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from;},\n    to: function() {if (this.atOccurrence) return this.pos.to;},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return;\n      var lines = CodeMirror.splitLines(newText);\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n    }\n  };\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos) {\n    if (orig.length == folded.length) return pos;\n    for (var pos1 = Math.min(pos, orig.length);;) {\n      var len1 = orig.slice(0, pos1).toLowerCase().length;\n      if (len1 < pos) ++pos1;\n      else if (len1 > pos) --pos1;\n      else return pos1;\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold);\n  });\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold);\n  });\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = [];\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break;\n      ranges.push({anchor: cur.from(), head: cur.to()});\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0);\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/addon/search/searchcursor.js\n ** module id = 22\n ** module chunks = 0\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\n  function findMatchingBracket(cm, where, strict, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  var currentlyHighlighted = null;\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init)\n      cm.off(\"cursorActivity\", doMatchBrackets);\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, strict, config){\n    return findMatchingBracket(this, pos, strict, config);\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/addon/edit/matchbrackets.js\n ** module id = 23\n ** module chunks = 0\n **/"],"sourceRoot":""}