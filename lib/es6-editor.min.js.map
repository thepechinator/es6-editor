{"version":3,"sources":["webpack:///es6-editor.min.js","webpack:///./src/js/es6-editor.js","webpack:///./src/js/babel/repl.js","webpack:///./~/codemirror/addon/comment/comment.js","webpack:///./~/codemirror/keymap/sublime.js","webpack:///./~/codemirror/addon/search/searchcursor.js","webpack:///./~/codemirror/addon/edit/matchbrackets.js"],"names":["webpackJsonp","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_babelRepl","_babelRepl2","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","CodeMirror","BabelREPL","$context","_this","this","$consoleReporter","find","$output","$toggleFullScreen","editorCompiled","fromTextArea","mode","lineNumbers","matchBrackets","tabSize","readOnly","theme","keyMap","editor","compile","getValue","on","_","debounce","handleCodeChange","bind","click","toggleClass","hasClass","text","refresh","changeObj","setValue","empty","code","transformed","undefined","clear","babel","transform","evaluate","err","message","flush","buffer","join","write","data","push","done","capturingConsole","create","console","error","log","apply","arguments","info","debug","args","Array","slice","call","Function","logs","reduce","String","toString","outerHTML","JSON","stringify","e","myRequire","id","a","b","mod","firstNonWS","str","found","search","nonWS","noOptions","Pos","commands","toggleComment","cm","defineExtension","options","minLine","Infinity","ranges","listSelections","from","to","line","uncomment","lineComment","self","getModeAt","commentString","blockCommentStart","fullLines","blockComment","firstLine","getLine","end","Math","min","ch","lastLine","pad","padding","blankLines","commentBlankLines","operation","indent","baseString","whitespace","cut","test","replaceRange","startString","endString","blockCommentEnd","lastLineHasText","lead","blockCommentLead","didSomething","start","lineString","lines","indexOf","getTokenTypeAt","pos","endPos","startLine","endLine","open","close","lastIndexOf","lastStart","firstEnd","almostLastStart","openEnd","foundEnd","findPosSubword","doc","dir","clipPos","type","state","next","charAt","cat","isWordChar","toUpperCase","moveSubword","extendSelectionsBy","range","display","shift","extend","head","insertLine","above","len","newSelection","last","at","indentLine","anchor","setSelections","wordAt","word","selectBetweenBrackets","getCursor","opening","scanForBracket","closing","mirror","setSelection","sortLines","caseSensitive","selected","toSort","getRange","sort","au","bu","modifyWordOrSelection","indices","replacements","replaceSelections","cmpPos","getTarget","query","findAndGoTo","forward","cur","getSearchCursor","findNext","findPrevious","map","sublime","fallthrough","cmds","mac","macDefault","ctrl","scrollLineCombo","getScrollInfo","somethingSelected","visibleBottomLine","lineAtHeight","top","clientHeight","execCommand","scrollTo","defaultTextHeight","visibleTopLine","lineRanges","scroll","extended","fullWord","sublimeFindFullWord","sel","RegExp","addSelection","Pass","prev","swapLineCombo","linesToMove","newSels","scrollIntoView","joined","offset","actual","exec","rangeCount","marks","sublimeBookmarks","current","unshift","pop","findMarks","j","sublimeBookmark","k","splice","markText","clearWhenEmpty","cK","cursor","toStartOfLine","column","countColumn","getOption","indentUnit","prevIndent","findColumn","toLowerCase","sublimeMark","setBookmark","tmp","sublimeKilled","setCursor","replaceSelection","cursorCoords","bottom","matches","primaryIndex","normalizeKeyMap","SearchCursor","caseFold","atOccurrence","global","source","ignoreCase","reverse","lastIndex","match","cutOff","newMatch","index","matchLen","origQuery","fold","split","orig","adjustPos","origTarget","ln","folded","pos1","len1","savePosAndFail","maxLine","lineCount","replace","newText","origin","splitLines","defineDocExtension","findMatchingBracket","where","strict","config","getLineHandle","matching","style","maxScanLen","maxScanLineLength","maxScanLines","stack","re","bracketRegex","lineEnd","max","lineNo","autoclear","maxHighlightLen","maxHighlightLineLength","className","ie_lt8","focused","focus","setTimeout","doMatchBrackets","currentlyHighlighted","navigator","userAgent","document","documentMode","(",")","[","]","{","}","defineOption","val","old","Init","off"],"mappings":"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","file":"es6-editor.min.js","sourcesContent":["webpackJsonp([0],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _babelRepl = __webpack_require__(1);\n\t\n\tvar _babelRepl2 = _interopRequireDefault(_babelRepl);\n\t\n\tmodule.exports = _babelRepl2['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* jshint evil: true */\n\t\n\t/**\n\t* Code inspired and taken from https://babeljs.io/scripts/repl.js.\n\t*/\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\t__webpack_require__(2);\n\t__webpack_require__(5);\n\t\n\t// A library required to get this library working.\n\t__webpack_require__(7);\n\t\n\t// More 3rd party libraries, but these are actually required to get this class\n\t// working.\n\tvar CodeMirror = __webpack_require__(8);\n\t__webpack_require__(10);\n\t__webpack_require__(11);\n\t\n\t// babel is provided in an external script tag\n\t\n\tvar BabelREPL = (function () {\n\t  function BabelREPL($context) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, BabelREPL);\n\t\n\t    this.$context = $context;\n\t\n\t    this.$consoleReporter = this.$context.find('.js-console');\n\t    this.$output = $context.find('.js-output');\n\t    this.$toggleFullScreen = $context.find('.js-toggle-fs');\n\t\n\t    // Create the CodeMirror editors which give us nice things\n\t    // like line number, key maps, and syntax highlighting.\n\t    this.editorCompiled = CodeMirror.fromTextArea($context.find('.js-demo-compiled')[0], {\n\t      mode: \"javascript\",\n\t      lineNumbers: true,\n\t      matchBrackets: true,\n\t      tabSize: 2,\n\t      readOnly: true,\n\t      theme: 'seti',\n\t      keyMap: 'sublime'\n\t    });\n\t\n\t    this.editor = CodeMirror.fromTextArea($context.find('.js-demo-text')[0], {\n\t      mode: \"javascript\",\n\t      lineNumbers: true,\n\t      matchBrackets: true,\n\t      tabSize: 2,\n\t      theme: 'seti',\n\t      keyMap: 'sublime'\n\t    });\n\t\n\t    // Compile what's already in there.\n\t    this.compile(this.editor.getValue());\n\t\n\t    // Attach to change event so we can recompile each time something\n\t    // changes.\n\t    this.editor.on('change', _.debounce(this.handleCodeChange, 500).bind(this));\n\t\n\t    this.$toggleFullScreen.click(function () {\n\t      $context.toggleClass('is-full');\n\t\n\t      if ($context.hasClass('is-full')) {\n\t        _this.$toggleFullScreen.text('Exit Full Screen');\n\t      } else {\n\t        _this.$toggleFullScreen.text('Full Screen');\n\t      }\n\t\n\t      _this.editor.refresh();\n\t      _this.editorCompiled.refresh();\n\t    });\n\t  }\n\t\n\t  // The following methods are taken from Babel's REPL\n\t  // code, though many of them have been modified to\n\t  // fit our needs.\n\t\n\t  _createClass(BabelREPL, [{\n\t    key: 'refresh',\n\t    value: function refresh() {\n\t      // console.log('refresh');\n\t      this.editor.refresh();\n\t      this.editorCompiled.refresh();\n\t    }\n\t  }, {\n\t    key: 'handleCodeChange',\n\t    value: function handleCodeChange(instance, changeObj) {\n\t      this.compile(instance.getValue());\n\t    }\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      this.editorCompiled.setValue('');\n\t      this.$output.empty();\n\t      this.$consoleReporter.empty();\n\t    }\n\t  }, {\n\t    key: 'compile',\n\t    value: function compile(code) {\n\t      var transformed = undefined;\n\t\n\t      // Clear our output and console each time we recompile.\n\t      this.clear();\n\t\n\t      try {\n\t        // console.log('code', code);\n\t        transformed = babel.transform(code, {});\n\t        //console.log('past transform');\n\t        this.editorCompiled.setValue(transformed.code);\n\t        //console.log('past setValue');\n\t        this.evaluate(transformed.code);\n\t        //console.log('past evaluate');\n\t      } catch (err) {\n\t        // console.log('ERROR thrown', transformed.code);\n\t        // don't throw it.. just output it\n\t        this.$output.text(err.message);\n\t        this.$consoleReporter.text(err.message);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'evaluate',\n\t    value: function evaluate(code) {\n\t      if (typeof this.capturingConsole === 'undefined') {\n\t        // extend console\n\t        this.capturingConsole = Object.create(console);\n\t      }\n\t      var capturingConsole = this.capturingConsole;\n\t\n\t      var $consoleReporter = this.$consoleReporter;\n\t      var buffer = [];\n\t      var error = undefined;\n\t      var done = false;\n\t\n\t      function flush() {\n\t        //console.log('buffer', buffer);\n\t        $consoleReporter.text(buffer.join('\\n'));\n\t      }\n\t\n\t      function write(data) {\n\t        buffer.push(data);\n\t        if (done) {\n\t          flush();\n\t        }\n\t      }\n\t\n\t      capturingConsole.clear = function () {\n\t        buffer = [];\n\t        flush();\n\t      };\n\t\n\t      capturingConsole.error = function () {\n\t        error = true;\n\t        capturingConsole.log.apply(capturingConsole, arguments);\n\t      };\n\t\n\t      capturingConsole.log = capturingConsole.info = capturingConsole.debug = function () {\n\t        if (this !== capturingConsole) {\n\t          return;\n\t        }\n\t\n\t        var args = Array.prototype.slice.call(arguments);\n\t        Function.prototype.apply.call(console.log, console, args);\n\t\n\t        var logs = args.reduce(function (logs, log) {\n\t          console.log('log', log);\n\t          if (typeof log === 'string') {\n\t            // console.log('string');\n\t            logs.push(log);\n\t          } else if (typeof log === 'symbol') {\n\t            logs.push(String(log));\n\t          } else if (log instanceof Function) {\n\t            // console.log('function');\n\t            logs.push(log.toString());\n\t          } else {\n\t            // console.log('log', log);\n\t            // We need to account for DOM elements.\n\t            if (typeof log !== 'undefined' && typeof log.outerHTML !== 'undefined') {\n\t              logs.push(log.outerHTML);\n\t            } else {\n\t              try {\n\t                log = JSON.stringify(log);\n\t              } catch (e) {}\n\t              logs.push(String(log));\n\t            }\n\t          }\n\t\n\t          return logs;\n\t        }, []);\n\t\n\t        // console.log('logs', logs);\n\t        write(logs.join('\\n'));\n\t      };\n\t\n\t      try {\n\t        // So this is actually running the code we obtained\n\t        // and setting the console used as the capturingConsole\n\t        // we created. It's cool because it gives us control\n\t        // over what to replace in our block of our code.\n\t        // (function(console, $$, code) {}(capturingConsole, this.$output));\n\t        new Function('console', '$$', 'require', code)(capturingConsole, this.$output, this.myRequire);\n\t      } catch (err) {\n\t        error = err;\n\t        buffer.push(err.message);\n\t      }\n\t\n\t      done = true;\n\t      flush();\n\t\n\t      if (error) {\n\t        throw error;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'myRequire',\n\t    value: function myRequire(id) {\n\t      return {\n\t        a: function a() {\n\t          return 'i am a';\n\t        },\n\t        b: function b() {\n\t          return 'i am beaver';\n\t        }\n\t      };\n\t    }\n\t  }]);\n\t\n\t  return BabelREPL;\n\t})();\n\t\n\texports['default'] = BabelREPL;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(8));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  var noOptions = {};\n\t  var nonWS = /[^\\s\\u00a0]/;\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  function firstNonWS(str) {\n\t    var found = str.search(nonWS);\n\t    return found == -1 ? 0 : found;\n\t  }\n\t\n\t  CodeMirror.commands.toggleComment = function(cm) {\n\t    cm.toggleComment();\n\t  };\n\t\n\t  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n\t    if (!options) options = noOptions;\n\t    var cm = this;\n\t    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n\t    for (var i = ranges.length - 1; i >= 0; i--) {\n\t      var from = ranges[i].from(), to = ranges[i].to();\n\t      if (from.line >= minLine) continue;\n\t      if (to.line >= minLine) to = Pos(minLine, 0);\n\t      minLine = from.line;\n\t      if (mode == null) {\n\t        if (cm.uncomment(from, to, options)) mode = \"un\";\n\t        else { cm.lineComment(from, to, options); mode = \"line\"; }\n\t      } else if (mode == \"un\") {\n\t        cm.uncomment(from, to, options);\n\t      } else {\n\t        cm.lineComment(from, to, options);\n\t      }\n\t    }\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n\t    if (!options) options = noOptions;\n\t    var self = this, mode = self.getModeAt(from);\n\t    var commentString = options.lineComment || mode.lineComment;\n\t    if (!commentString) {\n\t      if (options.blockCommentStart || mode.blockCommentStart) {\n\t        options.fullLines = true;\n\t        self.blockComment(from, to, options);\n\t      }\n\t      return;\n\t    }\n\t    var firstLine = self.getLine(from.line);\n\t    if (firstLine == null) return;\n\t    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n\t    var pad = options.padding == null ? \" \" : options.padding;\n\t    var blankLines = options.commentBlankLines || from.line == to.line;\n\t\n\t    self.operation(function() {\n\t      if (options.indent) {\n\t        var baseString = null;\n\t        for (var i = from.line; i < end; ++i) {\n\t          var line = self.getLine(i);\n\t          var whitespace = line.slice(0, firstNonWS(line));\n\t          if (baseString == null || baseString.length > whitespace.length) {\n\t            baseString = whitespace;\n\t          }\n\t        }\n\t        for (var i = from.line; i < end; ++i) {\n\t          var line = self.getLine(i), cut = baseString.length;\n\t          if (!blankLines && !nonWS.test(line)) continue;\n\t          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n\t          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n\t        }\n\t      } else {\n\t        for (var i = from.line; i < end; ++i) {\n\t          if (blankLines || nonWS.test(self.getLine(i)))\n\t            self.replaceRange(commentString + pad, Pos(i, 0));\n\t        }\n\t      }\n\t    });\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n\t    if (!options) options = noOptions;\n\t    var self = this, mode = self.getModeAt(from);\n\t    var startString = options.blockCommentStart || mode.blockCommentStart;\n\t    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n\t    if (!startString || !endString) {\n\t      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n\t        self.lineComment(from, to, options);\n\t      return;\n\t    }\n\t\n\t    var end = Math.min(to.line, self.lastLine());\n\t    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\t\n\t    var pad = options.padding == null ? \" \" : options.padding;\n\t    if (from.line > end) return;\n\t\n\t    self.operation(function() {\n\t      if (options.fullLines != false) {\n\t        var lastLineHasText = nonWS.test(self.getLine(end));\n\t        self.replaceRange(pad + endString, Pos(end));\n\t        self.replaceRange(startString + pad, Pos(from.line, 0));\n\t        var lead = options.blockCommentLead || mode.blockCommentLead;\n\t        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n\t          if (i != end || lastLineHasText)\n\t            self.replaceRange(lead + pad, Pos(i, 0));\n\t      } else {\n\t        self.replaceRange(endString, to);\n\t        self.replaceRange(startString, from);\n\t      }\n\t    });\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n\t    if (!options) options = noOptions;\n\t    var self = this, mode = self.getModeAt(from);\n\t    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\t\n\t    // Try finding line comments\n\t    var lineString = options.lineComment || mode.lineComment, lines = [];\n\t    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n\t    lineComment: {\n\t      if (!lineString) break lineComment;\n\t      for (var i = start; i <= end; ++i) {\n\t        var line = self.getLine(i);\n\t        var found = line.indexOf(lineString);\n\t        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n\t        if (found == -1 && (i != end || i == start) && nonWS.test(line)) break lineComment;\n\t        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n\t        lines.push(line);\n\t      }\n\t      self.operation(function() {\n\t        for (var i = start; i <= end; ++i) {\n\t          var line = lines[i - start];\n\t          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n\t          if (pos < 0) continue;\n\t          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n\t          didSomething = true;\n\t          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n\t        }\n\t      });\n\t      if (didSomething) return true;\n\t    }\n\t\n\t    // Try block comments\n\t    var startString = options.blockCommentStart || mode.blockCommentStart;\n\t    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n\t    if (!startString || !endString) return false;\n\t    var lead = options.blockCommentLead || mode.blockCommentLead;\n\t    var startLine = self.getLine(start), endLine = end == start ? startLine : self.getLine(end);\n\t    var open = startLine.indexOf(startString), close = endLine.lastIndexOf(endString);\n\t    if (close == -1 && start != end) {\n\t      endLine = self.getLine(--end);\n\t      close = endLine.lastIndexOf(endString);\n\t    }\n\t    if (open == -1 || close == -1 ||\n\t        !/comment/.test(self.getTokenTypeAt(Pos(start, open + 1))) ||\n\t        !/comment/.test(self.getTokenTypeAt(Pos(end, close + 1))))\n\t      return false;\n\t\n\t    // Avoid killing block comments completely outside the selection.\n\t    // Positions of the last startString before the start of the selection, and the first endString after it.\n\t    var lastStart = startLine.lastIndexOf(startString, from.ch);\n\t    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n\t    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n\t    // Positions of the first endString after the end of the selection, and the last startString before it.\n\t    firstEnd = endLine.indexOf(endString, to.ch);\n\t    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n\t    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n\t    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\t\n\t    self.operation(function() {\n\t      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n\t                        Pos(end, close + endString.length));\n\t      var openEnd = open + startString.length;\n\t      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n\t      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n\t      if (lead) for (var i = start + 1; i <= end; ++i) {\n\t        var line = self.getLine(i), found = line.indexOf(lead);\n\t        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n\t        var foundEnd = found + lead.length;\n\t        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n\t        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n\t      }\n\t    });\n\t    return true;\n\t  });\n\t});\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// A rough approximation of Sublime Text's keybindings\n\t// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(8), __webpack_require__(12), __webpack_require__(13));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t\n\t  var map = CodeMirror.keyMap.sublime = {fallthrough: \"default\"};\n\t  var cmds = CodeMirror.commands;\n\t  var Pos = CodeMirror.Pos;\n\t  var mac = CodeMirror.keyMap[\"default\"] == CodeMirror.keyMap.macDefault;\n\t  var ctrl = mac ? \"Cmd-\" : \"Ctrl-\";\n\t\n\t  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n\t  function findPosSubword(doc, start, dir) {\n\t    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n\t    var line = doc.getLine(start.line);\n\t    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n\t    var state = \"start\", type;\n\t    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n\t      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n\t      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n\t      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n\t      if (state == \"start\") {\n\t        if (cat != \"o\") { state = \"in\"; type = cat; }\n\t      } else if (state == \"in\") {\n\t        if (type != cat) {\n\t          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n\t          if (type == \"W\" && cat == \"w\" && dir > 0) { type = \"w\"; continue; }\n\t          break;\n\t        }\n\t      }\n\t    }\n\t    return Pos(start.line, pos);\n\t  }\n\t\n\t  function moveSubword(cm, dir) {\n\t    cm.extendSelectionsBy(function(range) {\n\t      if (cm.display.shift || cm.doc.extend || range.empty())\n\t        return findPosSubword(cm.doc, range.head, dir);\n\t      else\n\t        return dir < 0 ? range.from() : range.to();\n\t    });\n\t  }\n\t\n\t  cmds[map[\"Alt-Left\"] = \"goSubwordLeft\"] = function(cm) { moveSubword(cm, -1); };\n\t  cmds[map[\"Alt-Right\"] = \"goSubwordRight\"] = function(cm) { moveSubword(cm, 1); };\n\t\n\t  var scrollLineCombo = mac ? \"Ctrl-Alt-\" : \"Ctrl-\";\n\t\n\t  cmds[map[scrollLineCombo + \"Up\"] = \"scrollLineUp\"] = function(cm) {\n\t    var info = cm.getScrollInfo();\n\t    if (!cm.somethingSelected()) {\n\t      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n\t      if (cm.getCursor().line >= visibleBottomLine)\n\t        cm.execCommand(\"goLineUp\");\n\t    }\n\t    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n\t  };\n\t  cmds[map[scrollLineCombo + \"Down\"] = \"scrollLineDown\"] = function(cm) {\n\t    var info = cm.getScrollInfo();\n\t    if (!cm.somethingSelected()) {\n\t      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n\t      if (cm.getCursor().line <= visibleTopLine)\n\t        cm.execCommand(\"goLineDown\");\n\t    }\n\t    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n\t  };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"L\"] = \"splitSelectionByLine\"] = function(cm) {\n\t    var ranges = cm.listSelections(), lineRanges = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var from = ranges[i].from(), to = ranges[i].to();\n\t      for (var line = from.line; line <= to.line; ++line)\n\t        if (!(to.line > from.line && line == to.line && to.ch == 0))\n\t          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n\t                           head: line == to.line ? to : Pos(line)});\n\t    }\n\t    cm.setSelections(lineRanges, 0);\n\t  };\n\t\n\t  map[\"Shift-Tab\"] = \"indentLess\";\n\t\n\t  cmds[map[\"Esc\"] = \"singleSelectionTop\"] = function(cm) {\n\t    var range = cm.listSelections()[0];\n\t    cm.setSelection(range.anchor, range.head, {scroll: false});\n\t  };\n\t\n\t  cmds[map[ctrl + \"L\"] = \"selectLine\"] = function(cm) {\n\t    var ranges = cm.listSelections(), extended = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i];\n\t      extended.push({anchor: Pos(range.from().line, 0),\n\t                     head: Pos(range.to().line + 1, 0)});\n\t    }\n\t    cm.setSelections(extended);\n\t  };\n\t\n\t  map[\"Shift-\" + ctrl + \"K\"] = \"deleteLine\";\n\t\n\t  function insertLine(cm, above) {\n\t    cm.operation(function() {\n\t      var len = cm.listSelections().length, newSelection = [], last = -1;\n\t      for (var i = 0; i < len; i++) {\n\t        var head = cm.listSelections()[i].head;\n\t        if (head.line <= last) continue;\n\t        var at = Pos(head.line + (above ? 0 : 1), 0);\n\t        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n\t        cm.indentLine(at.line, null, true);\n\t        newSelection.push({head: at, anchor: at});\n\t        last = head.line + 1;\n\t      }\n\t      cm.setSelections(newSelection);\n\t    });\n\t  }\n\t\n\t  cmds[map[ctrl + \"Enter\"] = \"insertLineAfter\"] = function(cm) { insertLine(cm, false); };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"Enter\"] = \"insertLineBefore\"] = function(cm) { insertLine(cm, true); };\n\t\n\t  function wordAt(cm, pos) {\n\t    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n\t    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n\t    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n\t    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n\t  }\n\t\n\t  cmds[map[ctrl + \"D\"] = \"selectNextOccurrence\"] = function(cm) {\n\t    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n\t    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n\t    if (CodeMirror.cmpPos(from, to) == 0) {\n\t      var word = wordAt(cm, from);\n\t      if (!word.word) return;\n\t      cm.setSelection(word.from, word.to);\n\t      fullWord = true;\n\t    } else {\n\t      var text = cm.getRange(from, to);\n\t      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n\t      var cur = cm.getSearchCursor(query, to);\n\t      if (cur.findNext()) {\n\t        cm.addSelection(cur.from(), cur.to());\n\t      } else {\n\t        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n\t        if (cur.findNext())\n\t          cm.addSelection(cur.from(), cur.to());\n\t      }\n\t    }\n\t    if (fullWord)\n\t      cm.state.sublimeFindFullWord = cm.doc.sel;\n\t  };\n\t\n\t  var mirror = \"(){}[]\";\n\t  function selectBetweenBrackets(cm) {\n\t    var pos = cm.getCursor(), opening = cm.scanForBracket(pos, -1);\n\t    if (!opening) return;\n\t    for (;;) {\n\t      var closing = cm.scanForBracket(pos, 1);\n\t      if (!closing) return;\n\t      if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n\t        cm.setSelection(Pos(opening.pos.line, opening.pos.ch + 1), closing.pos, false);\n\t        return true;\n\t      }\n\t      pos = Pos(closing.pos.line, closing.pos.ch + 1);\n\t    }\n\t  }\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"Space\"] = \"selectScope\"] = function(cm) {\n\t    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n\t  };\n\t  cmds[map[\"Shift-\" + ctrl + \"M\"] = \"selectBetweenBrackets\"] = function(cm) {\n\t    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n\t  };\n\t\n\t  cmds[map[ctrl + \"M\"] = \"goToBracket\"] = function(cm) {\n\t    cm.extendSelectionsBy(function(range) {\n\t      var next = cm.scanForBracket(range.head, 1);\n\t      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n\t      var prev = cm.scanForBracket(range.head, -1);\n\t      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n\t    });\n\t  };\n\t\n\t  var swapLineCombo = mac ? \"Cmd-Ctrl-\" : \"Shift-Ctrl-\";\n\t\n\t  cmds[map[swapLineCombo + \"Up\"] = \"swapLineUp\"] = function(cm) {\n\t    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n\t      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n\t                    head: Pos(range.head.line - 1, range.head.ch)});\n\t      if (range.to().ch == 0 && !range.empty()) --to;\n\t      if (from > at) linesToMove.push(from, to);\n\t      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n\t      at = to;\n\t    }\n\t    cm.operation(function() {\n\t      for (var i = 0; i < linesToMove.length; i += 2) {\n\t        var from = linesToMove[i], to = linesToMove[i + 1];\n\t        var line = cm.getLine(from);\n\t        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n\t        if (to > cm.lastLine())\n\t          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n\t        else\n\t          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n\t      }\n\t      cm.setSelections(newSels);\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  cmds[map[swapLineCombo + \"Down\"] = \"swapLineDown\"] = function(cm) {\n\t    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n\t    for (var i = ranges.length - 1; i >= 0; i--) {\n\t      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n\t      if (range.to().ch == 0 && !range.empty()) from--;\n\t      if (from < at) linesToMove.push(from, to);\n\t      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n\t      at = to;\n\t    }\n\t    cm.operation(function() {\n\t      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n\t        var from = linesToMove[i], to = linesToMove[i + 1];\n\t        var line = cm.getLine(from);\n\t        if (from == cm.lastLine())\n\t          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n\t        else\n\t          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n\t        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n\t      }\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  map[ctrl + \"/\"] = function(cm) {\n\t    cm.toggleComment({ indent: true });\n\t  }\n\t\n\t  cmds[map[ctrl + \"J\"] = \"joinLines\"] = function(cm) {\n\t    var ranges = cm.listSelections(), joined = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i], from = range.from();\n\t      var start = from.line, end = range.to().line;\n\t      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n\t        end = ranges[++i].to().line;\n\t      joined.push({start: start, end: end, anchor: !range.empty() && from});\n\t    }\n\t    cm.operation(function() {\n\t      var offset = 0, ranges = [];\n\t      for (var i = 0; i < joined.length; i++) {\n\t        var obj = joined[i];\n\t        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n\t        for (var line = obj.start; line <= obj.end; line++) {\n\t          var actual = line - offset;\n\t          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n\t          if (actual < cm.lastLine()) {\n\t            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n\t            ++offset;\n\t          }\n\t        }\n\t        ranges.push({anchor: anchor || head, head: head});\n\t      }\n\t      cm.setSelections(ranges, 0);\n\t    });\n\t  };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"D\"] = \"duplicateLine\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var rangeCount = cm.listSelections().length;\n\t      for (var i = 0; i < rangeCount; i++) {\n\t        var range = cm.listSelections()[i];\n\t        if (range.empty())\n\t          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n\t        else\n\t          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n\t      }\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  map[ctrl + \"T\"] = \"transposeChars\";\n\t\n\t  function sortLines(cm, caseSensitive) {\n\t    var ranges = cm.listSelections(), toSort = [], selected;\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var range = ranges[i];\n\t      if (range.empty()) continue;\n\t      var from = range.from().line, to = range.to().line;\n\t      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n\t        to = range[++i].to().line;\n\t      toSort.push(from, to);\n\t    }\n\t    if (toSort.length) selected = true;\n\t    else toSort.push(cm.firstLine(), cm.lastLine());\n\t\n\t    cm.operation(function() {\n\t      var ranges = [];\n\t      for (var i = 0; i < toSort.length; i += 2) {\n\t        var from = toSort[i], to = toSort[i + 1];\n\t        var start = Pos(from, 0), end = Pos(to);\n\t        var lines = cm.getRange(start, end, false);\n\t        if (caseSensitive)\n\t          lines.sort();\n\t        else\n\t          lines.sort(function(a, b) {\n\t            var au = a.toUpperCase(), bu = b.toUpperCase();\n\t            if (au != bu) { a = au; b = bu; }\n\t            return a < b ? -1 : a == b ? 0 : 1;\n\t          });\n\t        cm.replaceRange(lines, start, end);\n\t        if (selected) ranges.push({anchor: start, head: end});\n\t      }\n\t      if (selected) cm.setSelections(ranges, 0);\n\t    });\n\t  }\n\t\n\t  cmds[map[\"F9\"] = \"sortLines\"] = function(cm) { sortLines(cm, true); };\n\t  cmds[map[ctrl + \"F9\"] = \"sortLinesInsensitive\"] = function(cm) { sortLines(cm, false); };\n\t\n\t  cmds[map[\"F2\"] = \"nextBookmark\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks;\n\t    if (marks) while (marks.length) {\n\t      var current = marks.shift();\n\t      var found = current.find();\n\t      if (found) {\n\t        marks.push(current);\n\t        return cm.setSelection(found.from, found.to);\n\t      }\n\t    }\n\t  };\n\t\n\t  cmds[map[\"Shift-F2\"] = \"prevBookmark\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks;\n\t    if (marks) while (marks.length) {\n\t      marks.unshift(marks.pop());\n\t      var found = marks[marks.length - 1].find();\n\t      if (!found)\n\t        marks.pop();\n\t      else\n\t        return cm.setSelection(found.from, found.to);\n\t    }\n\t  };\n\t\n\t  cmds[map[ctrl + \"F2\"] = \"toggleBookmark\"] = function(cm) {\n\t    var ranges = cm.listSelections();\n\t    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var from = ranges[i].from(), to = ranges[i].to();\n\t      var found = cm.findMarks(from, to);\n\t      for (var j = 0; j < found.length; j++) {\n\t        if (found[j].sublimeBookmark) {\n\t          found[j].clear();\n\t          for (var k = 0; k < marks.length; k++)\n\t            if (marks[k] == found[j])\n\t              marks.splice(k--, 1);\n\t          break;\n\t        }\n\t      }\n\t      if (j == found.length)\n\t        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n\t    }\n\t  };\n\t\n\t  cmds[map[\"Shift-\" + ctrl + \"F2\"] = \"clearBookmarks\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks;\n\t    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n\t    marks.length = 0;\n\t  };\n\t\n\t  cmds[map[\"Alt-F2\"] = \"selectBookmarks\"] = function(cm) {\n\t    var marks = cm.state.sublimeBookmarks, ranges = [];\n\t    if (marks) for (var i = 0; i < marks.length; i++) {\n\t      var found = marks[i].find();\n\t      if (!found)\n\t        marks.splice(i--, 0);\n\t      else\n\t        ranges.push({anchor: found.from, head: found.to});\n\t    }\n\t    if (ranges.length)\n\t      cm.setSelections(ranges, 0);\n\t  };\n\t\n\t  map[\"Alt-Q\"] = \"wrapLines\";\n\t\n\t  var cK = ctrl + \"K \";\n\t\n\t  function modifyWordOrSelection(cm, mod) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections(), indices = [], replacements = [];\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n\t        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n\t      }\n\t      cm.replaceSelections(replacements, \"around\", \"case\");\n\t      for (var i = indices.length - 1, at; i >= 0; i--) {\n\t        var range = ranges[indices[i]];\n\t        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n\t        var word = wordAt(cm, range.head);\n\t        at = word.from;\n\t        cm.replaceRange(mod(word.word), word.from, word.to);\n\t      }\n\t    });\n\t  }\n\t\n\t  map[cK + ctrl + \"Backspace\"] = \"delLineLeft\";\n\t\n\t  cmds[map[\"Backspace\"] = \"smartBackspace\"] = function(cm) {\n\t    if (cm.somethingSelected()) return CodeMirror.Pass;\n\t\n\t    var cursor = cm.getCursor();\n\t    var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n\t    var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\t    var indentUnit = cm.getOption(\"indentUnit\");\n\t\n\t    if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n\t      var prevIndent = new Pos(cursor.line,\n\t        CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\t\n\t      // If no smart delete is happening (due to tab sizing) just do a regular delete\n\t      if (prevIndent.ch == cursor.ch) return CodeMirror.Pass;\n\t\n\t      return cm.replaceRange(\"\", prevIndent, cursor, \"+delete\");\n\t    } else {\n\t      return CodeMirror.Pass;\n\t    }\n\t  };\n\t\n\t  cmds[map[cK + ctrl + \"K\"] = \"delLineRight\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections();\n\t      for (var i = ranges.length - 1; i >= 0; i--)\n\t        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n\t      cm.scrollIntoView();\n\t    });\n\t  };\n\t\n\t  cmds[map[cK + ctrl + \"U\"] = \"upcaseAtCursor\"] = function(cm) {\n\t    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n\t  };\n\t  cmds[map[cK + ctrl + \"L\"] = \"downcaseAtCursor\"] = function(cm) {\n\t    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n\t  };\n\t\n\t  cmds[map[cK + ctrl + \"Space\"] = \"setSublimeMark\"] = function(cm) {\n\t    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n\t    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n\t  };\n\t  cmds[map[cK + ctrl + \"A\"] = \"selectToSublimeMark\"] = function(cm) {\n\t    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n\t    if (found) cm.setSelection(cm.getCursor(), found);\n\t  };\n\t  cmds[map[cK + ctrl + \"W\"] = \"deleteToSublimeMark\"] = function(cm) {\n\t    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n\t    if (found) {\n\t      var from = cm.getCursor(), to = found;\n\t      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n\t      cm.state.sublimeKilled = cm.getRange(from, to);\n\t      cm.replaceRange(\"\", from, to);\n\t    }\n\t  };\n\t  cmds[map[cK + ctrl + \"X\"] = \"swapWithSublimeMark\"] = function(cm) {\n\t    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n\t    if (found) {\n\t      cm.state.sublimeMark.clear();\n\t      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n\t      cm.setCursor(found);\n\t    }\n\t  };\n\t  cmds[map[cK + ctrl + \"Y\"] = \"sublimeYank\"] = function(cm) {\n\t    if (cm.state.sublimeKilled != null)\n\t      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n\t  };\n\t\n\t  map[cK + ctrl + \"G\"] = \"clearBookmarks\";\n\t  cmds[map[cK + ctrl + \"C\"] = \"showInCenter\"] = function(cm) {\n\t    var pos = cm.cursorCoords(null, \"local\");\n\t    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n\t  };\n\t\n\t  cmds[map[\"Shift-Alt-Up\"] = \"selectLinesUpward\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections();\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (range.head.line > cm.firstLine())\n\t          cm.addSelection(Pos(range.head.line - 1, range.head.ch));\n\t      }\n\t    });\n\t  };\n\t  cmds[map[\"Shift-Alt-Down\"] = \"selectLinesDownward\"] = function(cm) {\n\t    cm.operation(function() {\n\t      var ranges = cm.listSelections();\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (range.head.line < cm.lastLine())\n\t          cm.addSelection(Pos(range.head.line + 1, range.head.ch));\n\t      }\n\t    });\n\t  };\n\t\n\t  function getTarget(cm) {\n\t    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n\t    if (CodeMirror.cmpPos(from, to) == 0) {\n\t      var word = wordAt(cm, from);\n\t      if (!word.word) return;\n\t      from = word.from;\n\t      to = word.to;\n\t    }\n\t    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n\t  }\n\t\n\t  function findAndGoTo(cm, forward) {\n\t    var target = getTarget(cm);\n\t    if (!target) return;\n\t    var query = target.query;\n\t    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\t\n\t    if (forward ? cur.findNext() : cur.findPrevious()) {\n\t      cm.setSelection(cur.from(), cur.to());\n\t    } else {\n\t      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n\t                                              : cm.clipPos(Pos(cm.lastLine())));\n\t      if (forward ? cur.findNext() : cur.findPrevious())\n\t        cm.setSelection(cur.from(), cur.to());\n\t      else if (target.word)\n\t        cm.setSelection(target.from, target.to);\n\t    }\n\t  };\n\t  cmds[map[ctrl + \"F3\"] = \"findUnder\"] = function(cm) { findAndGoTo(cm, true); };\n\t  cmds[map[\"Shift-\" + ctrl + \"F3\"] = \"findUnderPrevious\"] = function(cm) { findAndGoTo(cm,false); };\n\t  cmds[map[\"Alt-F3\"] = \"findAllUnder\"] = function(cm) {\n\t    var target = getTarget(cm);\n\t    if (!target) return;\n\t    var cur = cm.getSearchCursor(target.query);\n\t    var matches = [];\n\t    var primaryIndex = -1;\n\t    while (cur.findNext()) {\n\t      matches.push({anchor: cur.from(), head: cur.to()});\n\t      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n\t        primaryIndex++;\n\t    }\n\t    cm.setSelections(matches, primaryIndex);\n\t  };\n\t\n\t  map[\"Shift-\" + ctrl + \"[\"] = \"fold\";\n\t  map[\"Shift-\" + ctrl + \"]\"] = \"unfold\";\n\t  map[cK + ctrl + \"0\"] = map[cK + ctrl + \"j\"] = \"unfoldAll\";\n\t\n\t  map[ctrl + \"I\"] = \"findIncremental\";\n\t  map[\"Shift-\" + ctrl + \"I\"] = \"findIncrementalReverse\";\n\t  map[ctrl + \"H\"] = \"replace\";\n\t  map[\"F3\"] = \"findNext\";\n\t  map[\"Shift-F3\"] = \"findPrev\";\n\t\n\t  CodeMirror.normalizeKeyMap(map);\n\t});\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(8));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  \"use strict\";\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  function SearchCursor(doc, query, pos, caseFold) {\n\t    this.atOccurrence = false; this.doc = doc;\n\t    if (caseFold == null && typeof query == \"string\") caseFold = false;\n\t\n\t    pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n\t    this.pos = {from: pos, to: pos};\n\t\n\t    // The matches method is filled in based on the type of query.\n\t    // It takes a position and a direction, and returns an object\n\t    // describing the next occurrence of the query, or null if no\n\t    // more matches were found.\n\t    if (typeof query != \"string\") { // Regexp match\n\t      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? \"ig\" : \"g\");\n\t      this.matches = function(reverse, pos) {\n\t        if (reverse) {\n\t          query.lastIndex = 0;\n\t          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;\n\t          for (;;) {\n\t            query.lastIndex = cutOff;\n\t            var newMatch = query.exec(line);\n\t            if (!newMatch) break;\n\t            match = newMatch;\n\t            start = match.index;\n\t            cutOff = match.index + (match[0].length || 1);\n\t            if (cutOff == line.length) break;\n\t          }\n\t          var matchLen = (match && match[0].length) || 0;\n\t          if (!matchLen) {\n\t            if (start == 0 && line.length == 0) {match = undefined;}\n\t            else if (start != doc.getLine(pos.line).length) {\n\t              matchLen++;\n\t            }\n\t          }\n\t        } else {\n\t          query.lastIndex = pos.ch;\n\t          var line = doc.getLine(pos.line), match = query.exec(line);\n\t          var matchLen = (match && match[0].length) || 0;\n\t          var start = match && match.index;\n\t          if (start + matchLen != line.length && !matchLen) matchLen = 1;\n\t        }\n\t        if (match && matchLen)\n\t          return {from: Pos(pos.line, start),\n\t                  to: Pos(pos.line, start + matchLen),\n\t                  match: match};\n\t      };\n\t    } else { // String query\n\t      var origQuery = query;\n\t      if (caseFold) query = query.toLowerCase();\n\t      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};\n\t      var target = query.split(\"\\n\");\n\t      // Different methods for single-line and multi-line queries\n\t      if (target.length == 1) {\n\t        if (!query.length) {\n\t          // Empty string would match anything and never progress, so\n\t          // we define it to match nothing instead.\n\t          this.matches = function() {};\n\t        } else {\n\t          this.matches = function(reverse, pos) {\n\t            if (reverse) {\n\t              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);\n\t              var match = line.lastIndexOf(query);\n\t              if (match > -1) {\n\t                match = adjustPos(orig, line, match);\n\t                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n\t              }\n\t             } else {\n\t               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);\n\t               var match = line.indexOf(query);\n\t               if (match > -1) {\n\t                 match = adjustPos(orig, line, match) + pos.ch;\n\t                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n\t               }\n\t            }\n\t          };\n\t        }\n\t      } else {\n\t        var origTarget = origQuery.split(\"\\n\");\n\t        this.matches = function(reverse, pos) {\n\t          var last = target.length - 1;\n\t          if (reverse) {\n\t            if (pos.line - (target.length - 1) < doc.firstLine()) return;\n\t            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;\n\t            var to = Pos(pos.line, origTarget[last].length);\n\t            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)\n\t              if (target[i] != fold(doc.getLine(ln))) return;\n\t            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;\n\t            if (fold(line.slice(cut)) != target[0]) return;\n\t            return {from: Pos(ln, cut), to: to};\n\t          } else {\n\t            if (pos.line + (target.length - 1) > doc.lastLine()) return;\n\t            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;\n\t            if (fold(line.slice(cut)) != target[0]) return;\n\t            var from = Pos(pos.line, cut);\n\t            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)\n\t              if (target[i] != fold(doc.getLine(ln))) return;\n\t            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;\n\t            return {from: from, to: Pos(ln, origTarget[last].length)};\n\t          }\n\t        };\n\t      }\n\t    }\n\t  }\n\t\n\t  SearchCursor.prototype = {\n\t    findNext: function() {return this.find(false);},\n\t    findPrevious: function() {return this.find(true);},\n\t\n\t    find: function(reverse) {\n\t      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n\t      function savePosAndFail(line) {\n\t        var pos = Pos(line, 0);\n\t        self.pos = {from: pos, to: pos};\n\t        self.atOccurrence = false;\n\t        return false;\n\t      }\n\t\n\t      for (;;) {\n\t        if (this.pos = this.matches(reverse, pos)) {\n\t          this.atOccurrence = true;\n\t          return this.pos.match || true;\n\t        }\n\t        if (reverse) {\n\t          if (!pos.line) return savePosAndFail(0);\n\t          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);\n\t        }\n\t        else {\n\t          var maxLine = this.doc.lineCount();\n\t          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);\n\t          pos = Pos(pos.line + 1, 0);\n\t        }\n\t      }\n\t    },\n\t\n\t    from: function() {if (this.atOccurrence) return this.pos.from;},\n\t    to: function() {if (this.atOccurrence) return this.pos.to;},\n\t\n\t    replace: function(newText, origin) {\n\t      if (!this.atOccurrence) return;\n\t      var lines = CodeMirror.splitLines(newText);\n\t      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n\t      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n\t                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n\t    }\n\t  };\n\t\n\t  // Maps a position in a case-folded line back to a position in the original line\n\t  // (compensating for codepoints increasing in number during folding)\n\t  function adjustPos(orig, folded, pos) {\n\t    if (orig.length == folded.length) return pos;\n\t    for (var pos1 = Math.min(pos, orig.length);;) {\n\t      var len1 = orig.slice(0, pos1).toLowerCase().length;\n\t      if (len1 < pos) ++pos1;\n\t      else if (len1 > pos) --pos1;\n\t      else return pos1;\n\t    }\n\t  }\n\t\n\t  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n\t    return new SearchCursor(this.doc, query, pos, caseFold);\n\t  });\n\t  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n\t    return new SearchCursor(this, query, pos, caseFold);\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n\t    var ranges = [];\n\t    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n\t    while (cur.findNext()) {\n\t      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break;\n\t      ranges.push({anchor: cur.from(), head: cur.to()});\n\t    }\n\t    if (ranges.length)\n\t      this.setSelections(ranges, 0);\n\t  });\n\t});\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    mod(__webpack_require__(8));\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    define([\"../../lib/codemirror\"], mod);\n\t  else // Plain browser env\n\t    mod(CodeMirror);\n\t})(function(CodeMirror) {\n\t  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n\t    (document.documentMode == null || document.documentMode < 8);\n\t\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\t\n\t  function findMatchingBracket(cm, where, strict, config) {\n\t    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n\t    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n\t    if (!match) return null;\n\t    var dir = match.charAt(1) == \">\" ? 1 : -1;\n\t    if (strict && (dir > 0) != (pos == where.ch)) return null;\n\t    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\t\n\t    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n\t    if (found == null) return null;\n\t    return {from: Pos(where.line, pos), to: found && found.pos,\n\t            match: found && found.ch == match.charAt(0), forward: dir > 0};\n\t  }\n\t\n\t  // bracketRegex is used to specify which type of bracket to scan\n\t  // should be a regexp, e.g. /[[\\]]/\n\t  //\n\t  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n\t  //\n\t  // Returns false when no bracket was found, null when it reached\n\t  // maxScanLines and gave up\n\t  function scanForBracket(cm, where, dir, style, config) {\n\t    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n\t    var maxScanLines = (config && config.maxScanLines) || 1000;\n\t\n\t    var stack = [];\n\t    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n\t    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n\t                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n\t    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n\t      var line = cm.getLine(lineNo);\n\t      if (!line) continue;\n\t      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n\t      if (line.length > maxScanLen) continue;\n\t      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n\t      for (; pos != end; pos += dir) {\n\t        var ch = line.charAt(pos);\n\t        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n\t          var match = matching[ch];\n\t          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n\t          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n\t          else stack.pop();\n\t        }\n\t      }\n\t    }\n\t    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n\t  }\n\t\n\t  function matchBrackets(cm, autoclear, config) {\n\t    // Disable brace matching in long lines, since it'll cause hugely slow updates\n\t    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n\t    var marks = [], ranges = cm.listSelections();\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);\n\t      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n\t        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n\t        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n\t        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n\t          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n\t      }\n\t    }\n\t\n\t    if (marks.length) {\n\t      // Kludge to work around the IE bug from issue #1193, where text\n\t      // input stops going to the textare whever this fires.\n\t      if (ie_lt8 && cm.state.focused) cm.focus();\n\t\n\t      var clear = function() {\n\t        cm.operation(function() {\n\t          for (var i = 0; i < marks.length; i++) marks[i].clear();\n\t        });\n\t      };\n\t      if (autoclear) setTimeout(clear, 800);\n\t      else return clear;\n\t    }\n\t  }\n\t\n\t  var currentlyHighlighted = null;\n\t  function doMatchBrackets(cm) {\n\t    cm.operation(function() {\n\t      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n\t      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n\t    });\n\t  }\n\t\n\t  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n\t    if (old && old != CodeMirror.Init)\n\t      cm.off(\"cursorActivity\", doMatchBrackets);\n\t    if (val) {\n\t      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n\t      cm.on(\"cursorActivity\", doMatchBrackets);\n\t    }\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n\t  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, strict, config){\n\t    return findMatchingBracket(this, pos, strict, config);\n\t  });\n\t  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n\t    return scanForBracket(this, pos, dir, style, config);\n\t  });\n\t});\n\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** es6-editor.min.js\n **/","import BabelREPL from 'babel/repl';\n\nmodule.exports = BabelREPL;\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/es6-editor.js\n **/","/* jshint evil: true */\n\n/**\n* Code inspired and taken from https://babeljs.io/scripts/repl.js.\n*/\n\nrequire('script!babel-polyfill/dist/polyfill.js');\nrequire('script!babel-core/browser.js');\n\n// A library required to get this library working.\nrequire('underscore');\n\n// More 3rd party libraries, but these are actually required to get this class\n// working.\nvar CodeMirror = require('codemirror/lib/codemirror');\nrequire('codemirror/addon/comment/comment');\nrequire('codemirror/keymap/sublime');\n\n// babel is provided in an external script tag\nexport default class BabelREPL {\n  constructor($context) {\n    this.$context = $context;\n\n    this.$consoleReporter = this.$context.find('.js-console');\n    this.$output = $context.find('.js-output');\n    this.$toggleFullScreen = $context.find('.js-toggle-fs');\n\n    // Create the CodeMirror editors which give us nice things\n    // like line number, key maps, and syntax highlighting.\n    this.editorCompiled = CodeMirror.fromTextArea($context.find('.js-demo-compiled')[0], {\n      mode: \"javascript\",\n      lineNumbers: true,\n      matchBrackets: true,\n      tabSize: 2,\n      readOnly: true,\n      theme: 'seti',\n      keyMap: 'sublime'\n    });\n\n    this.editor = CodeMirror.fromTextArea($context.find('.js-demo-text')[0], {\n      mode: \"javascript\",\n      lineNumbers: true,\n      matchBrackets: true,\n      tabSize: 2,\n      theme: 'seti',\n      keyMap: 'sublime'\n    });\n\n    // Compile what's already in there.\n    this.compile(this.editor.getValue());\n\n    // Attach to change event so we can recompile each time something\n    // changes.\n    this.editor.on('change', _.debounce(this.handleCodeChange, 500).bind(this));\n\n    this.$toggleFullScreen.click(() => {\n      $context.toggleClass('is-full');\n\n      if ($context.hasClass('is-full')) {\n        this.$toggleFullScreen.text('Exit Full Screen');\n      } else {\n        this.$toggleFullScreen.text('Full Screen');\n      }\n\n      this.editor.refresh();\n      this.editorCompiled.refresh();\n    });\n  }\n\n  // The following methods are taken from Babel's REPL\n  // code, though many of them have been modified to\n  // fit our needs.\n  refresh() {\n    // console.log('refresh');\n    this.editor.refresh();\n    this.editorCompiled.refresh();\n  }\n\n  handleCodeChange(instance, changeObj) {\n    this.compile(instance.getValue());\n  }\n\n  clear() {\n    this.editorCompiled.setValue('');\n    this.$output.empty();\n    this.$consoleReporter.empty();\n  }\n\n  compile(code) {\n    let transformed;\n\n    // Clear our output and console each time we recompile.\n    this.clear();\n\n    try {\n      // console.log('code', code);\n      transformed = babel.transform(code, {});\n      //console.log('past transform');\n      this.editorCompiled.setValue(transformed.code);\n      //console.log('past setValue');\n      this.evaluate(transformed.code);\n      //console.log('past evaluate');\n    } catch (err) {\n      // console.log('ERROR thrown', transformed.code);\n      // don't throw it.. just output it\n      this.$output.text(err.message);\n      this.$consoleReporter.text(err.message);\n    }\n  }\n\n  evaluate(code) {\n    if (typeof this.capturingConsole === 'undefined') {\n      // extend console\n      this.capturingConsole = Object.create(console);\n    }\n    let capturingConsole = this.capturingConsole;\n\n    let $consoleReporter = this.$consoleReporter;\n    let buffer = [];\n    let error;\n    let done = false;\n\n    function flush() {\n      //console.log('buffer', buffer);\n      $consoleReporter.text(buffer.join('\\n'));\n    }\n\n    function write(data) {\n      buffer.push(data);\n      if (done) {\n        flush();\n      }\n    }\n\n    capturingConsole.clear = function() {\n      buffer = [];\n      flush();\n    };\n\n    capturingConsole.error = function() {\n      error = true;\n      capturingConsole.log.apply(capturingConsole, arguments);\n    };\n\n    capturingConsole.log =\n    capturingConsole.info =\n    capturingConsole.debug = function() {\n      if (this !== capturingConsole) { return; }\n\n      let args = Array.prototype.slice.call(arguments);\n      Function.prototype.apply.call(console.log, console, args);\n\n      let logs = args.reduce(function(logs, log) {\n        console.log('log', log);\n        if (typeof log === 'string') {\n          // console.log('string');\n          logs.push(log);\n        } else if (typeof log === 'symbol') {\n          logs.push(String(log));\n        } else if (log instanceof Function) {\n          // console.log('function');\n          logs.push(log.toString());\n        } else {\n          // console.log('log', log);\n          // We need to account for DOM elements.\n          if (typeof log !== 'undefined' &&\n            typeof log.outerHTML !== 'undefined') {\n            logs.push(log.outerHTML);\n          } else {\n            try {\n              log = JSON.stringify(log);\n            } catch(e) {\n\n            }\n            logs.push(String(log));\n          }\n        }\n\n        return logs;\n      }, []);\n\n      // console.log('logs', logs);\n      write(logs.join('\\n'));\n    };\n\n    try {\n      // So this is actually running the code we obtained\n      // and setting the console used as the capturingConsole\n      // we created. It's cool because it gives us control\n      // over what to replace in our block of our code.\n      // (function(console, $$, code) {}(capturingConsole, this.$output));\n      new Function('console', '$$', 'require', code)(capturingConsole, this.$output, this.myRequire);\n    } catch (err) {\n      error = err;\n      buffer.push(err.message);\n    }\n\n    done = true;\n    flush();\n\n    if (error) {\n      throw error;\n    }\n  }\n\n  myRequire(id) {\n    return {\n      a: function() {\n        return 'i am a';\n      },\n      b: function() {\n        return 'i am beaver';\n      }\n    };\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/babel/repl.js\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var noOptions = {};\n  var nonWS = /[^\\s\\u00a0]/;\n  var Pos = CodeMirror.Pos;\n\n  function firstNonWS(str) {\n    var found = str.search(nonWS);\n    return found == -1 ? 0 : found;\n  }\n\n  CodeMirror.commands.toggleComment = function(cm) {\n    cm.toggleComment();\n  };\n\n  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n    if (!options) options = noOptions;\n    var cm = this;\n    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      if (from.line >= minLine) continue;\n      if (to.line >= minLine) to = Pos(minLine, 0);\n      minLine = from.line;\n      if (mode == null) {\n        if (cm.uncomment(from, to, options)) mode = \"un\";\n        else { cm.lineComment(from, to, options); mode = \"line\"; }\n      } else if (mode == \"un\") {\n        cm.uncomment(from, to, options);\n      } else {\n        cm.lineComment(from, to, options);\n      }\n    }\n  });\n\n  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = self.getModeAt(from);\n    var commentString = options.lineComment || mode.lineComment;\n    if (!commentString) {\n      if (options.blockCommentStart || mode.blockCommentStart) {\n        options.fullLines = true;\n        self.blockComment(from, to, options);\n      }\n      return;\n    }\n    var firstLine = self.getLine(from.line);\n    if (firstLine == null) return;\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n    var pad = options.padding == null ? \" \" : options.padding;\n    var blankLines = options.commentBlankLines || from.line == to.line;\n\n    self.operation(function() {\n      if (options.indent) {\n        var baseString = null;\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i);\n          var whitespace = line.slice(0, firstNonWS(line));\n          if (baseString == null || baseString.length > whitespace.length) {\n            baseString = whitespace;\n          }\n        }\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i), cut = baseString.length;\n          if (!blankLines && !nonWS.test(line)) continue;\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n        }\n      } else {\n        for (var i = from.line; i < end; ++i) {\n          if (blankLines || nonWS.test(self.getLine(i)))\n            self.replaceRange(commentString + pad, Pos(i, 0));\n        }\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = self.getModeAt(from);\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) {\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n        self.lineComment(from, to, options);\n      return;\n    }\n\n    var end = Math.min(to.line, self.lastLine());\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\n    var pad = options.padding == null ? \" \" : options.padding;\n    if (from.line > end) return;\n\n    self.operation(function() {\n      if (options.fullLines != false) {\n        var lastLineHasText = nonWS.test(self.getLine(end));\n        self.replaceRange(pad + endString, Pos(end));\n        self.replaceRange(startString + pad, Pos(from.line, 0));\n        var lead = options.blockCommentLead || mode.blockCommentLead;\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n          if (i != end || lastLineHasText)\n            self.replaceRange(lead + pad, Pos(i, 0));\n      } else {\n        self.replaceRange(endString, to);\n        self.replaceRange(startString, from);\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = self.getModeAt(from);\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\n    // Try finding line comments\n    var lineString = options.lineComment || mode.lineComment, lines = [];\n    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n    lineComment: {\n      if (!lineString) break lineComment;\n      for (var i = start; i <= end; ++i) {\n        var line = self.getLine(i);\n        var found = line.indexOf(lineString);\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n        if (found == -1 && (i != end || i == start) && nonWS.test(line)) break lineComment;\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n        lines.push(line);\n      }\n      self.operation(function() {\n        for (var i = start; i <= end; ++i) {\n          var line = lines[i - start];\n          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n          if (pos < 0) continue;\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n          didSomething = true;\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n        }\n      });\n      if (didSomething) return true;\n    }\n\n    // Try block comments\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) return false;\n    var lead = options.blockCommentLead || mode.blockCommentLead;\n    var startLine = self.getLine(start), endLine = end == start ? startLine : self.getLine(end);\n    var open = startLine.indexOf(startString), close = endLine.lastIndexOf(endString);\n    if (close == -1 && start != end) {\n      endLine = self.getLine(--end);\n      close = endLine.lastIndexOf(endString);\n    }\n    if (open == -1 || close == -1 ||\n        !/comment/.test(self.getTokenTypeAt(Pos(start, open + 1))) ||\n        !/comment/.test(self.getTokenTypeAt(Pos(end, close + 1))))\n      return false;\n\n    // Avoid killing block comments completely outside the selection.\n    // Positions of the last startString before the start of the selection, and the first endString after it.\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n    // Positions of the first endString after the end of the selection, and the last startString before it.\n    firstEnd = endLine.indexOf(endString, to.ch);\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\n    self.operation(function() {\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n                        Pos(end, close + endString.length));\n      var openEnd = open + startString.length;\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n      if (lead) for (var i = start + 1; i <= end; ++i) {\n        var line = self.getLine(i), found = line.indexOf(lead);\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n        var foundEnd = found + lead.length;\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n      }\n    });\n    return true;\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/addon/comment/comment.js\n ** module id = 10\n ** module chunks = 0 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var map = CodeMirror.keyMap.sublime = {fallthrough: \"default\"};\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  var mac = CodeMirror.keyMap[\"default\"] == CodeMirror.keyMap.macDefault;\n  var ctrl = mac ? \"Cmd-\" : \"Ctrl-\";\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type;\n    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { type = \"w\"; continue; }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  cmds[map[\"Alt-Left\"] = \"goSubwordLeft\"] = function(cm) { moveSubword(cm, -1); };\n  cmds[map[\"Alt-Right\"] = \"goSubwordRight\"] = function(cm) { moveSubword(cm, 1); };\n\n  var scrollLineCombo = mac ? \"Ctrl-Alt-\" : \"Ctrl-\";\n\n  cmds[map[scrollLineCombo + \"Up\"] = \"scrollLineUp\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds[map[scrollLineCombo + \"Down\"] = \"scrollLineDown\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"L\"] = \"splitSelectionByLine\"] = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  map[\"Shift-Tab\"] = \"indentLess\";\n\n  cmds[map[\"Esc\"] = \"singleSelectionTop\"] = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds[map[ctrl + \"L\"] = \"selectLine\"] = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  map[\"Shift-\" + ctrl + \"K\"] = \"deleteLine\";\n\n  function insertLine(cm, above) {\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n  }\n\n  cmds[map[ctrl + \"Enter\"] = \"insertLineAfter\"] = function(cm) { insertLine(cm, false); };\n\n  cmds[map[\"Shift-\" + ctrl + \"Enter\"] = \"insertLineBefore\"] = function(cm) { insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds[map[ctrl + \"D\"] = \"selectNextOccurrence\"] = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      if (cur.findNext()) {\n        cm.addSelection(cur.from(), cur.to());\n      } else {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        if (cur.findNext())\n          cm.addSelection(cur.from(), cur.to());\n      }\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var pos = cm.getCursor(), opening = cm.scanForBracket(pos, -1);\n    if (!opening) return;\n    for (;;) {\n      var closing = cm.scanForBracket(pos, 1);\n      if (!closing) return;\n      if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n        cm.setSelection(Pos(opening.pos.line, opening.pos.ch + 1), closing.pos, false);\n        return true;\n      }\n      pos = Pos(closing.pos.line, closing.pos.ch + 1);\n    }\n  }\n\n  cmds[map[\"Shift-\" + ctrl + \"Space\"] = \"selectScope\"] = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds[map[\"Shift-\" + ctrl + \"M\"] = \"selectBetweenBrackets\"] = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  cmds[map[ctrl + \"M\"] = \"goToBracket\"] = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1);\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1);\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  var swapLineCombo = mac ? \"Cmd-Ctrl-\" : \"Shift-Ctrl-\";\n\n  cmds[map[swapLineCombo + \"Up\"] = \"swapLineUp\"] = function(cm) {\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[swapLineCombo + \"Down\"] = \"swapLineDown\"] = function(cm) {\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  map[ctrl + \"/\"] = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds[map[ctrl + \"J\"] = \"joinLines\"] = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"D\"] = \"duplicateLine\"] = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  map[ctrl + \"T\"] = \"transposeChars\";\n\n  function sortLines(cm, caseSensitive) {\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = range[++i].to().line;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort();\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -1 : a == b ? 0 : 1;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: end});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds[map[\"F9\"] = \"sortLines\"] = function(cm) { sortLines(cm, true); };\n  cmds[map[ctrl + \"F9\"] = \"sortLinesInsensitive\"] = function(cm) { sortLines(cm, false); };\n\n  cmds[map[\"F2\"] = \"nextBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds[map[\"Shift-F2\"] = \"prevBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds[map[ctrl + \"F2\"] = \"toggleBookmark\"] = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"F2\"] = \"clearBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds[map[\"Alt-F2\"] = \"selectBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  map[\"Alt-Q\"] = \"wrapLines\";\n\n  var cK = ctrl + \"K \";\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  map[cK + ctrl + \"Backspace\"] = \"delLineLeft\";\n\n  cmds[map[\"Backspace\"] = \"smartBackspace\"] = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    var cursor = cm.getCursor();\n    var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n    var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n    var indentUnit = cm.getOption(\"indentUnit\");\n\n    if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n      var prevIndent = new Pos(cursor.line,\n        CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n      // If no smart delete is happening (due to tab sizing) just do a regular delete\n      if (prevIndent.ch == cursor.ch) return CodeMirror.Pass;\n\n      return cm.replaceRange(\"\", prevIndent, cursor, \"+delete\");\n    } else {\n      return CodeMirror.Pass;\n    }\n  };\n\n  cmds[map[cK + ctrl + \"K\"] = \"delLineRight\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[cK + ctrl + \"U\"] = \"upcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds[map[cK + ctrl + \"L\"] = \"downcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds[map[cK + ctrl + \"Space\"] = \"setSublimeMark\"] = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds[map[cK + ctrl + \"A\"] = \"selectToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds[map[cK + ctrl + \"W\"] = \"deleteToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds[map[cK + ctrl + \"X\"] = \"swapWithSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds[map[cK + ctrl + \"Y\"] = \"sublimeYank\"] = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  map[cK + ctrl + \"G\"] = \"clearBookmarks\";\n  cmds[map[cK + ctrl + \"C\"] = \"showInCenter\"] = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  cmds[map[\"Shift-Alt-Up\"] = \"selectLinesUpward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line > cm.firstLine())\n          cm.addSelection(Pos(range.head.line - 1, range.head.ch));\n      }\n    });\n  };\n  cmds[map[\"Shift-Alt-Down\"] = \"selectLinesDownward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line < cm.lastLine())\n          cm.addSelection(Pos(range.head.line + 1, range.head.ch));\n      }\n    });\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds[map[ctrl + \"F3\"] = \"findUnder\"] = function(cm) { findAndGoTo(cm, true); };\n  cmds[map[\"Shift-\" + ctrl + \"F3\"] = \"findUnderPrevious\"] = function(cm) { findAndGoTo(cm,false); };\n  cmds[map[\"Alt-F3\"] = \"findAllUnder\"] = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n  map[\"Shift-\" + ctrl + \"[\"] = \"fold\";\n  map[\"Shift-\" + ctrl + \"]\"] = \"unfold\";\n  map[cK + ctrl + \"0\"] = map[cK + ctrl + \"j\"] = \"unfoldAll\";\n\n  map[ctrl + \"I\"] = \"findIncremental\";\n  map[\"Shift-\" + ctrl + \"I\"] = \"findIncrementalReverse\";\n  map[ctrl + \"H\"] = \"replace\";\n  map[\"F3\"] = \"findNext\";\n  map[\"Shift-F3\"] = \"findPrev\";\n\n  CodeMirror.normalizeKeyMap(map);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/keymap/sublime.js\n ** module id = 11\n ** module chunks = 0 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var Pos = CodeMirror.Pos;\n\n  function SearchCursor(doc, query, pos, caseFold) {\n    this.atOccurrence = false; this.doc = doc;\n    if (caseFold == null && typeof query == \"string\") caseFold = false;\n\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n    this.pos = {from: pos, to: pos};\n\n    // The matches method is filled in based on the type of query.\n    // It takes a position and a direction, and returns an object\n    // describing the next occurrence of the query, or null if no\n    // more matches were found.\n    if (typeof query != \"string\") { // Regexp match\n      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? \"ig\" : \"g\");\n      this.matches = function(reverse, pos) {\n        if (reverse) {\n          query.lastIndex = 0;\n          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;\n          for (;;) {\n            query.lastIndex = cutOff;\n            var newMatch = query.exec(line);\n            if (!newMatch) break;\n            match = newMatch;\n            start = match.index;\n            cutOff = match.index + (match[0].length || 1);\n            if (cutOff == line.length) break;\n          }\n          var matchLen = (match && match[0].length) || 0;\n          if (!matchLen) {\n            if (start == 0 && line.length == 0) {match = undefined;}\n            else if (start != doc.getLine(pos.line).length) {\n              matchLen++;\n            }\n          }\n        } else {\n          query.lastIndex = pos.ch;\n          var line = doc.getLine(pos.line), match = query.exec(line);\n          var matchLen = (match && match[0].length) || 0;\n          var start = match && match.index;\n          if (start + matchLen != line.length && !matchLen) matchLen = 1;\n        }\n        if (match && matchLen)\n          return {from: Pos(pos.line, start),\n                  to: Pos(pos.line, start + matchLen),\n                  match: match};\n      };\n    } else { // String query\n      var origQuery = query;\n      if (caseFold) query = query.toLowerCase();\n      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};\n      var target = query.split(\"\\n\");\n      // Different methods for single-line and multi-line queries\n      if (target.length == 1) {\n        if (!query.length) {\n          // Empty string would match anything and never progress, so\n          // we define it to match nothing instead.\n          this.matches = function() {};\n        } else {\n          this.matches = function(reverse, pos) {\n            if (reverse) {\n              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);\n              var match = line.lastIndexOf(query);\n              if (match > -1) {\n                match = adjustPos(orig, line, match);\n                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n              }\n             } else {\n               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);\n               var match = line.indexOf(query);\n               if (match > -1) {\n                 match = adjustPos(orig, line, match) + pos.ch;\n                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n               }\n            }\n          };\n        }\n      } else {\n        var origTarget = origQuery.split(\"\\n\");\n        this.matches = function(reverse, pos) {\n          var last = target.length - 1;\n          if (reverse) {\n            if (pos.line - (target.length - 1) < doc.firstLine()) return;\n            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;\n            var to = Pos(pos.line, origTarget[last].length);\n            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)\n              if (target[i] != fold(doc.getLine(ln))) return;\n            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;\n            if (fold(line.slice(cut)) != target[0]) return;\n            return {from: Pos(ln, cut), to: to};\n          } else {\n            if (pos.line + (target.length - 1) > doc.lastLine()) return;\n            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;\n            if (fold(line.slice(cut)) != target[0]) return;\n            var from = Pos(pos.line, cut);\n            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)\n              if (target[i] != fold(doc.getLine(ln))) return;\n            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;\n            return {from: from, to: Pos(ln, origTarget[last].length)};\n          }\n        };\n      }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false);},\n    findPrevious: function() {return this.find(true);},\n\n    find: function(reverse) {\n      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n      function savePosAndFail(line) {\n        var pos = Pos(line, 0);\n        self.pos = {from: pos, to: pos};\n        self.atOccurrence = false;\n        return false;\n      }\n\n      for (;;) {\n        if (this.pos = this.matches(reverse, pos)) {\n          this.atOccurrence = true;\n          return this.pos.match || true;\n        }\n        if (reverse) {\n          if (!pos.line) return savePosAndFail(0);\n          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);\n        }\n        else {\n          var maxLine = this.doc.lineCount();\n          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);\n          pos = Pos(pos.line + 1, 0);\n        }\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from;},\n    to: function() {if (this.atOccurrence) return this.pos.to;},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return;\n      var lines = CodeMirror.splitLines(newText);\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n    }\n  };\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos) {\n    if (orig.length == folded.length) return pos;\n    for (var pos1 = Math.min(pos, orig.length);;) {\n      var len1 = orig.slice(0, pos1).toLowerCase().length;\n      if (len1 < pos) ++pos1;\n      else if (len1 > pos) --pos1;\n      else return pos1;\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold);\n  });\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold);\n  });\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = [];\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break;\n      ranges.push({anchor: cur.from(), head: cur.to()});\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0);\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/addon/search/searchcursor.js\n ** module id = 12\n ** module chunks = 0 1\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\n  function findMatchingBracket(cm, where, strict, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  var currentlyHighlighted = null;\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init)\n      cm.off(\"cursorActivity\", doMatchBrackets);\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, strict, config){\n    return findMatchingBracket(this, pos, strict, config);\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/codemirror/addon/edit/matchbrackets.js\n ** module id = 13\n ** module chunks = 0 1\n **/"],"sourceRoot":""}